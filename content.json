[{"title":"需求分析","date":"2018-12-09T09:38:27.000Z","path":"2018/12/09/需求分析/","text":"1 需求的定义1.1 什么是需求需求是为了满足某类用户的某种欲望或解决某些问题时所产生的现象 1.2 需求的层次马斯洛需求层次理论 生理需求&gt;安全需求&gt;社交需求&gt;尊重需求&gt;自我实现 生理需求：饿了么安全需求：360社交需求：QQ，微信尊重需求：知乎自我实现：抖音 1.3 刚需/痛点，痒点 痛点对应的就是解决核心的问题，痛点就是刚需 痒点就是满足欲望，是消费升级的副产品 2 需求的来源2.1 需求的分类需求按分类分为内部需求和外部需求 内部需求 外部需求 用户需求 客户/合作需求 运营需求 市场需求 技术需求 数据需求 用户需求解决或满足用户在某些场景下为了达到某些目的所产生的需求 运营需求满足公司内部运营对某类事件或活动所产生的推广等性质的需求 技术需求代码重构，系统安全等，技术人员提出的需求 数据需求 基本数据 用户数据 点击埋点 路径漏斗 数据知道产品，需要做到问道任何数据，均可以流畅的回答 客户需求/合作需求 需要平衡商业展示和用户体验（比如：观看视频之前的广告，有一定的收入但是影响用户体验） 市场/战略需求 战略需求往往代表着市场的前沿，具有一定的前瞻性与风险 2.2 需求的来源 用户访谈 主要通过用户调研和市场调研 定性|定量面对面访谈|问卷调查可用性测试|PUSH|有偿调查 定性走开放性问题，定量走简单可选择的问题观察&gt;引导，深挖但不被误导 数据分析通过基础的数据分析辅佐你想要优化的方向，是做需求的核心目的之一。 基本数据 Crash DAU/MAU 留存 用户数据 性别 地狱 标签（包括购买率，页面流失情况，功能使用情况，产品情况） 点击埋点 点击次数 点击人数 路径漏斗 页面层级 页面流失 竞品分析 选择相当的竞品 功能颗粒度足够细 长期维护（带版本） 发觉竞品路线 学会标注重点 用户反馈用户反馈主要通过用户评论用户反馈还可以通过微博，QQ/微信群，贴吧，亲朋好友，各类应用市场获取 头脑风暴 3-8人 定义一个主题 提前准备 3 需求的提炼3.1 四要素比对需求提炼中注意4个要素 人物 场景 任务 目标 案例：建议能将运动中拍到的照片传到运动的轨迹中去，便于查询存档。 人物 场景 任务 目标 用户属性 运动结束后 上传照片到轨迹 查询，存档？ 运动属性 一个爱运动的女性 人物 场景 任务 目标 使用者&amp;决策者 用户使用场景vs产品提供场景 多样性 用户的目标vs我们的目标 人群：宽&amp;窄 复杂程度 用户属性 习惯性的对每个需求都拆分成4个结构，并对其进行分析比对，然后筛选出我们真正的需求。 3.2 需求的转化"},{"title":"竞品分析","date":"2018-12-09T02:35:50.000Z","path":"2018/12/09/竞品分析/","text":"1 竞品分析的概念介绍1.1 什么是竞品分析竞品分析顾名思义，是对竞争对手的产品进行比较分析。值对现有的潜在竞争产品的优势和劣势进行评价。在用户体验行业，则更加倾向于同类产品的分析，特别是产品交互界面，视觉表现方面的分析。 1.2 什么时候竞品分析竞品分析使用阶段以及调研目标我们来看一个表格，表格从左到右是项目的进展 需求分析 立项 设计阶段 上线验证 产品经理 确定方向，了解市场 差异点，功能，框架创新，优缺点分析 用户研究 参考竞品用户群体以及需求优先级 对比竞品已完成情况，用户反馈，输出结果 交互设计 竞品主要任务流程，页面框架，逻辑性，页面语言风格 视觉设计 色彩，颜色层次，页面细节 1.3 竞品分析的目的 选中目标+行为移植+价值分析 = 收益 找准对的目标，寻找目标身上的价值移植到我们的产品中，并添加我们自己的价值来创造收益 选择&gt;分析&gt;罗列 1.4 如何做竞品分析 选择竞品 竞品选择我们有两种，一种是直接对手，一种是间接对手 直接对手： 市场范围相似&amp;商业模式相似 客户群体相似 产品功能差异不大 间接对手： 市场范围相同&amp;商业模式不同 客户群体相似 产品功能互补，或未来存在重叠的可能 分析维度和决策依据我们可以列出一个excel表格来分析 竞品1 竞品2 竞品3 维度1 数据 维度1 分析维度的选择取决于你的目标，例如 目标1：我想知道哪些功能，哪些功能属性必不可少，值得借鉴一番（维度：功能穷举） 目标2：我想知道如何进行细节设计（维度：操作任务） 目标3：我想知道这些产品最终突出细节特点是什么，值得借鉴一番（维度：设计特点） 决策依据则反映了你的专业性这么多维度的结果数据，你到底在乎哪些？目标1：我想知道哪些功能，哪些功能属性必不可少，值得借鉴一番（维度：功能穷举）以新闻为例 腾讯新闻（优先级3星） 网易新闻（优先级3星） … 内容 新闻头条 分类新闻 图片 视频 专题 博客 比赛分数 股票市场信息 新闻（网友） 评论（媒体） 评论（媒体） 功能 新闻排行 follow新闻 用户编辑贡献新闻 根据位置推送新闻 自定义导航 天气 投票 目标2：我想知道如何进行细节设计（维度：操作任务）就是基于用户的视角来体验产品 打开应用 选择频道 浏览标题列表 刷新 获取更多 进入/推出文章 阅读文章 阅读 自定义阅读模式（字体，背景） 查看文章内图片 分享/保存/收藏 阅读上一篇/下一篇 返回标题列表 浏览图片 查看图片 图片切换 获取数据 可以试用通过用户了解竞争产品使用百度指数等工具获取数据拨打竞争产品的客服了解竞品产品 分析 提出合理假设：我们认为某某竞品的成功因素如下…在这些要点中，他们形成了如下的闭环…这个闭环的业务链条，对其所相关的用户/商家等操作者带来了如下的价值… 对假设进行逆向确认如果没有某某功能要点，竞品的价值链条会变成下面这样…这可能导致的结果有… 对自己的产品进行剖析现在我们对标的产品，其在应用价值方面，优缺点如下…我们的价值链条用如下方式闭环…我们对相关的用户/商家等操作者带来了如下价值…与竞争对手相比，我们的整条价值链的差异在哪里…这些差异会导致我们好竞品的敌手存在这些强弱之处… 在SWOT模型中一般SO说的是自己，WT说的是自己与竞品对比后的结果 给出可执行的结论经过以上分析，我们的产品改进方向如下…改进步骤如下…改进的各个阶段，我们对竞标产品的竞争优势情况如下… 沟通 深入其中的人往往忘记了别人还在边缘把自己当做一个教室重复重复再重复 1.5 竞品分析模板 行业背景 确定竞品 竞品分析3.1 定位及功能 产品定位（包括目标人群等） 产品功能3.2 设计和技术 交互和体验 视觉和风格 亮点功能和核心技术3.3 运营及商业化 运营模式 盈利模式 市场推广3.4 用户数据 用户数量和活跃度 转化率，健康度 在线时长 地域差异3.5 策略 版本迭代和演变 公司策略3.6 优缺点借鉴 总结 2 几个问题 为什么市场分析已经做了精品相关的内容，还需要专门做竞品分析？ 对应的时机不同：时长分析一般是在初试一个产品的时候进行的。而竞品分析则会在产品的整个生命迭代周期里都会做 侧重点不同：市场分析的竞品分析内容，基本上是蜻蜓点水的进行简要概括，而竞品分析则非常细致，从流程，界面，用户体验，核心价值点等各个方面进行比对。 我做了一个创新产品，在世面上好像没有类似的产品，那竞品分析怎么搞? 不用搞，请专注于市场分析，并明确产品迭代策略，等精品出现了再去研究它。"},{"title":"市场分析","date":"2018-12-08T03:17:36.000Z","path":"2018/12/08/市场分析/","text":"1. 市场容积我们经常听到一种说辞：这个项目，我个人感觉有/没有市场。。。我都是生活在一个真实的世界中，我们都会对某件事物接受程度有个模糊认识，其中最典型的就是如果你处在某个行业，或者热衷于某个领域，就会觉得周围都是在这个领域中的人，就会觉得这个领域中的想法很有市场其实这个只是一个很片面，很模糊的观点，大多数都很不靠谱 1.1 市场容积分析我们首先要考虑3个问题 目标用户群体量多大？有多少市场潜力 （他们有多少人） 针对目标产品，其应对的用户群的需求点有那些？（他们用了我产品会变成什么样） 目标用户痛点如何？当前在用何种方式解决？（他们现在怎么样） 市场容量分析是产品落地的基础当我们有一个点子出现的时候，如果要落地为产品，总要做下市场容量分析。1) 看看自己的点子前景如何？2) 也为后期争取项目资源做好理论依据。 1.2 如何获取市场容积具体操作是需要我们收集一些权威的网站报告。比如中研网,中国报告大厅,中国产业信息研究网当然我们也可以去百度文库搜索搜索 案例：家电医保卡12345根据商务部流通服务业典型企业调查数据，2014年家电服务业全国经营单位有10.8万个，从业人员为312.1万人，全行业四项主要业务（装，洗，养，修）营业收入为1956.5亿元，比2013年提高了11.8%。2014年的数据表明，家电服务市场已经在我国形成了千亿级别的市场，而且保持了较高的增长率。（数据来源：《中国家电服务行业发展报告2015》） 家电医保卡。这是一个针对家电进行售后服务的产品，这个案例中总结几个小技巧1) 一般来说，隔一年的诗句是很容易看到免费报告的。类似2017年能看到2015年报告。2) 所以，如果出现这种情况，记得做下趋势/增长率分析。这会对我们预估现有的市场容量做一个参考。3) 要有产品针对性。例如家电医保卡这种需要地域竞争的产品，就需要做好地域分布分析。 2. 需求点2.1 什么是需求点继续看上面的例子。众所周知，大家电品类是现在电商的重点品类，仅天猫，京东，苏宁等电商，该品类的年GMV汇总已经超过千亿元。可是，在购买了大家电以后，下一步的电商服务会有哪些？ 电器品类 服务市场需求点 空调 清除过滤网，蒸发器等内部灰尘，清除病菌潜在危险 内外机移机，主要有搬家等场景，让空调在新的地点继续使用 油烟机 解决用户自行清洗的费时费力，以及专业的清洗效果 洗衣机 清除内外桶之间积垢，消除病菌潜在的危险 冰箱 清除冰箱内部污垢，消除异味 热水器 清除热水器内外水垢，杂质，提高电器工作效率 热水器移机，同样也是搬家场景，让热水器在新的地点继续使用 根据以上表格，我们可以总结出几下几个需求点 健康：因作业的专业性，用户无法自行动手。这一类的情况，对此健康生活不关注的用户经常放任不管，只有特别关注健康的用户会有持续性的需求。 便捷和省钱：用户可以自己动手，但是费时费力。这一类情况，用户关注一般就是便捷和省钱，否则就会生出“还不如我自己来弄”的想法 专业：用户无法自己动手。这一类的情况，用户关注的这是主要是作业的专业性。“当初花那么多钱买的千万别给搞坏了” 2.2 如何获取需求点我们主要有两种方式：用户拜访，问卷调查 好处 坏处 用户拜访 发挥空间大，可以采集很多无法格式化的信息 不好大面积推开，只能安排少量人员去执行，不好事后统计，需要执行者自行总结和整理 问卷调查 格式化的问卷调查有利于统计和分析，可以借助客服/市场团队的资源，大面积进行 问卷调查的内容是预先设定好的，缺乏变通，对不能格式化的信息无法获取 所以我们一般的做法是 先进行用户拜访 格式化出问题 大范围问卷调查 3. 产品方案3.1 结合自身，锁定人群我们分析了市场容积和用户的需求点，这时候我们就可以总结出我们想要的结果，一个产品方案记住，没有一款产品可以包打天下，我们要说的不是宏观市场有多大，而是我们的市场有多大 可以投入的资源 + 需要锁定的人群 》》 可以得到的经济价值 以家电医保卡为例 可以投入的资源： 1500个家电网点 覆盖全国98%的城市 涵盖空调，冰箱洗衣机，各种家电等服务范围 需要锁定的人群： 健康？省钱+便捷？专业？ 可以得到的经济价值 通过测算用户的使用率和标准用户的平均消费情况来计算预期市场经济价值 我们可以看一个样本 电器品类 数量（台/户） 清晰频次（次/年） 清洗市场单价（元） 成本（元） 空调 1.5 2 120 70 油烟机 1 1 150 90 洗衣机 1 1 120 70 冰箱 1 0.5 120 70 热水器 1 0.5 120 70 年度合计 6 7 750 440 123456我国家庭数量已经到到3.5亿多户，城镇家庭约2亿户根据用例选择，在一年类进行验算如下：1. 按10%的用户清洗市场需求，收入预期为 750元*2000万人 = 150亿2. 按1%的用户清洗市场需求，收入预期为 750元*200万人 = 15亿3. 按0.1%的用户清洗市场需求，收入预期为 750元*20万人 = 1.5亿随着人均收入的不断提升及健康意识增强，用户的清洗需求率会不断提高，市场容量也不断增大 3.2推导产品方案有了我们的资源有了我们的用户现在我们可以推导出产品的方案：我们有什么？我们如何包装我们的资源？这里我们需要区分核心资源和增值资源 核心资源：用来解决用户的痛点 增值资源：用来帮用户下最后的决心，解决转化率问题 已有能力 售后（核心） 客服 金融 安装，清洗，维修 免取件费，快递退换货专享通道 延保，意外保障 结合这些已有能力我们可以推出以下套餐 服务类型 套餐内容 延保服务 延长保修一年 清洗（核心） 洗衣机清洗一次 清洗（核心） 烟灶清洗套餐服务一次 客服 专属通道 物流 运费券 4. 竞争力分析如果我们锁定了我们的产品方案，那我们要看看，市场上有哪些雷同的产品他们的市场占有率如何，产品竞争力如何我们的定义的目标产品方案，是否有足够的生存空间？ 4.1 竞品调研一般来说，竞争力分析主要有两种： 如果有明确的市场对标对象，则对这个对标对象进行单一对标分析 如果没有明确的市场对标对象，则需要列举市场上主要的TOP级竞争对手，逐一做单一分析，最后汇总。 竞品分析调研 天猫： 无理由保修 免费维修 三包范围外的因灰尘，受热，内部潮湿/冷凝，动力高峰/电压不稳所引起的故障 除修复产品故障外，还额外提供100元/次的服务满意金现金。 享受减免80%维修费用的优惠维修服务 由于疏忽或不慎跌落，碰撞，挤压而造成意外损坏导致产品无法使用的情况下 除修复产品故障外，还额外提供100元/次的服务满意金现金 换新服务 如产品被严重损坏经检测判断故障无法修复或维修费用高于故障产品市场零售价时，消费者支付少量的折旧费，即可获得服务商提供的换新服务 京东： 会员plus 150元/年 首次体验价149元 免费试用30天 2张运费券 购买正版后返京东豆 专享客服 退换无忧 免（退换维修）运费 免费上门取件 畅销电子书一年 自营运费补贴 60张运费券 购物回馈 按照品类回馈0.5%-2%的京东豆（&lt;=2000元价值京东豆） 亚马逊 亚马逊prime 388元/年 海外购订单 单比订单满200元，无限次跨境免运费 国内订单 零门槛，无限次免邮（自营+平台） 免费试享30天 首次体验价188元 总结 网站 售后 物流 客服 其他增值 促销 试用期 定价 总结 京东 / 60张运费券 专享客服，免（退换维修）运费，免费上门取件 畅销电子书一年，按照品类回馈0.5%-2%的京东豆 圣诞1元试用，京准达 30天，2张运费券 首次149元，150元/年 核心不凸显 亚马逊 / 海外购单比订单满200元，无限次跨境免运费，国内订单零门槛，无限次免邮（自营+平台） / / / 30天 首次体验价188元，388元/年 重叠度不高 天猫 三包范围外的因灰尘，受热，内部潮湿/冷凝，动力高峰/电压不稳所引起的故障，由于疏忽或不慎跌落，碰撞，挤压而造成意外损坏导致产品无法使用的情况下，除修复产品故障外，还额外提供100元/次的服务满意金现金，换新服务 / / / / / 按品类按价格段定价 缺乏增值能力 这个时候，我们可以推导出：与竞争对手相比，我们的竞争力体现在地方… 4.2 竞争力分析工具我们一般采用SWOT分析法对竞争力分析的结果进行总汇： 内因 外因 正面 优势(售后资源优势，累积了大量的家电用户群) 机会（市场上尚无引领性厂商，老百姓需求迫切度高，市场潜力巨大） 负面 劣势（销售优势品类单一：清洗增值服务不够吸引人） 挑战（服务规范化难度大，参差不齐，政府支持力度不够，缺乏支撑） 如何做SWOT分析呢？ 内因：QCDMS法 从质量，价格，能力，技术，资产，销量五个方面去分析 按照重要程度，列举有重要意义的内容 外因：PEST法 从政策法律，宏观经济，社会情况，整体技术水平四个方面去分析 按照重要程度，列举有重要意义的内容 SWOT分析的核心可以认为是两部分： 优势与劣势（S/W）：这一部分是分析内因 机会与挑战（O/T）：这一部分是分析外因 5. 产品迭代策略5.1 SWOT策略最后我们根据市场分析情况来确定我们的产品迭代策略：先切分哪块市场？先对标哪个主要的竞争对手？先包装哪些内容？第二步，第三步如何? 策略名称 策略解释 总结 WT策略 (劣势挑战) 努力让自己的弱势最小化，努力避免风险 守城，慢慢来吧 SO策略（优势机会） 努力让自己的优势最大化，让机会最大化 高风险，玩的就是心跳 WO策略（劣势机会） 努力你不自己弱势，从而努力赢得一些机会 现实主义，小富即安 ST策略（优势挑战） 努力让自己优势最大化，并通过减少风险，消除威胁因素 镣铐舞蹈，苦乐掺半 小米最开始为发烧而生就是SO策略，只做最低价来占领市场（当时智能机很贵），不顾其他性能和温度。直到小米4才开始有设计注重性能开始WO策略 5.2 推导迭代策略根据上面说明的我们来推导我们的家电医保卡迭代策略 版本 策略 目的 说明 一期 SO策略 冷启动，先进入清洗市场 万屋清新-清洗服务，增值服务-免邮/客服 二期 WO策略 弥补缺点，对标天猫，赢在价值 苏宁帮客-维修服务，增值服务-延保/免邮/客服 三期 WT策略 规范服务质量，开启价格战模式，丰富内容 万事无忧-增值服务强化，服务治理-淘汰，评分 5.3 迭代策略总结 首先我们确定的迭代策略一定是基于SWOT的分析结果。 其次在不同的产品阶段，我们可以采用不同的策略来指导产品方案 例如在冷启动阶段，我们可以采用高风险的策略，来赢得尽可能多的机会，以保证冷启动的成功，当然拼输了在这个阶段也无所谓 而在运营阶段，可以逐步弥补弱势，步步为营的去蚕食别人的市场。 在进入常规运营阶段，可以采用守城的策略，尾骨经营成果。 最后，不要拘泥于形式和套路 市场与市场竞争是一种很灵活的东西，受大量的不定因素左右，有时候后有些创造力是可以的。 6 总结6.1 市场分析总结 市场容量分析 大小 趋势 分类 需求点 锁定产品方案 我们有什么 我们打算切割哪块市场 竞争力分析 咱们那啥跟他们斗 迭代策略 咱们怎么切入这个市场 6.2 市场分析报告 市场分析 市场容量分析（当前规模） 增长趋势分析（近几年的增长速率和增长点） 市场需求分析 典型目标人群介绍 归纳核心需求点 建议目标产品方案描述 建议目标产品方案描述 对标竞争对手，做竞争力对比 通过SWOT分析，做出分析汇总 建议市场竞争策略 搬出SWOT分析结果，选择对策策略 明确产品迭代策略，写出RoadMap 注意：我们不是市场分析师，我们的公司也不是咨询机构在我们的工作中，基本上不可能进行规模浩大的市场分析。因为如果消耗成本去完成一次大规模的市场调研分析，还不如把成本投入去试错。所以，请把市场分析工作做的简短和直接，以需求为向导，以产品为核心"},{"title":"MySQL高级","date":"2018-12-04T01:18:52.000Z","path":"2018/12/04/MySQL高级/","text":"0 视图0.1 视图定义视图是有查询结果形成的一张虚拟表，是表通过某种运算得到的一个投影。同一张表可以创建多个视图创建视图语法： create view 视图名称 as select 语句 说明： 视图名跟表名是一个级别的名字，隶属于数据库； 该语句的含义可以理解为：就是将该select命名为该名字（视图名） 该视图也可以设定自己的字段名，而不是select语句本身的字段名（通常不设置） 视图的使用几乎和表一样（只不过一般都用做查询，很少增删改，增删改在后面说明） 0.2 视图的作用 可以简化查询案例：1.查询平均价格前3的栏目以前的SQL语句1select cat_id,avg(shop_price) as pj from ecs_goods group by cat_id order by pj limit 3; 应用视图的1) 创建一个视图1create view ecs_goods_v1 as select cat_id,avg(shop_price) as pj from ecs_goods group by cat_id; 2) 查询平均价格前3只需要查询视图即可1selcet * from ecs_goods_v1 order by pj desc limit 3; 案例：2.查询出商品表，以及所在的栏目名称以前的sql语句12select goods_id,goods_name,b.cat_name,shop_price from ecs_goods a left join ecs_category b on a.vat_id=b.cat_id 1) 创建视图123create view ecs_goods_v2 as select goods_id,goods_name,b.cat_name,shop_price from ecs_goods a left join ecs_category b on a.vat_id=b.cat_id 2) 查询视图1selcet * from ecs_goods_v2; 可以进行权限控制把表的权限封闭，但是开放相应的视图权限，视图里只开放部分数据，比如用户表为例，两个网站搞合作，可以查询对方网站的用户，需要向对方开放用户表的权限，但是又不想开放用户表中的密码字段。再比如一个goods表，两个网站搞合作，可以互相查询对方的商品列表，比如进货价格字段不能让对方看到案例1) 创建一个视图，视图中不能包含进价字段（in_price）1creat view goods_v1 as select id,goods_name,shop_price from goods; 2) 创建一个用户，授予查询权限，只能操作goods_v1表（视图）1grant select on php.goods_v1 to &apos;xiaoming&apos;@&apos;%&apos; identified by &apos;123456&apos;; 3) 这样就把新建的用户给合作方 0.3 视图操作 查询视图语法： select * from 视图名 [where 条件] 视图和表一样，可以添加where条件 修改视图 alter view 视图名称 as select …. 删除视图 drop view 视图名称 查看视图结构和表一样，语法： desc 视图名称 查看所有视图和表一样，语法： show tables; 注意：没有show views 语句 视图和表得关系表 &gt;&gt;——&gt;&gt; 视图表改变了视图就改变了视图 &gt;&gt;——&gt;&gt; 表修改：1) 如果没有计算的来的值（avg），视图改变可以影响表增加：2) 如果没有不能为空而又刚好没被视图收录的字段，视图创建可以影响创建 视图算法algorithm = merge/temptable/undefined 名称 算法 创建方式 merge 当引用视图时，引用视图的语句与定义视图的语句合并（默认） 意味着视图只是一个语句规则，当查询视图时，吧查询视图的语句与创建时语句where子句等合并，分析，形成一条select语句 temptable 当引用视图时，根据视图语句创建一张临时表 根据创建语句，瞬间创建一张临时表，然后查询视图的语句，从该临时表查询数据 undefined 未定义，让系统自动选择 1 SQL编程1.1 声明变量 会话变量定义形式 set @变量名 = 值; 说明：1) 和js类似，第一次给其赋值，就算定义了2) 它可以在变成环境和非编程环境中使用3) 使用的任何场合都该带“@”符号 普通变量定义形式： declare 变量名 类型 【default 默认值】; 说明：1) 他必须先声明（即定义），此时也可以赋值；2) 赋值跟会话变量一样set 变量名 = 值；3) 它只能在编程环境中使用！！！(编程环境指的是：存储过程，函数，触发器) 变量赋值形式1) 语法1： set 变量名 = 表达式; 此语法中的变量必须先使用declare声明 2) 语法2: set @变量名 = 表达式 此方式可以无需declare语法声明，而是直接赋值，类似js定义变量并赋值； 3) 语法3： select @变量名:= 表达式； 此语句会给变量赋值，同时还会作为一个select语句输出结果 4) 语法4： select 表达式 into @变量名; 此语句虽然看起来是select语句，但是其实并不输出结果集，而是给变量赋值 1.2运算符 算术运算符 +,-,*,/,% 注意musql没有++和-- 关系运算符 &lt; &lt;= = &lt;&gt; != 逻辑运算符 and or not 1.3语句包含模块所谓语句包含符，在js中，以及大部分其他语言中，大都是{}它用在很多场合if，switch，for，function而mysql编程包含的语句符是： begin【什么】 end【什么】 1.4条件判断MySQL支持两种判断if判断和case判断 if单分支语法： if 条件 then //代码 end if; 双分支 if 条件 then //代码1 else //代码2 end if; 多分枝 if 条件 then //代码1 elseif 条件 then //代码2 else //代码3 end if; 注意：通常情况下;表示sql的结束，同时向服务器提交并执行，但存储过程中很多SQL语句每一句都是;分开的，这时候我们就需要用其他符号来代替向服务器提交的命令 delimiter 符号 案例：接收4个数字，如果输入1=春天，2=夏天，3=秋天，4=冬天，其他=出错先修改;符号 delimiter $ 1234567891011121314create procedure p1 (n int)begin if n=1 thenselect &apos;春天&apos; as &apos;季节&apos;;elseif n=2 thenselect &apos;夏天&apos; as &apos;季节&apos;;elseif n=3 thenselect &apos;秋天&apos; as &apos;季节&apos;;elseif n=4 thenselect &apos;冬天&apos; as &apos;季节&apos;;elseselect &apos;错误&apos; as &apos;季节&apos;;end if;end$ case判断 case 变量when 值 then 语句;when 值 then 语句;else 语句;end case; 上面的例子我们改变如下 12345678910create procedure p2 (n int)begin case nwhen 1 then select &apos;春天&apos; as &apos;季节&apos;;when 2 then select &apos;夏天&apos; as &apos;季节&apos;;when 3 then select &apos;秋天&apos; as &apos;季节&apos;;when 4 then select &apos;冬天&apos; as &apos;季节&apos;;else select &apos;错误&apos; as &apos;季节&apos;;end case;end$ 1.5循环Mysql支持的循环有loop，while，repeat循环 loop循环 标签名:loopleave 标签名（退出循环）end loop; 案例：循环1到n的和 12345678910111213create procedure p3 (n int)begin declare i int default 1; declare s int default 0; aa:loop if i&gt;n then leave aa; end if; set s=s+i; set i=i+1; end loop; select s;end$ while循环 标签名 while 条件 do// 代码end while 12345678910create procedure p4 (n int)begin declare i int default 1; declare s int default 0; while i&lt;=n do set s=s+i; set i=i+1; end while; select s;end$ repeat循环 repeat// 代码until 条件 end repeat; 12345678910create procedure p5 (n int)begin declare i int default 1; declare s int default 0; repeat set s=s+i; set i=i+1; until i&gt;n end repeat; select s;end$ 2 存储过程存储过程是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过制定存储过程的名字，并给出参数（如果该存储过程携带参数）来执行。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。 2.1 好处 存储过程只是在创建时进行编译，以后每次执行存储过程不需要再重新编译，而一般SQL语句每执行一次就编译一次，所以使用存储过程可以提高数据库执行速度。 当对数据库进行复杂操作时（如对多个表进行增删改时），可以将此复杂操作用存储过程封装起来，与数据库提供的事务结合一起使用 存储过程可以重复使用，减少数据库开发人员的工作量 安全性提高，可设定只有某些用户才具有对指定的存储过程使用权限 2.2 存储过程操作 创建存储过程 1234create procedure 存储过程名称(参数1,参数2,...)begin // 代码end 存储过程的参数部分为输入参数（in），输出参数（out），输入输出参数（inout），默认是输入参数。如果存储过程中就一条语句，begin和end是可以省略的。 说明：1) 存储过程中，可有各种变成元素：（变量，流程控制，函数调用）；2) 还可以有：增删改查等各种sql语句3) 其中select（或show，或desc）会作为存储过程执行后的“结果集”返回；4)形参可以设定数据的“进出方向” 案例1：查询一个表里面某些语句 1234create procedure p10()beginselect * from ecs_goods;end; 案例2：输入一个字符串，如果是h输出价格大于1000商品，其他输出小于1000商品 12345678910create procedure p11(str char(1))beginif str = &apos;h&apos; thenselect * from ecs_goods where price&gt;1000;elseselect * from ecs_goods where price&lt;=1000;end if;end;call p11(&apos;h&apos;); 调用存储过程语法： call 存储过程() 删除存过程 语法: drop procedure [if exists] 存储过程名 创建复杂存储过程 案例1：带输出参数的存储过程 123456create procedure p12(in n int,out res int)begin set res = n*n;end;set @res=0;call p12(100,@res);selcet @res; 案例2:带有输入输出参数的存储过程123456create procedure p13(inout n int)begin set n = n*n;end;set @a = 20; call p13(@a);select @a; 2.3 变量 系统变量 MySQL启动的时候就存在的变量，以@@开头的都是系统变量 查询mysql版本： select @@version; 用户变量用户变量只要在前面加一个@就可以12set @name=&apos;linjiad&apos;;select @name; 3 函数和js中的函数几乎一样：需要先定义，然后调用。只是规定这个函数必须需要一个返回值; 3.1 定义函数语法： 123456create function 函数名(参数) returns 返回值类型begin// 代码return xx值;end; 说明：1) 函数内部可以有各种编程语言元素：变量，流程控制，函数调用；2) 函数内部可以有增删改等语句3)但：函数内部不可以有查（select或show，或desc）这种返回结果集的语句 3.2 调用跟系统函数调用一样：任何需要数据的位置，都可以调用该函数 案例1：返回两个数的和123456create function he(num1 int,num2 int) return intbeginreturn num1+num2;end;select he(100,120); 案例2: 返回1到n的和123456789101112create function hee(n int) return intbegindeclare i int default 1;declare s int default 0;while i &lt;=n doset s= s + i;set i= i + 1;end while;retuen s;end;select he(100,120); 注意：创建的函数是属于数据库的，只能在创建函数的数据库中才能使用； 3.3 SQL内部函数 数字类 1) select rand(); //返回0到1之间的随机数2) select * from it_goods //随机取出两个商品3) select floor(3.9) // 向上取整 44) select ceil(3.1) // 向下取整 35) select round(3.5) // 四舍五入 4 大小写转换 1) select ucase(‘linjiad’) //转换成大写2) select icase(‘linjiad’)//转换成小写 字符串截取 1) select left(‘abcde’,3) //从左边截取2) select right(‘abcde’,3) //从右边截取3) select substring(‘abcde’,2,3) //从第二个位置开始，截取3个4) select concat(‘abc’,’:de’) //字符串项链 10:abcde5) coalesce(str1,str2) //返回参数中的第一个非空表达式select stuname.stusex,coalesce(writtenexam,’缺考’),coalesce(labexam,’缺考’) from stuinfo6) select length(‘锄禾日当午’) //显示字节个数 107) select char_length(‘锄禾日当午’) //显示字符个数 58) select length(trim(‘ abc ‘)) //trim 用来去除字符串两边空格9) select replace(‘abc’,’bc’,’pache’) //将bc替换成pache 时间类 1) select unix_timestamp() // 时间戳2) select from unixtime(unix_timestamp()) //将时间戳转换成日期格式select from_unixtime(unix_timestamp(),’%Y-%m-%d’);3) curdate (); //返回今天得日期select curdate(); // 2018-12-074) select now();// 去除当前时间select now();// 2018-12-07 15:02:595) select year(now()) 年, mouth(now()) 月,day(now()) 天,hour(now()) 小时。minute(now()) 分,second(now()) 秒 6) select datediff(now(),’1997-7-1’)// 两个日期相聚多少天7) if(表达式,值1,值2) //类似三元云算法select concat(10,if(10%2=0,’偶数’,’奇数’))8) date_sub 和date_add //时间加减date_sub(时间日期时间,interval 数字 时间单位) ①：时间单位：可以是year month day hour minute second ②数字：可以是正数和负数（具体看案例2） 案例案例1： 查询今天得电影①curdate()求出今天的日期②把添加的时间戳，转换成日期select title from dede_archives where curdate()=from_unixtime(senddate,’%Y-%m-%d’); 案例2： 求昨天添加的电影① 去除昨天日期select date_sub(curdate(),interval 1 day)或者select date_add(curdate(),interval -1 day) 4 触发器4.1 简介 触发器是一个特殊的存储过程，它是Mysql在insert，update，delete的时候自动执行的代码块。 触发器必须定义在特定表上 自动执行，不能直接调用作用：监视某种情况并触发某种操作触发器的思路：监视X表，如果X表里面有增删改的操作，则自动触发Y里面增删改操作。比如用户表增加新用户，相应的订单表增加该用户的信息。 目前mysql不支持多个具有同一个动作，同一时间，同一事件，同一地点，的触发器。 4.2 创建触发器 监视地点（table） 监视事件（insert/update/delete） 触发时间（after/before） 触发事件（insert/update/delete） 语法： 123456create trigger 触发器名after/before inster/update/delete on 表名for each row begin // sql语句及代码（触发的语句可以是一句或多句）end 4.3 案例 案例1：第一个触发器，购买一个订单表减少一个 1) 监视地点 it_order表2) 监视事件 it_order表的inset操作3) 触发时间 it_order表的inset之后4) 触发事件 it_goods表减少库存的操作 123456create trigger t1after inster on it_orderfor each row begin update it_goods set goods_number=goods_number - 1 where id = 2;end 这个t1是有问题的，我们购买任何商品都是减少id=2的对应库存 案例2: 购买商品，减少对应库存如何在触发器中引用行的值？对于insert而言，新增的行用new来表示，行中的每一列的值，用new.列名来表示。 123456create trigger t1after inster on it_orderfor each row begin update it_goods set goods_number=goods_number - new.much where id = new.goods_id;end 案例3：取消订单时，减掉的库存要添加回来 删除行我们用old来表示，如果要引用里面的数据，则使用old.列名来表示 1) 监视地点 it_order表2) 监视事件 it_order表的delete操作3) 触发时间 it_order表的delete之后4) 触发事件 it_goods表减少库存恢复过来 123456create trigger t3after delete on it_orderfor each row begin update it_goods set goods_number=goods_number + old.much where id = old.goods_id;end 案例4：修改订单时，库存也要做对应修改（可以修改购买数量，也可以修改类型）如果是修改操作要引用it_order里面的值修改前的数据用old表示，old.列名引用被修改之前的值修改后的数据用new表示，new.列名引用被修改之后的值 1) 监视地点 it_order表2) 监视事件 it_order表的update操作3) 触发时间 it_order表的update之后4) 触发事件 it_goods表要修改对应的库存 1234567create trigger t4after update on it_orderfor each row begin update it_goods set goods_number=goods_number + old.much where id = old.goods_id;update it_goods set goods_number=goods_number - new.much where id = new.goods_id;end 4.4 其他操作 删除触发器 drop trigger 触发器名称 查看触发器 show triggers 4.5 befor和afterafter是先完成数据的增删改，再出发，触发器中的语句晚于监视的增删改，无法影响前面的增删改动作类似于自助餐，先付钱，在吃饭，无法影响吃多少 befor是先完成出发，再增删改，触发的语句先于监视的增删改发生，我们有机会判断修改即将发生的操作 案例：对于已下的订单，进行判断，如果订单数量&gt;5，就认为是恶意订单，强制吧所定的商品数量改成5 1) 监视地点 it_order表2) 监视事件 it_order表的insert操作3) 触发时间 it_order表的insert之前4) 触发事件 如果购买数量＞5就把购买数量改成5 12345678create trigger t5after insert on it_orderfor each row begin if new.much&gt;5 thennew.much=5;end if;end"},{"title":"Docker简介","date":"2018-11-30T01:20:09.000Z","path":"2018/11/30/Docker简介/","text":"0 场景简述0.1虚拟化技术所谓的虚拟化技术实际是一种资源管理技术，他可以将我们计算机中的实体资源进行虚拟化虚拟化技术种类有很多，例如：软件虚拟化，硬件虚拟化，内存虚拟化，网络虚拟化，桌面虚拟化，虚拟机等目的：就是为了提供我们计算机的使用率在实际的生产环境中，虚拟化技术主要用来解决高性能的屋里硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层屋里硬件，从而最大化的利用屋里硬件对资源充分利用 0.2 虚拟化技术分类 全虚拟化架构我们的虚拟机VMware就是利用了这种技术操作系统可以和虚拟机系统不相同 OS虚拟化架构OS虚拟化架构出来的操作系统要和我们底层的操作系统共享系统内核（即相同的操作系统）我们的Docker就是用了这种架构 硬件层虚拟化架构 0.3 Docker容器容器主要的作用就是装东西，比如我们的数组，集合也是容器，我们可以使用数组，集合来存储我们的数据我们也可以使用Docker来装我们的软件，比如：我们可以把mysql安装到docker容器中，tomcar，redis，nginx都可以安装到docker中我们把响应的软件安装到docker容器中以后好处： 方便我们队软件环境进行搬运 开发环境，测试换件，生产环境————&gt;统一我们的软件，有了docker以后我们可以极大的减少我们的部署成本，可以把mysql安装到dicker中，这样可以直接把容器给他 各个容器之间是隔离状态：这样就减少了我们软件之间的影响 docker是os层虚拟化架构的一种体现产品，os层虚拟化架构虚拟出来的操作系统需要和宿主机中的操作系统共享一个内核，docker容器的体积相对较小 0.4 Docker的组件 客户端和服务端在宿主机启动的所有docker容器中，启动的虚拟机都是客户端，而我们的宿主机是服务端 镜像镜像是一组文件的集合，竟像是构建Docker的基石（相当于操作系统镜像，能安装操作系统），其中包括了容器的文件系统结构与内容 注册中心类似于我们的Maven仓库，在注册中心中存储了很多的常用镜像，docker中的注册中心地址是docker——hub 容器容器就是镜像的运行实例，镜像和容器之间的关系就类似于类和对象的关系我们的容器创建时需要通过镜像来进行构建的 1 Docker的操作1.1安装Docker使用yum命令来进行在线安装 yun install docker [配图]提示信息[配图]输入y进行安装[配图]安装之后我们检查docker版本 docker -v[配图] 1.2卸载Docker查看docker的安装包 yum list installed|grep docker [配图] 删除安装包，就是删除刚才看到的文件 yum -y remove docker.x86_64yum -y remove docker-client.x86_64yum -y remove docker-common.x86_64 删除docker镜像 rm -rf /var/lib/docker/ 再次检查Docke是否删除成功 yum list installed|grep docker[配图] 1.3启动/关闭Dockersystemctl命令是系统服务管理指令，他是service和chkconfig两个命令组合 systemctl start docker 启动dockersystemctl status docker 产看docker的启动状态systemctl stop docker 停止dockersystemctl restart docker 重启docker docker info 查看docker的重要信息docker -help 查看docker的帮助文档 1.4启动Docker报错有时候我们启动docker会报错如下[配图]我们查看docker状态[配图]这里表示的意思是此linux的内核中的SELinux不支持overlay2 graph driver，解决办法有两个， 要么升级内核版本（升级操作系统） 要么在docker里禁用selinux --selinux-enabled=false vi /etc/sysconfig/docker [配图]再次启动docker，并且查看docker状态 1.5列出镜像列出宿主机上所有存在的镜像 docker images 第一次安装docker的时候是没有镜像的，索引我们看到的镜像信息是空的 列名 含义 备注 PEPOSITORY 镜像所在的仓库名称 TAG 镜像标签 为了区分同一个仓库下的不同镜像，Docker提供了一种标签(Tag)的功能，每个景祥在列出来的时候都带有一个标签 IMAGE ID 镜像ID CREATED 创建时间 创建镜像的时间（不是获取镜像的时间） SIZE 镜像大小 90 注：这些镜像都是存储在Docker宿主机的/var/lib/docker目录下的 1.6搜索镜像去注册中心（docker hub）上去所属需要的镜像 docker search 镜像名 如：搜索tomcat镜像[配图] 列名 含义 NAME 仓库名称 DESCRIPTION 镜像描述 STARS 综合评分，反应一个镜像受欢迎程度 OFFICIAL 是否官方 AUTOMATED 自动构建，表示该镜像由Docker Hub自动构建流程创建的 1.7拉取镜像我们拉取镜像默认是从Docker Hub镜像仓库上进行获取的，在Docker Hub的官网上我们可以看到一些信息[配图] 国情原因，国内下载Docker Hub官方的相关镜像比较慢，可以使用国内（docker.io）的一些镜像加速器，镜像保持和官方一致，关键是速度快 常用的镜像加速器有Mirror与Private Registry区别如下 序号 Private Registry 备注 1 Private Registry(私有仓库)是开发者或者企业自建的镜像缓存库，通常用来保存企业内部的Docker镜像，用于内部开发流程和产品的发布，版本控制 Mirror是一种代理中转服务器，我们（比如daocloud）提供的Mirror服务，直接对接Docker Hub的官方Registry。Docker Hbu上有数以十万计的各类Docker镜像 2 在使用Private Registry时，需要在Docker Pull或Dockerfile中直接接入Private Registry的地址，通常这样会导致与Private Registry的绑定，缺乏灵活性 使用Mirror服务，只需要在Docker守护经常（Dacmon）的配置文件中加入Mirror参数，即可在局范围内透明的访问官方的Docker Hub，避免了对Dockerfile镜像引用来源的修改 ustc镜像是老牌的linux镜像服务提供者配置ustc镜像加速 编辑文件 vi /etc/docker/daemon.json 在配置文件中配置如下内容 { “registry-mirrors”:[“https://docker.mirrors.ustc.edu.cn&quot;]} 重启docker systemctl restart docker 如果重启docker以后还是无法进行加速，可以重启宿主机尝试 拉取镜像： docker pull 镜像名称 拉取tomcat镜像 docker pull tomcat 1.8 删除镜像我们可以删除指定的镜像也可以删除所有镜像 删除指定镜像 docker rmi 镜像名称/镜像ID 删除所有镜像 1docker rmi `docker images -q` 注:中间的字符可以被当作linux的命令进行解析执行docker images -q 获取所有镜像的ID 2 Docker容器操作2.1 查看容器查看正在运行的容器 docker ps [配图] 列名 含义 CONTAINER ID 容器的id IMAGE 创建容器时所使用的镜像 COMMAND 运行容器中的软件执行的命令 CREATED 容器创建时间 STATUS 容器的状态：UP表示运行状态 Exited表示关闭状态 PORTS 宿主机端口和容器中软件的端口的对应关系 NAMES 容器名称 查看多有的容器（包括正在运行的容器和之前启动过的容器） docker ps -a 查看最后一次运行的容器 docker ps -l 查看停止的容器 docker ps -f status=exited 2.2 创建容器创建容器命令 docker run 创建容器参数介绍 参数名称 参数含义 -i 运行容器 -t 表示容器启动后进入命令行，加入这两个参数后，容器创建就能登录进去。分配一个伪终端 -d 在run后面加上-d参数，则会创建一个守护模式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i-t两个参数，创建后就回自动进入容器） –name 为创建的容器命名 -v 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到宿主机上 -p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个-p做多个端口映射 2.3 交互式容器创建一个交互式容器取名为mycentos docker run -it –name=mycentos centos /bin/bash 使用ps查看容器状态[配图] 使用exit退出容器[配图]然后再查看容器状态[配图]我们退出了容器也就关闭了容器 2.4 守护式容器创建的容器名不能重复 docker run -di –name=mycentos2 centos 创建好后我们进入这个容器 docker exec -it 容器名称/容器ID /bin/bash 2.5 停止与启动容器 停止容器 docker stop 容器名称/容器ID 启动已经关闭的容器 docker start 容器名称/容器ID"},{"title":"JavaScript对象","date":"2018-11-27T07:38:38.000Z","path":"2018/11/27/JavaScript对象/","text":"0 对象0.1简介JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。 对象只是一种特殊的数据。对象拥有属性和方法。 0.2创建对象创建新对象有两种不同的方法： 定义并创建对象的实例 12345person=new Object();person.firstname=\"John\";person.lastname=\"Doe\";person.age=50;person.eyecolor=\"blue\"; 使用函数来定义对象，然后创建新的对象实例 123456789function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor;&#125;var myFather=new person(\"John\",\"Doe\",50,\"blue\");var myMother=new person(\"Sally\",\"Rally\",48,\"green\"); 也可以把方法添加到 JavaScript 对象1234567891011121314function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; this.changeName=changeName; function changeName(name) &#123; this.lastname=name; &#125;&#125;myMother.changeName(\"Doe\"); 1 Object对象Object是javaScript中一切对象的父类对象 0.1 创建Object对象语法 obj = new Object([value]) 参数 obj 必需 Object 对象分配到的变量名称。 值 可选 任一 JavaScript 基元数据类型（数字、布尔值或字符串）。 如果值是一个对象，则返回的对象是未修改的。 如果值是 null、“未定义”或“未提供”，则创建无内容的对象。 0.2 属性 属性 描述 __proto__ 属性 指定对象的原型。 constructor 属性 指定用于创建对象的函数。 prototype 属性 为对象的类返回原型的引用。 proto 属性语法: object.__proto__ object 必需。要对其设置原型的对象。__proto__ 属性名称以两个下划线开始和结束。 1) 下面的代码示例显示如何为对象设置原型。12345678910function Rectangle() &#123;&#125;var rec = new Rectangle();if (console &amp;&amp; console.log) &#123; console.log(rec.__proto__ === Rectangle.prototype); // Returns true rec.__proto__ = Object.prototype; console.log(rec.__proto__ === Rectangle.prototype); // Returns false&#125; 2) 下面的代码示例演示如何通过将属性添加到原型来将其添加到对象中。12345678910111213var proto = &#123; y: 2 &#125;;var obj = &#123; x: 10 &#125;;obj.__proto__ = proto;proto.y = 20;proto.z = 40;if (console &amp;&amp; console.log) &#123; console.log(obj.x === 10); // Returns true console.log(obj.y === 20); // Returns true console.log(obj.z === 40); // Returns true&#125; 3) 下面的代码示例通过在 String 对象上设置新原型将特性添加到该对象。123456789101112131415161718var stringProp = &#123; desc: \"description\" &#125;;String.__proto__ = stringProp;var s1 = \"333\";var s2 = new String(\"333\");if (console &amp;&amp; console.log) &#123; console.log(String.desc === \"description\"); // Returns true console.log(s1.desc === \"description\"); // Returns false console.log(s2.desc === \"description\"); // Returns false s1.__proto__ = String; // Can't be set. s2.__proto__ = String; console.log(s1.desc === \"description\"); // Returns false console.log(s2.desc === \"description\"); // Returns true&#125;"},{"title":"AJAX","date":"2018-11-23T01:28:17.000Z","path":"2018/11/23/AJAX/","text":"0 AJAX基础简介0.1 什么是AJAX？async javascript and xml异步的JS和XML 0.2. xml可扩展的标记语言 作用是用来存储数据的（通过自己扩展的标记名称清晰地展示出数据结构） ajax之所以成为异步的js和xml，主要原因是：当初最开始使用ajax实现客户端和服务端数据通信的时候，传输数据格式一般都是xml格式的数据，我们把它称之为异步js和xml（现在一般都是基于JSON格式来进行数据传输的） 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;root&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;score&gt; &lt;english&gt;90&lt;/english&gt; &lt;math&gt;100&lt;/math&gt; &lt;chinese&gt;97&lt;/chinese&gt; &lt;/score&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;score&gt; &lt;english&gt;90&lt;/english&gt; &lt;math&gt;100&lt;/math&gt; &lt;chinese&gt;97&lt;/chinese&gt; &lt;/score&gt; &lt;/student&gt;&lt;/root&gt; 0.3 异步的JS这里的异步不是说ajax只能基于异步进行请求（虽然建议都使用异步编程），这里的异步指的是局部刷新 1 前后端分离前后端分离的导火线就是全局刷新和局部刷新 1.1刷新全局(不分离)在非完全前后端分离的项目中，前端开发只需要完成页面的制作，并且把一些基础的人机交互效果使用js完成即可，页面中需要动态呈现内容的部分，都是交给后台开发人员做数据绑定和基于服务器进行渲染的（服务器渲染）[优势] 动态战士的数据在页面的源代码中课件，有利于SEO优化推广（有利于搜索引擎的收录和抓取） 从服务器端获取的结果就已经是最后要呈现的结果了，不需要客户端做额外的事情，所以页面加载速度快（前提是服务器端处理的速度够快），所以类似京东，淘宝这类网站，首屏数据一般都是经由服务器端渲染的 [弊端] 如果页面中存在需要实时更新的数据，每一次想要展示最新数据，页面都需要重新的刷新一次，这样肯定不行 都交给服务器端做数据渲染，服务器端的压力大，如果服务器处理不过来，页面显现的速度会更慢 3.这种模式不利于开发，（开发效率低） 目前市场上大部分项目都是前后端完全分离的项目（也有非完全前后端分离的项目） 1.2 局部刷新(分离)前后端完全分离的项目，页面中需要动态绑定的数据是交给客户端完成渲染的 向服务器发送AJAX请求 把从服务器端获取的数据解析进行处理，拼接成我们需要的HTML字符串 把拼接好的字符串替换页面中某一部分的内容（局部刷新），页面整体不需要重新加载，局部渲染即可 [优势] 我们可以根据需求，任意修改页面中某一部分的内容（例如实时刷新），整体页面不刷新，性能好，体验好（所有表单验证，需要实施刷新的需求都要局域AJAX实现） 有利于开发，提高开发效率1) 前后端分离，后端不需要考虑前端是如何呈现的，前端也不需要考虑后台使用什么技术，真正意义上实现了技术划分2) 可以同时进行开发：项目开发开始，首先指定前后端数据交互的接口文档（文档中包含了，调取那个接口或者那些数据等协议规范），后台把接口写好（目前很多公司也需要前端自己拿NODE来模拟这些接口） [弊端] 不利于SEO优化：第一次从服务器端获取的内容不包含需要动态绑定的数据，所以页面的源代码中没有这些内容，不利于SEO收录，后期经过JS添加到页面中的内容，并不会卸载页面的源代码中（是源代码不是页面结构） 交由客户端进行渲染，首先需要把页面呈现，然后再通过JS的异步AJAX请求获取数据，然后数据绑定，浏览器把动态数据增加的部分重新渲染，无形中兰妃了一些时间，没有服务器端渲染页面呈现的速度快 2 AJAX参数详解2.1 创建一个AJAX对象12345678910111213// 创建AJAX对象let xhr = new XMLHttpRequest(); //不兼容IE6及更低版本的浏览器（IE6：ActiveXObject）//打开请求地址（可理解为一些基础配置，但是并没有发送请求）xhr.open([method],[url],[async],[user_name],[user_password]);// 监听AJAX状态改变，获取相应信息（获取响应头信息，获取响应主体信息）xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; let result = xhr.responseText;//获取相应主题中的内容 &#125;&#125;// 发送AJAX请求（括号中的内容就是请求的主题内容）xhr.send(null); 2.2 配置（open）的参数xhr.open([method],[url],[async],[user_name],[user_password]);1. [method]请求方式1) GET系列的请求 get delete 从服务器上删除某些文件 head 只想获取服务器返回的响应头信息（相应主体内容不需要获取） …2) POST请求方式 post put 向服务器中增减指定的资源文件 不管是哪一种请求方式，客户端都可以把信息传递给服务器，服务器也可以把信息返回给客户端，只是GET系列一般以获取为主（给的少，拿得多）而POST系列一般以推送为主（给的多，拿得少）1) 我们想获取一些动态展示的信息一般都用GET请求，因为只需要向服务器发送请求，告诉服务器端我们想要什么2) 在实现注册功能的时候，我们需要吧客户端输入的信息发送给服务器进行存储，服务器一般返回成功还是失败等状态，此时我们一般都是基于POST请求完成的 2. GET VS POSTGET系列请求和POST系列请求系列请求，在项目实战中存在很多区别1) GET请求传递给服务器的内容一般没有POST请求传递给服务器的多原因：GET请求传给服务器内容一般都是基于url地址问号传参来实现的，而POST请求一般都是基于设置请求主体来实现的。各浏览器都有自己的关于URL最大长度限制（谷歌：8K，火狐：7k，IE：2K）超过限制长度的部分，浏览器会自动截取掉，导致传递给服务器的数据缺失。理论上POST请求通过主体传递是没有大小限制的，真实项目中为了保证传输的速率，我们也会限制大小（例如：上传的资料或者图片我们会做大小的限制）2) GET请求很容易出现你缓存（这个缓存不可控：一般我们不需要），而POST不会出现缓存（除非做特殊处理）123456789setTimeout(()=&gt;&#123; $.ajax(&#123; url:'getList?lx=news', ... success=&gt;&#123; //第一次请求数据回来，间隔一分钟后，浏览器又发送一次请求，但是发送新的请求，不管是地址还是传递的参数都和上一次一样，浏览器很有可能会把上一次数据获取，而不是获取最新数据 &#125; &#125;,60000);&#125;) 解决方法：每一次重新请求的时候，在URL的末尾追加一个随机数，保证每一次请求的地址不完全一致，就可以避免是从缓存中读取的数据123456789setTimeout(()=&gt;&#123; $.ajax(&#123; url:'getList?lx=news&amp;_='+Math.random(), ... success=&gt;&#123; &#125; &#125;,60000);&#125;) 3) GET请求没有POST请求安全（POST也并不是十分安全，只是相对安全）原因：还是因为GET是URL传参给服务器有一种比较简单的黑客技术：URL劫持，也就是可以把客户端传递给服务器的数据劫持掉，导致信息泄露 3. [url]请求地址真实项目中，后台开发工程师会写一个API文档，在API文档中汇总了获取哪些数据需要使用那些地址，我们按照文档操作即可 4. [async]异步ASYNC异步（SYNC同步），设置当前AJAX请求时异步还是同步的，不写默认是异步（TRUE），如果设置为FALSE，则代表当前请求时同步 5. [user_name],[user_password]用户名和密码这两个参数一般不用，如果你请求的URL地址所在的服务器设定了访问权限，则需要我们提供可通信的用户名密码才可以（一般服务器都是可以允许匿名访问的） 2.3 AJAX状态码描述当前AJAX操作的状态的xhr.readyState 0 :UNSENT 未发送，只要创建一个AJAX对象，默认是0 1 :HEADERS_RECEIVED当前AJAX的请求已经发送，并且已经接收到服务器端返回的响应头信息了 3 :LOADING响应主体内容正在返回的路上 4 :DONE响应主体内容已经返回给客户端 2.4 HTTP网络状态HTTP网络状态码：记录了当前服务器返回的状态（xhr.status） 200: 成功，一个完整的HTTP事务完成（以2开头的状态码一般都是成功） 以3开头的一般也都是成功，只不过服务器做了特殊处理 301:Moved Permanently 永久颛臾（永久重定向） 302:Moved temporarily 临时转移（临时重定向，新的HTTP版本中任务307是临时重定向）一般用于服务器负载均衡：当前服务器处理不了，我们把当前请求临时交给其他的服务器处理（一般图片请求经常出现302，很多公司都有单独的图片服务器） 304: Not Modified 从浏览器缓存中获取数据把一些不经常更新的文件或者内容缓存到浏览器中，下一次从缓存中获取，减轻服务器压力，也提高页面加载速度 一般4开头的都是失败，而且服务器的问题偏大 400:请求参数错误 401:无权限访问 404:访问地址不存在 以5开头的一般都是失败，而且服务器的问题偏大 500:Internal Server Error未知的服务器错误 503:Service Unavailable服务器负载 2.5 AJAX参数及方法运行下面代码查看AJAX属性及方法12let xhr = new XMLHttpRequest();dir(xhr) [属性] readState 存储的是当前AJAX的状态码 response/responseText/responseXML 都是用来接受服务器返回的响应主体中的内容，只是根据服务器返回内容格式不一样，我们使用不同的属性接收即可 responseText是最常用的，接收到的内容格式是字符串格式的（一般服务器返回的数据都是JSON格式字符串） responseXML偶尔会用到，如果服务器端返回的是XML文档数据，我们需要使用这个属性接收 starus 记录了服务器返回的HTTP状态码 statusText 返回状态码的描述 timeout 设置当前AJAX请求的超时时间，假设我们设置的时间为3000（MS），从AJAX请求发送开始，3秒后响应主体内容还没有返回，浏览器就会把当前的AJAX请求任务强制断开 [方法] abort() 强制中断AJAX请求 getAllResponseHeaders() 获取指定属性名的响应头信息，例如：xhr.getResponseHeader(‘date’)获取响应头中存储的服务器时间 open() 打开一个URL地址 overrideMimeType() 重写数据的MIME类型 send() 发送AJAX请求（括号中书写的内容是客户端基于请求主体把信息传递给服务器） setRequesHeader(key,value) 设置请求头信息（可以是设置的自定义请求头） [事件] onabort 当AJAX状态发生改变，会触发这个事件 onreadystatechange AJAX状态发生改变，会触发这个事件 ontimeout 当AJAX请求超时，会触发这个事件 [代码示例]12345678910111213141516171819202122232425262728293031323334353637let xhr = new XMLHttpRequest();xhr.open('get','url?_='+Math.random(),true);// xhr.setRequestHeader('cookie','培训')设置请求头内容不能出现中文，并且header的key不能使cookie//请求头必须在OPEN之后SEND之前xhr.setRequestHeader('aaa','xxx');//设置请求超时时间xhr.timeout = 10;xhr.ontimeout = ()=&gt;&#123; console.log('请求已超时'); xhr.abort();&#125;xhr.onreadystatechange=()=&gt;&#123; let &#123;readyState:state,status&#125;=xhr // 如果跳过这个if没有return则说明成功了 if(!/^(2|3)\\d&#123;2&#125;$)/.test(status)) return; // 在状态为2的时候就可以获取响应头信息 if (state === 2)&#123; let headerAll = xhr.getAllResponseHeaders(), //获取的是服务器时间是格林尼治时间(相比于北京时间差了8小时)，通过new Date可以把这个时间转换为北京时间 serverDate = xhr.getResponseHeader('data'); console.log(headerAll,new Date(serverDate)); return; &#125; // 在状态为4的时候响应主体已经回来了 if (state === 4)&#123; //获取的结果一般是JSON字符串（可以使用JSON.PARSE把其转换为JSON对象） let valueText = xhr.responseText, //获取到的结果是SML格式的数据（可以通过XML的一些常规操作获取存储的信息） //如果服务器返回的是XML文档，responseText获取的结果是字符串而responseXML获取的是标准XML文档 valueXML = xhr.responseXML; console.log(valueText,valueXML); return; &#125; &#125;xhr.send('name=zxt&amp;age=28&amp;sex=man'); 2.6 AJAX同步异步详解AJAX这个任务：发送请求接收到响应主体内容（完成一个完整的HTTP事务） xht.send() 开始任务 xht.readyState === 4; 结束任务 [同步] 1234567let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;xhr.send();// 只输出一次结果 12345678let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.send(); // [同步]开始发送AJAX请求，开启AJAX任务，在任务没有完成之前，什么事情都做不了，下面绑定事件也做不了xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;// 绑定方法之前状态已经为4了，此时AJAX的状态不会再改变成其他值，所以事件永远//也不会被触发，一次都没执行方法（使用AJAX同步编程，不要把SEND放在事件监听前，这样我们无法在绑定的方法中获取到响应主题内容） 原理如图所示： [异步]1234567let xhr = new XMLHttpRequest();xhr.open('get','temp.json');xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;xhr.send();// 输出结果分别是2，3，4 1234567let xhr = new XMLHttpRequest();xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;xhr.open('get','temp.json');xhr.send();// 输出结果分别是1,2，3，4 原理如图所示： [AJAX特殊性] 虽然是同步但是还是会输出1 123456789let xhr = new XMLHttpRequest();xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;//xhr.readyState === 1 AJAX特殊处理的一件事：执行OPEN状态改变为1，会主动把之前坚挺的方法执行一次，然后再去执行SENDxhr.open('get','temp.json',false);xhr.send();//xhr.readyState ===4 AJAX任务结束，主任务队列完成// 1，4 3 JS中常用的编(解)码方法3.1 正常编码解码 escape/unescape主要是把中文汉字进行编码和解码（一般只有JS语言支持，也经常应用于前端页面通信的时候中文编码问题） 12345let str = '培训@163.com'escape(str);// 显示\"%u57F9%u8BAD@163.com\"unescape('%u57F9%u8BAD@163.com')// 显示\"培训@163.com\" encodeURI/decodeURI 12345let str = '培训@163.com';encodeURI(str);// \"%E5%9F%B9%E8%AE%AD@163.com\"decodeURI('%E5%9F%B9%E8%AE%AD@163.com')// \"培训@163.com\" encodeURIComponent/encodeURIComponent 12345let str = '培训@163.com';encodeURIComponent(str);// \"%E5%9F%B9%E8%AE%AD%40163.com\"encodeURIComponent('%E5%9F%B9%E8%AE%AD%40163.com');// \"培训@163.com\" encodeURI区别encodeURIComponent1) encodeURI不处理特殊字符2) encodeURIComponent处理特殊字符我们URL问号传递参数的时候，我们传递的参数还是一个URL或者包含很多特殊字符，此时为了不影响主要的URL，我们需要吧传递的参数值进行编码，使用encodeURI不能编码一些特殊字符，所以只能使用encodeURIComponent处理 123456789101112let str = 'http://www.baidu.com?',obj=&#123; name:'培训', age:'9', url:'http://www.linjiad.cn/?lx=1'&#125;;//把obj中的每一项属性名和属性值拼接到url末尾for(let key in obj)&#123; str+=`$&#123;key&#125;=$&#123;obj[key]&#125;&amp;`;&#125;console.log(str.replace(/&amp;$/g,''));//后期获取URL问号传参的时候，我们把获取的值一次的解码即可 3.2 加密方式进行编码解码 可逆转加密（一般都是团队自己定义的规则） 不可逆加密（一般都是基于MD5加密完成的）MD5加密是不可逆的，网上解析是通过匹配大数据，能解析出常用的加密，不常用的是无法解析的 4 实现AJAX4.1 Jquery中的AJAX123456789101112131415161718192021222324$.ajax(&#123; url:'xxxx', // 请求的API地址 method:'get',// 请求方式GET/POST。。，在老的版本中使用的是type使用type和method实现的是相同效果 dataType:'json',// dataType知识我们预设获取结果的类型，不会影响服务器的返回 // （服务器一般给我们返回的都是JSON格式字符串），如果我们预设的是json，那么类库中将把服务器返回的字符串转换为json对象 // ，如果我们预设的事text（默认值），我们把服务器获取的结果直接拿过来即可，我们预设的值还可以是xml等 cache:false, // 设置是否清除缓存，只对GET系列请求有作用，默认是TRUE不清除缓存，手动设置为FALSE，JQ类库 // 会在请求URL的末尾追加一个随机数来清除缓存 data:null, //我们通过DATA可以吧一些信息传递给服务器；GET系列请求会把DAT中的内容拼接在URL的末尾， // 通过问号传参的方式传递给服务器，POST系列请求会把内容放在请求主体中传递给服务器，DATA的值可以设置为两种格式 //字符串，对象，如果是字符串，设置的值是什么传递给服务器的就是什么，如果设置的对象， // JQ会把对象变为xxx=xxx&amp;xxx=xxx这样的字符串传递给服务器 async:true,// 设置同步或者异步，默认是TRUE代表异步，FALSE是同步 success:function() &#123; // 当AJAX请求成功（readyState===4&amp;status是2或3开头的） // 请求成功后JQ会把传递的回调函数执行，并且把获取的结果当做实参传递给回调函数（result就是我们从服务器获取的结果） &#125;, error:function() &#123; // 请求错误触发回调函数 &#125;, complate:function() &#123; // 不管是否请求错误还是正确，都会触发回调函数（他是完成） &#125;&#125;) 4.2 封装AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778~function() &#123; class ajaxClass&#123; init()&#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = () =&gt;&#123; if(!/^[23]\\d&#123;2&#125;$/.test(xhr.status)) return; if(xhr.readyState === 4)&#123; let result = xhr.responseText; switch (this.dataType.toUpperCase())&#123; case 'TEXT': case 'HTML': break; case 'JSON': result = JSON.parse(result); case 'XML': result = xhr.responseXML; &#125; this.success(result); &#125; &#125;; // 处理data if(this.data !== null)&#123; this.formatData(); if(this.isGet)&#123; this.url += `$&#123;this.querySymbol()&#125;`; &#125; &#125; // 是否去除缓存 this.isGet ? this.cacheFn():null; xhr.open(this.method,this.url,this.async); xhr.send(this.data); &#125; formatData()&#123; if(Object.prototype.toString.call(this.data)==='[object,object]')&#123; let obj = this.data, str = ''; for(let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; str += `$&#123;key&#125;=$&#123;obj[key]&#125;&amp;`; &#125; &#125; str = str.replace(/&amp;$/g,'') this.data = str; &#125; &#125; // 是否清楚缓存 cacheFn() &#123; !this.cache?this.url += `$&#123;this.querySymbol()&#125;_=$&#123;Math.random()&#125;`:null; &#125; // 判断结尾是否为？ querySymbol()&#123; return this.url.indexOf('?')&gt;-1?'&amp;':'?'; &#125; &#125; window.ajax = function(&#123; url = null, method = 'GET', type = 'GET', data = null, dataType = 'JSON', cache = true, async = true, success = null &#125; = &#123;&#125;)&#123; let example = new ajaxClass(); example.url = url; example.method = type === null?method:type; example.data = data; example.dataType = dataType; example.cache = cache; example.async = async; example.success = typeof success === 'function'?success: new Function(); example.isGet = /^(GET|DELETE|HEAD)$/i.test(example.method); example.init(); &#125; &#125;();"},{"title":"正则","date":"2018-11-21T02:20:44.000Z","path":"2018/11/21/正则/","text":"0 概述0.1 正则概念就是一个规则，用来处理字符串的一个规则 0.2 正则的用处 匹配:判断一个字符串是否包含我们所指定的规则 ref.test(str) 捕获：把字符串中符合规则的内容捕获到 ref.exec(str) 0.3 正则的元素每一个正则表达式都是由元字符和修饰符组成的 【元字符】在//之间具有意义的一些字符 【量词元字符】代表出现次数数量的元字符 【特殊符号】（()，[]） 【修饰符】① global（g）：全局匹配② ignoreCase（i）：忽略大小写匹配③ multiline（m）：多行匹配 1 创建正则我们可以先看看正则里都包含了哪些 console.log(RegExp.prototype); 1.1 字面量方式 var reg = /\\d/ 1.2实例创建 var reg = new RegExp(“”) 1.3两者区别 字面量：在字面量方式中，我们//之间包起来的所有内容都是元字符，有特殊意义的，大部分都是代表本身含义的普通的元字符1234var name = zhu;var reg = /^\\d+\"+name+\"\\d+$/g;Console.log(reg.test(\"2015zhu2016\"))// false;Console.log(reg.test('2015\"\"nameeeee2016'))// true; 在这段代码中，并非是name代表zhu而是仅代表name本身，并且+为出现e的次数 创建实例12var reg = new RegExp(\"/^\\\\d+\"+name+\"\\\\d+$/\",g);console.log(reg.test(\"2015zhu2016\")) //true; 这里name就代表的是zhu注意：1.创建实例中转移符为两个\\\\d2.创建实例中修饰符作为第二个参数传入 1.4 字符串match方法字符串中的match方法：把所有和正则匹配的字符都获取到1234var reg = /\\d+?/g;var str = \"zhufeng2015peixun2016\";var ary = str.match(reg);console.log(ary) 虽然当前情况下，match比我们的exec更加的简便一些，但是match中存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则匹配的内容，而对于小正则捕获的内容是无法获取的 1.5 字符串中replace把原有的字符串替换成新的字符在不使用正则的情况下，每当执行一次只能替换一个字符123var str = \"zhufeng2015zhufeng2016\"str = str.replace(\"zhufeng\",\"zhufengjiaoyu\").replace(\"zhufeng\",\"zhufengjiaoyu\")// \"zhufengjiaoyujiaoyu2015zhufeng2016\" 这样出现zhufengjiaoyujiaoyu并没有实现需求；1234var str = \"zhufeng2015zhufeng2016\"str = str.replace(/zhufeng/g,\"zhufengjiaoyu\");console.log(str);// \"zhufengjiaoyu2015zhufengjiaoyu2016\" replace第一项的值是一个正则的实现原理 2 语法规则2.1 元字符在//之间具有意义的一些字符 \\：转义字符，转义后面字符所代表的含义 ^ :以某一元字符开始 $ :以某一元字符结束 \\n :匹配一个换行符 . :除了\\n以外的任意字符 123456var reg = /^0.2$/ // 以0开头2结尾中间除了\\n的任意字符Console.log(reg.test(\"0.2\")) // trueConsole.log(reg.test(\"0-2\")) // true reg = /^0\\.2$/ Console.log(reg.test(\"0.2\")) // falseConsole.log(reg.test(\"0-2\")) // true x|y:x或y其中一个 [xyz]:x或者y或者z其中一个 [^xyz]:除了xyz之外的任意字符 [a-z]:a-z之间任意一个字符 [^a-z]:除了a-z之间任意一个字符 \\d:一个0-9之间的数字 \\D:除了0-9之外的任意字符 \\w:数字，字母，下划线中的任意一个字符 [0-9a-zA-Z_] \\b:匹配一个边界符 \\s:匹配一个空白字段，空格或制表符，换页符 2.2 量词元字符代表出现次数数量的元字符 *:出现0到多次 +:出现1到 ?:出现0或1次 {n}:出现n次 {n,}:出现n到多次 {n,m}:出现n到m次 一个简单的手机验证1var reg= /^1\\d(10)$/ 2.3 特殊符号 ()分组作用改变x|y的优先级 var reg = /^18|19$/; 可以是18,19,189,119,819,1819…. var reg = /^(18|19)$/; 只能是18,19 []1) 在括号中出现的所有字段都代表本身意思的字符串（没有特殊含义）123var reg = /^0[.]$/ // 以0开头2结尾中间除了\\n的任意字符console.log(reg.test(\"1\")) // falseconsole.log(reg.test(\".\")) // true 2) 中括号中不识别两位数123var reg = /^[12]$/ // 1或者2中的其中一个var reg = /^[12-68]$/ // 1,2-6中的一个，8 三个中的一个var reg = /^[\\w-]$/ // 数字，字母，下划线，-中的一个 2.4 修饰符修饰符可以有效的解决正则捕获的懒惰性 global（g）：全局匹配ignoreCase（i）：忽略大小写匹配multiline（m）：多行匹配 3 正则用法3.1 匹配判断一个字符串是否包含我们所指定的规则 ref.test(str) 1234var reg = /\\d/ //包含一个0-9之间的数字console.log(reg.test(\"住\")); //falseconsole.log(reg.test(\"1\")); //trueconsole.log(reg.test(\"住111\")); //true 3.2 捕获把字符串中符合规则的内容捕获到 ref.exec(str) 123var reg = /\\d/;console.log(reg.exec(\"住\")); // nullconsole.log(reg.exec(\"1\")); // [\"1\",index:0,input:\"1\"] 3.3 捕获的内容格式第一项为当前数组最大正则捕获的内容 index：捕获内容所在开始索引位置input：捕获的原始字符串1234var reg = /\\d+/;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(res); //[\"2015\",index:7,input:\"zhufeng2015peixun2016\"] 3.4 正则捕获的特点1.懒惰型每一次执行exec只捕捉第一个正则匹配的内容，在不进行任何处理的情况下，在执行多次捕捉，不做的还是第一个匹配内容第一次：1234var reg = /\\d+/;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(res); //[\"2015\",index:7,input:\"zhufeng2015peixun2016\"] 第二次：还是一样1234var reg = /\\d+/;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(res); //[\"2015\",index:7,input:\"zhufeng2015peixun2016\"] 如何解决懒惰型： 在正则末尾加上一个修饰符g原理：加了全局修饰符g，正则每一次捕获或，我们的lastIndex的值都变为了最新的值，下一次捕获从最新的位置开始查找。1234567var reg = /\\d+/g;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(reg.lastIndex); //匹配开始位置 0console.log(res); //[“2015”,index:7,input:“zhufeng2015peixun2016”]Console.log(reg.lastIndex); //匹配开始位置 11console.log(res); //[“2016”,index:7,input:17“zhufeng2015peixun2016”] 捕获全部内容：12345678var reg = /\\d+/g;var str = \"zhufeng2015peixun2016\";var arr = [];while(res)&#123;arr.push(res[0]);res = reg.exec(str);&#125;console.log(arr); 2.贪婪性正则的每一次捕获都是按照匹配最长的结果捕获的例如：2符合正则2015也符合正则，我们默认捕获的是2015如何解决贪婪性：在量词元字符后面加上？即可12345678var reg = /\\d+?/g;var str = \"zhufeng2015peixun2016\";console.log(reg.exec(str)); //[\"2\",....]var ary = [],res = reg.exec(str);while(res)&#123;ary.push(res[0]);&#125;console.log(ary); 4正则分组4.1 分组引用\\2代表和第二个分组出现一模一样的内容；\\1和第一个分组出现一模一样的内容：一模一样：和对应的分组中的内容的值都要一样123var reg = /^(\\w)\\1(\\w)\\2$/;Console.log(reg.test(\"zzff\")); //trueConsole.log(reg.test(\"z0f_\")); //false 4.2 分组捕获正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到 (?:)在分组中?:的意思是只匹配不捕获 1234var reg = /^(\\d&#123;2&#125;(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(?:\\d&#123;2&#125;)(\\d)(?:\\d|X))$/ var str = \"142726199009181211\";console.log(reg.exec(str));// ary = [\"142726199009181211\", \"142726199009181211\", \"2726\", \"1990\", \"09\", \"18\", \"1\", index: 0, input: \"142726199009181211\", groups: undefined] ary[0] 大写正则匹配的全部内容ary[1] 第一个分组捕获的内容ary[2] 第二个分组捕获的内容Match捕获： console.log(str.match(reg)) 和exec获取的结果一样不同:12345var reg = /zhufeng(\\d+)/gvar str = \"zhufeng1234zhufeng3456zhufeng5678\";console.log(reg.exec(str)); //[\"zhufeng1234\", \"1234\", index: 0, input: \"zhufeng1234zhufeng3456zhufeng5678\", groups: undefined]console.log(reg.exec(str)); //[\"zhufeng3456\", \"3456\", index: 11, input: \"zhufeng1234zhufeng3456zhufeng5678\", groups: undefined]console.log(reg.exec(str)); //[\"zhufeng5678\", \"5678\", index: 22, input: \"zhufeng1234zhufeng3456zhufeng5678\", groups: undefined] 而match只能捕获大正则匹配的内容1console.log(str.match(reg)) //[\"zhufeng1234\", \"zhufeng3456\", \"zhufeng5678\"] 5 练习1.有效数字的正则1）”.”可以出现也可以不出现，一旦出现后面要跟着一位或多位数字2）最开始可以使+/-也可以没有3）整数部分，一位数可以使0-9之间的一个，多位数不能以0开头1var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ 2.年龄介于18-65之间 18-19 20-59 60-651var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ 3.邮箱认证（简版）左侧：数字，字母，下划线。。。1var reg = /^[\\w.-]+@[0-9a-zA-Z]+(\\.[a-zA-Z]&#123;2,4&#125;)(1,2)$/; 4.中国标准实名2-4位1var reg = /^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/ 5.身份证号123var reg = /^\\d&#123;17&#125;(\\d\\X)$/// 21 0302 1990 12 30 00 1 9var reg = /^(\\d&#123;2&#125;(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X))$/"},{"title":"HTTP简述","date":"2018-11-15T07:28:39.000Z","path":"2018/11/15/HTTP简述/","text":"0简述0.1访问过程在输入网站到出现页面经历了怎样的心路历程？[Request请求阶段]1.首先根据用户输入的域名，到DNS服务区上进行反解析（通过域名找到对应服务器的外网IP）2.通过找到的外网IP，找到对应的服务器3.通过在地址栏中的端口号（没输入是因为不同协议都有自己默认的端口号）找到服务器上发布的对应项目 [Response请求阶段]4.服务器获取到请求资源文件的地址 例如：/stu/index.html把资源文件中的源代码找到5.服务器端会把找到的源代码返给客户端（通过HTTP等协议返回的） [浏览器渲染]6.客户端接收到源代码后，会交给浏览器内核进行渲染，最后由浏览器绘制出对应的页面 0.2URI，URL，URN1.[URI]统一资源标识符 2.[URN]统一资源路径地址 3.[URL]统一资源名称 URI = URL + URN 0.3 传输协议传输协议是用来完成客户端和服务器端的数据（内容）传输的，类似于快递小哥，负责吧客户和商家的物品来回传送 客户端不仅可以向服务器发送请求，而且还可以把一些内容传递给服务器 服务器端也可以吧内容返回给客户端 客户端和服务器端传输的内容总称为HTTP报文，这写报文信息都是基于传输协议完成传输的，客户端传递给服务器端的请求叫请求Request,服务器返给客户端叫响应Response，两个阶段总称为HTTP事务（一件完整的事情） 0.4 HTTP事务 当客户端像服务器端发送请求，此时客户端和服务器端会建立一个传输通道（链接通道），传输协议就是基于这个通道把信息进行传输的 当服务器端接收到请求信息，把内容返回给客户端后，传输协议就回自动销毁关闭0.5 传输协议分类 http:超文本传输协议（客户端和服务器端传输的内容除了文本以外，还可以传输图片，音频等文件流[二进制编码/BASE64码]，以及传输XML格式的数据等,）是目前市场是最广泛应用的传输协议 https:httpssl，它比http更加安全，因为数据内容的传输通道是经历过ssl加密的（他需要在服务器端进行特殊的处理），所以涉及到资金的网站一般都是https协议 ftp:资源文件传输协议，一般用于客户端吧资源文件（不是代码）上传到服务器端，或者从服务器端下载一些资源文件（一般ftp传输的内容会比http这类协议传输的内容多）0.6 HTTP报文 起始行 请求起始行响应起始行 首部（头部） 请求头:内置请求头，自定义请求头 响应头:内置响应头，自定义响应头 通用头:请求和响应都有的 3.主题 请求主题 相应主题 请求XXXX都是客户端设置这些信息，服务端获取这些信息响应XXXX都是服务器端设置的信息，客户端获取这些信息 0.7 总结客户端传递给服务器的诗句 URL问号传递参数 设置请求头 设置请求主体… 服务器端返回给客户端的内容 设置响应头（例如服务器时间） 设置响应主体… 第二部分 设置域名其实就是给不好记得服务器外网IP设置了一个好记的名字顶级域名（一级域名）：qq.com二级域名：www.qq.com v.qq.com sport.qq.com三级域名：kbs.sport.qq.com 第三部分 在服务器发布项目的时候，我们可以通过端口号区分当前服务器上不同的项目 一台服务器的端口号取值范围0-65535之间，如果电脑上安装了很多的程序，有一些端口号被占用了 HTTP：默认端口号80HTTPS：默认端口号443FTP：默认端口号21关于上诉三个端口号其实是很重要的，如果被其他程序占用，我们则不能使用了，所以服务器上一般是禁止安装其他应用程序的 第四部分：请求资源文件的路径名称 /stu/index.html 在服务器中发布项目的时候，我们一般都会配置一些默认文档：用户即便不输入请求文件的名称，服务器也会找到默认文档（一般默认文档都是index/default。。。） 我们通常为了做SEO优化，会把一些动态页面的地址（XX.PHP,XXX.ASP,XXX.JSP。。。）进行伪URL重写（需要服务器处理） http://item.jd.com/4325427.html不可能有一个商品，自己就单独写一个详情页面，肯定是同一个详情页做的不同处理 1) 第一种方案：由后台语言根据详情页模板动态生成具体的详情页面2) 第二种方案当前页面就是一个页面，例如：detail.html/detail.php…，我们做详情页面的时候，开发是按照detail.html?id=4325427来开发的；但是这方便做SEO优化。此时我们把真是的地址进行重写，重写为我们看到的4325427.html 第五部分：问号传参 ?name=zf&amp;age=9…把一些值通过xxx=xxx的方式，放在一个URL的末尾，通过问号传递 [作用] 在AJAX请求中，我们可以通过问号传递参数的方式，客户端把一些信息传递给服务器，服务器根据传递信息的不一样，返回不同的数据 123456// $.ajax(url,&#123;&#125;);// $.get(url,function()&#123;&#125;;)对于AJAX请求的特殊写法，原理上还是局域AJAX方法实现的$.post/$.script...$.ajax(&#123; url:'getPersonInfo?id=12'&#125;) 消除AJAX轻轻中GET方式缓存 1234$.ajax(&#123; url:'xxx?=0.123456', method:'get'&#125;); 我们会在请求URL的末尾加一个_=随机数，保证每一次请求的URL都是不一样的，以此来消除GET请求遗留的缓存问题 通过URL传递参数的方式，可以实现页面之间信息通信，例如：我们有两个页面A,B，A是列表页面B是详情页面，点击A中的某一条信息，进入到唯一的详情页面B，如何展示不同的信息，这种操作就是基于URL问号传递参数来实现的 在进入页面的时候，我们可以获取URL传递的参数值，根据传递参数值不一样，从服务器端获取不同的数据展示 在列表页面进行页面跳转的时候，我们需要记住的是跳转的同时传递不同的参数值 第六部分：HASH值 URL末尾传递的井号什么，就是HASH值[作用] 页面中锚点定位 前端路由（SPA单页面开发） 1优化技巧WEB前端开发常用的优化技巧减少HTTP请求的次数页面中每发送一次HTTP请求，都需要完成请求+响应这个完整的HTTP事务，会消耗一些时间，也可能会导致HTTP链接通道堵塞，为了提高页面加载速度和运行性能，我们应该减少HTTP的请求次数 采用CSS雪碧图（CSS Sprit/CSS 图片精灵）技术，把一些小图片合并在一张大图上，使用的时候通过背景图定位，定位到具体的某一张小图上css:1234567.pubBg&#123; background:url(\"../img/sprit.png\") no-repeat; background-size:x y;/*和原图的大小保持一致*/&#125;.box&#123; background-position: x y;/*通过背景定位，定位到具体的位置，展示不同的图片*/&#125; 1&lt;div class=\"pubBg box\"&gt;&lt;/div&gt; 真实项目中，我们最好把CSS或者JS文件进行合并压缩；尤其是在移动端开发的时候，如果CSS或者JS内容不是特别多，我们可以采取内嵌模式，以此减少HTTP请求的次数，加快页面加载速度：1) CSS合并成一个，JS最好也合并成一个2) 首先通过一些工具（例如：webpack）把合并后的CSS或者JS压缩成XX.min.js，减少文件大小3) 服务器端开启资源文件的GZIP压缩…通过一些自动化工具完成CSS以及JS的合并压缩，或者再完成LESS转CSS，ES6转ES5等操作，我们把这种自动化构建模式，称之为前端工程化开发 采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而是用默认占图占位，当页面加载完成后，根据相关条件一次加载真实图片（减少页面首次加载HTTP请求的次数）真实项目中，我们开始图片都不加载，页面首次记载完成，先把第一屏中可以看见的图片进行加载，随着页面滚动，把下面区域中能够有显现的图片进行加载。 对于不经常更新的数据，最好采用浏览器的304缓存做处理例如：第一次请求CSS和JS下来，浏览器会把请求的内容缓存起来，如果做了304处理，用户再起请求CSS和JS。直接从缓存中读取，不需要再去服务器获取了（减少了HTTP请求次数） 当用户刷新页面（CTRL+F5）或者当前缓存的CSS或者JS发生了变动，都会从新从服务器进行拉取 对于客户端来讲，我们还可以基于localStorage来做一些本地存储，例如：第一次请求的数据或者不经常更新的CSS和JS，我们都可以吧内容存储在本地，下次页面加载，我们从本地中获取即可，我们设定一定期限或者一些标识，可以控制在某个阶段重新从服务器获取 根据图片懒加载级啊，我们可以扩充出，数据懒加载。懒加载1）开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器端进行请求（有些网站首屏数据是后台渲染好的，整体返给客户端显现的）2) 当页面下拉，滚动到那个区域，在把这个区域所需要的数据进行轻轻（请求回来做数据绑定以及图片延迟加载等）3) 分页展示技术采用的也是数据的懒加载技术实现的：如果我们请求获取的数据是很多的数据，我们最好分批请求，开始只请求第一页的数据，当用户点击第二页（微博的下拉到一定距离后，宰庆秋第二页数据。。。）的时候再请求第二页数据。。。 5. 使用字体图标代替一些页面中的位图（图片），这样不仅做适配的时候方便，而且更加轻量级，而且减少了HTTP请求的次数（类似雪碧图） 如果当前页面中出现了AUDIO或者VIDEO标签，我们最好设置他们的preload=none：页面加载的时候，音频和视频不进行加载，播放的时候再开始加载（减少页面瘦子加载HTTP请求的次数）preload=auto：页面首次加载的时候就把音频和视频资源进行加载了preload=metadata：页面首次加载的时候只把音频视频资源的头部信息进行加载（比如时长） 7.在客户端和服务器端进行通信数据的时候，我们尽量采用JSON格式进行数据传输[优势]1) JSON格式的数据，能够清晰明了的展示出数据结构，而且也方便我们获取的操作2) 相对于很早以前的XML格式传输，JSON格式的数据更加轻量级3) 客户端和服务器端都支持JSON格式数据的处理，处理起来非常方便 真实项目中，并不是所有的数据都是JSON，我们尽量可能这样做，但是对于某些特殊需求（例如：文件流的传输或者文档传输），使用JSON就不合适了 采用CDN加速CDN地域式（地域分布式） 关于编写代码时候的一些优化技巧除了减少HTTP请求次数和大小可以优化性能，我们在编写代码的时候，也可以进行一些优化，让页面的性能有所提升（有些不好的代码编写习惯会导致页面性能消耗太大，例如：内存泄露） 在编写JS代码的时候剑灵减少对DOM的操作在JS中操作DOM是一个非常消耗性能的事情，但是我们有不可避免的操作DOM，我们只能尽量减少对于它的操作 [操作DOM弊端]1) DOM存在映射机制（JS中的DOM元素对象和页面中的DOM结构是存在映射机制的，一改则都改）这种映射机制，是浏览器按照W3C标准完成对JS语言的构建和DOM的构建（其实就是构建了一个监听机制），操作DOM是同时要修改两个地方，相对于一些其他的JS变成来说是消耗性能的。2) 页面中的DOM结构改变或者样式改变，会触发浏览器的回流（浏览器会把DOM结构重新进行计算，这个操作很消耗性能）和重绘（把一个元素的样式重新渲染） 编写代码的时候，更多的使用异步编程同步变成会导致：上面东西不完成，下面任务也做不了，我们开发的时候，可以吧某一区域模块都设置为异步编程，这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面模块的堵塞影响（用的不多） 尤其是AJAX数据请求，我们一般都需要使用异步编程，最好是基于promise设计模式进行管理（项目中经常使用fetch，axios等插件来进行AJAX请求处理，因为这些插件中就是基于promise设计模式对ajax进行的封装处理） 在真实项目中，我们尽量避免一次性循环过多数据（因为循环操作是同步编程），尤其是要避免while导致的死循环操作 CSS选择器优化1) 尽量减少标签选择器的使用2) 尽可能少使用ID选择器，多使用样式雷选择器（通用性强）3) 减少选择器前面的前缀，例如：1.headerBOX .nav .left a&#123;&#125; (选择器是从右往左查找的) 避免使用CSS表达式123.box&#123;background-color: expression((new Data()).getHours()%2?'red':'blue');&#125; 减少页面中的用于代码，尽可能提高方法的重复使用率：“低耦合高内聚” 最好CSS放在HEAD中，JS放在BODY尾部，让页面加载的时候，先加载CSS，在加载JS（先呈现页面，在给用户提供操作） JS中避免使用eval1) 性能消耗大2) 大妈压缩后，容易出现代码执行错乱问题 JS中尽量减少闭包的使用1) 闭包会形成一个不销毁的栈内存，过多的栈内存积累会影响页面的性能2) 还会容易导致内存的泄露 闭包自己的优势：保存和保护，我们只能尽量减少，但是无可避免 在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现 事件委托（事件代理）把事件绑定给外层容器，当里面的后代元素相关行为被触发，外层容器绑定的方法也会被触发执行（冒泡传播机制导致），通过事件源是谁，我们做不同的操作即可 尽量使用CSS3动画代替JS动画，因为CSS3的动画或者变形都开启了硬件加速，性能比JS动画好 编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性 关于页面的SEO优化技巧 页面中杜绝出现死链接（404页面）而对于用户用户输入一个错误页面我们要引导到404提示页面中（服务器处理的） 避免浏览器中异常错误的抛出尽可能避免代码出错使用TYE CATCH做异常信息捕获"},{"title":"安装mongodb","date":"2018-11-12T08:05:01.000Z","path":"2018/11/12/安装mongodb/","text":"0下载mongodb0.1下载去mongodb官网下载，传送门选择相应版本进行下载如图所示： 0.2解压tar包进入所mongodb下载位置，进行解压 tar -zxvf mongodb-linux-x86_64-rhel62-4.0.4.tgz 之后将解压包拷贝到指定目录 mv mongodb-linux-x86_64-rhel62-4.0.4/ /usr/local/mongodb 1创建配置文件1.1创建数据库文件夹进入对应的文件夹下 mkdir data 1.2创建日志文件 mkdir log 1.3 创建配置文件夹etc mkdir etc 1.4 创建配置文件进入etc目录下 cd /usr/local/mongodb/etc 在这个目录下创建mongodb.conf vim mongodb.conf 这里根据个人的安装路径进行配置，基于我的路径进行如下配置：12345678910111213141516#数据库路径dbpath=/usr/local/mongodb/data#日志输出文件路径logpath=/usr/local/mongodb/log/mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port=27017#关闭http接口，默认关闭27018端口访问#nohttpinterface = true#以守护程序的方式启用，即在后台运行fork = true 2启动mongodb2.1简单的启动mongodb进入mongodb文件下的bin文件夹下 cd /usr/local/mongodb/bin 执行命令./mongo即可 ./mongod -f /usr/local/mongodb/etc/mongodb.conf 之后我们可以查看27017端口号是否启动 netstat -tunlp|grep 27017 如图所示： 2.2添加管理用户(mongoDB 没有无敌用户root，只有能管理用户的用户 userAdminAnyDatabase)利用mongo命令连接mongoDB服务器端： ./mogo 输入下面命令进行添加用户1234&gt; use adminswitched to db admin&gt; db.createUser( &#123;user: &quot;pfnieadmin&quot;,pwd: &quot;123456&quot;,roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]&#125;); 成功后，你将会看到:添加完用户后可以使用show users或db.system.users.find()查看已有用户.添加完管理用户后，关闭MongoDB，并使用权限方式再次开启MongoDB，这里注意不要使用kill直接去杀掉mongodb进程，（如果这样做了，请去data/db目录下删除mongo.lock文件），可以使用db.shutdownServer()关闭. 2.3使用权限方式启动在配置文件中添加：auth=true , 然后启动：1234567891011121314151617#数据库路径dbpath=/usr/local/mongodb/data#日志输出文件路径logpath=/usr/local/mongodb/log/mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port=27017#关闭http接口，默认关闭27018端口访问#nohttpinterface = true#以守护程序的方式启用，即在后台运行fork = trueauth=true 进入mongo shell，使用admin数据库并进行验证，如果不验证，是做不了任何操作的。 use admin db.auth(“pfnieadmin”,”123456”) #认证，返回1表示成功 如图所示，在进入mogoshell时直接用show users会报错，只有先认证后才能使用shell 3优化mongodb3.1设置mongod环境变量 cd /etcvim profile 到etc下打开profile文件在/etc/profile文件中，添加 export PATH=$PATH:/usr/local/mongoDB/mongodbserver/bin 如图所示：执行source /etc/profile，使系统环境变量立即生效 3.2设置mongo软连接 ln -s /usr/local/mongodb/bin/mongo /usr/bin/mongo 配置完成这些，我们关闭mongo服务，可以随处启动mongo mongod -f /usr/local/mongodb/etc/mongodb.conf 4遇到的坑如果单单是这样配置后，mongodb只能在本地使用,我们可以测试一下，输入命令 netstat -tnlp 如图所示：想要远程使用，需要配置配置文件mongodb.conf在mongodb. bind_ip=0.0.0.0 最终配置文件如下12345678910111213141516171819#数据库路径dbpath=/usr/local/mongodb/data#日志输出文件路径logpath=/usr/local/mongodb/log/mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port=27017#关闭http接口，默认关闭27018端口访问#nohttpinterface = true#以守护程序的方式启用，即在后台运行fork = trueauth=true#绑定端口号，否则外网无法访问bind_ip=0.0.0.0 这时候我们再测试 netstat -tnlp 结果如图所示：之后我们需要配置腾讯云安全组：这时候我们通过浏览器进行访问，如图所示：这样我们就通过我们的本地工具进行连接吧，这里推荐工具ROBO连接后效果如图所示：为了方便使用我这里先把auth=true注掉取消认证"},{"title":"安装MySQL","date":"2018-11-12T06:19:05.000Z","path":"2018/11/12/安装MySQL/","text":"1.新建用户 1.1 登录MYSQL： @&gt;mysql -u root -p @&gt;密码 1.2 创建用户： mysql&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”test”,password(“1234”)); 这样就创建了一个名为：test 密码为：1234 的用户。 注意：此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。 1.3 然后登录一下： mysql&gt;exit; @&gt;mysql -u test -p @&gt;输入密码 mysql&gt;登录成功 2.为用户授权 授权格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”; 2.1 登录MYSQL（有ROOT权限），这里以ROOT身份登录： @&gt;mysql -u root -p @&gt;密码 2.2 首先为用户创建一个数据库(testDB)： mysql&gt;create database testDB; 2.3 授权test用户拥有testDB数据库的所有权限（某个数据库的所有权限）： mysql&gt;grant all privileges on testDB.* to test@localhost identified by ‘1234’; mysql&gt;flush privileges;//刷新系统权限表 格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”; 2.4 如果想指定部分权限给一用户，可以这样来写: mysql&gt;grant select,update on testDB.* to test@localhost identified by ‘1234’; mysql&gt;flush privileges; //刷新系统权限表 2.5 授权test用户拥有所有数据库的某些权限： mysql&gt;grant select,delete,update,create,drop on . to test@”%” identified by “1234”; //test用户对所有数据库都有select,delete,update,create,drop 权限。 //@”%” 表示对所有非本地主机授权，不包括localhost。（localhost地址设为127.0.0.1，如果设为真实的本地地址，不知道是否可以，没有验证。） //对localhost授权：加上一句grant all privileges on testDB.* to test@localhost identified by ‘1234’;即可。 删除用户 @&gt;mysql -u root -p @&gt;密码 mysql&gt;Delete FROM user Where User=’test’ and Host=’localhost’; mysql&gt;flush privileges; mysql&gt;drop database testDB; //删除用户的数据库 删除账户及权限：&gt;drop user 用户名@’%’; &gt;drop user 用户名@ localhost; 修改指定用户密码 @&gt;mysql -u root -p @&gt;密码 mysql&gt;update mysql.user set password=password(‘新密码’) where User=”test” and Host=”localhost”; mysql&gt;flush privileges; 列出所有数据库 mysql&gt;show database; 切换数据库 mysql&gt;use ‘数据库名’; 列出所有表 mysql&gt;show tables; 显示数据表结构 mysql&gt;describe 表名; 删除数据库和数据表 mysql&gt;drop database 数据库名; mysql&gt;drop table 数据表名;"},{"title":"构建cli脚手架","date":"2018-11-11T04:38:43.000Z","path":"2018/11/11/构建cli脚手架/","text":"0搭建前准备环境0.1创建项目nodejs环境是必备的，这里不多说了，首先需要 npm init -y初始化一个项目。然后创建一个index.js,整个项目结构如下.之后我们需要写的部分都在index.js中。 0.2配置项目 这里注意下为了系统能识别为node脚本，需要在index首行声明如下 #!/usr/bin/env node 配置package.json在末尾加上这段配置 “license”: “ISC”, “bin”: { “cli”: “index.js” }, 说明一下cli即为我们的命令，可以理解为vue-cliindex则为我们需要执行的脚本 0.3生成全局命令在index.js的目录下输入 npm link 这样就生成了全局变量，在任何地方只要输入cli就会执行index.js中的脚本。可以写一个console.log试试 1命令包安装commander.js1.1commander说明commander是一个轻巧的nodejs模块，提供了用户命令行输入和参数解析强大功能可以在github上直接搜索这个项目传送门下载 npm install commander -s 引用 const program = require(‘commander’); 1.2commander配置直接复制Examples下的代码到index中1234567891011121314program .command('exec &lt;cmd&gt;') .alias('ex') .description('execute the given remote cmd') .option(\"-e, --exec_mode &lt;mode&gt;\", \"Which exec mode to use\") .action(function(cmd, options)&#123; console.log('exec \"%s\" using %s mode', cmd, options.exec_mode); &#125;).on('--help', function() &#123; console.log(''); console.log('Examples:'); console.log(''); console.log(' $ deploy exec sequential'); console.log(' $ deploy exec async'); &#125;); 这些就是一个命令全部内容命令名称为： .command(‘exec [env]’) list代表命令名称 [env]代表参数其中[]内的参数为可选参数其中&lt;&gt;内的参数为必填参数命令说明为： .description(‘execute the given remote cmd’) 操作方法为： .action(function(template, project){} 输入–help操作为： .on(‘–help’, function() {}) 其中 –help命令不需要额外配置，它会根据配置自动生成 1.3commander错误命令提示错误配置代码如下：12345program .command('*') .action(function(env)&#123; console.log('deploying \"%s\"', env); &#125;); 1.4commander配置版本号版本号配置代码如下12program .version('0.1.0') //调用-v或者 --version的时候输出该版本号 2下载包download-git-repo.js2.1准备模板这里我准备了三个模板供下载，在github上创建三个空项目，自动生成README.md出来如图所示：.创建项目这里就不多说了。 2.2下载download-git-repo.js用npm下载 npm install download-git-repo -s 引用 const download = require(‘download-git-repo’) 传送门 123download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; console.log(err?'err':'success')&#125;) downloadUrl 为仓库地址路径 project 为创建项目的名称，即我本地想叫什么名 {clone:true} 进行克隆 err=&gt;{}错误原因并在下载结束后执行方法2.3完成下载我们希望输入命令 cli vue new_vue 生成一个new_vue的项目并应用我们的vue_template模板，同理其他模板也用相应命令进行创建 首先我们创建一个对象来放我们的模板名称和路径和简介1234567891011121314151617templates=&#123; 'vue':&#123; url:\"https://github.com/linjiad/vue_template.git\", description:\"vue模板\", downloadUrl:\"direct:https://github.com:linjiad/vue_template#master\" &#125;, 'react':&#123; url:\"https://github.com/linjiad/react_template.git\", description:\"react模板\", downloadUrl:\"direct:https://github.com:linjiad/react_template#master\" &#125;, 'angular':&#123; url:\"https://github.com/linjiad/angular_template.git\", description:\"angular模板\", downloadUrl:\"direct:https://github.com:linjiad/angular_template#master\" &#125;&#125; 这里开始写program命令12345678910111213141516program .command('init &lt;template&gt; &lt;project&gt;') //命令 .description('初始化项目模板') .action(function(template, project)&#123; const &#123;downloadUrl&#125; = templates[template]; //根据模板名(template)下载对应模板，并命名为(project) //第一个参数：仓库地址 //第二个参数：下载路径,下载到哪 download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; if(err)&#123; return console.log('下载失败：'+err); &#125; else&#123; return console.log('下载成功'); &#125; &#125;) &#125;); 这样简单的模板下载就成功了 3交互handlebars和inquirer3.1配置模板中的package.json在模板中创建package.json,同时把需要客户填写的地方配置成可变的,代码如下123456789101112&#123; \"name\": \"&#123;&#123; name &#125;&#125;\", \"version\": \"1.0.0\", \"description\": \"&#123;&#123; description &#125;&#125;\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"&#123;&#123; author &#125;&#125;\", \"license\": \"ISC\"&#125; 其中”name”: ““为用户输入的项目名 “description”: ““,为项目说明 “author”: “linjiad“,为作者姓名3.2下载handlebars和inquirer handlebars:模板引擎传送门 npm install handlebars -s 引用 const handlebars = require(‘handlebars’); inquirer:向导传送门 npm install inquirer -s 引用 const handlebars = require(‘inquirer’); 3.2修改program命令我们的思路分为以下几部 把项目下的 package.json 文件读取出来 使用想到的方式采集用户输入的值 使用模板引擎把用户输入的数据解析到package.json中 解析完毕，把解析之后的结果重新写入package.json中在此之前我们要用的nodejs中的读写fs模块 const fs = require(‘fs’); 修改后代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243program .command('init &lt;template&gt; &lt;project&gt;') //命令 .description('初始化项目模板') .action(function(template, project)&#123; const &#123;downloadUrl&#125; = templates[template]; //根据模板名(template)下载对应模板，并命名为(project) //第一个参数：仓库地址 //第二个参数：下载路径,下载到哪 download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; if(err)&#123; return console.log('下载失败：'+err); &#125; else&#123; // 把项目下的package.json读取 // 采取向导方式采集用户输入的值 // 使用模板引擎把用户输入的数据解析到package.json // 解析之后的结果从新写入package.json inquirer.prompt([ &#123; typ: 'input', name: 'name', message: '请输入项目名称' &#125;, &#123; typ: 'input', name: 'description', message: '请输入项目简介' &#125;, &#123; typ: 'input', name: 'author', message: '请输入作者姓名' &#125;, ]).then((answers)=&gt;&#123; const packagePath = `$&#123;project&#125;/package.json`; //把数据替换到package.json中 const packageContent = fs.readFileSync(packagePath,'utf8'); const packageResult = handlebars.compile(packageContent)(answers); fs.writeFileSync(packagePath,packageResult) console.log(logSymbols.success,chalk.green(\"初始化模板成功\")) &#125;) &#125; &#125;) &#125;); 这样整个cli脚本就更加人性化了 4美化脚本4.1添加loading效果 ora.jsora:loading美化传送门下载 npm install ora -s 引用 var ora = require(‘ora’); 使用： const spinner = ora(‘正在下载模板…’).start(); spinner.fail(‘下载失败’);//下载失败提示 spinner.succeed(‘下载成功’); //下载成功提示 4.2添加字体颜色 ora.jschalk:字体美化传送门下载 npm install chalk -s 引用 var chalk = require(‘chalk’); 使用： chalk.red(“错误”)chalk.green(“成功”) 4.3特殊符号 log-symbols.jslog-symbols:特殊符号，如对号错号传送门下载 npm install log-symbols -s 引用 var logSymbols = require(‘log-symbols’); 使用： console.log(logSymbols.erro);console.log(logSymbols.success); 4.4修改program命令修改后的代码如下(既全部代码)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!/usr/bin/env node//命令包const program = require('commander');//下载包const download = require('download-git-repo')//模板引擎const handlebars = require('handlebars');//向导const inquirer = require('inquirer');const fs = require('fs');//loading美化var ora = require('ora');//字体美化const chalk = require('chalk');//符号const logSymbols = require('log-symbols')program .version('0.1.0') //调用-v或者 --version的时候输出该版本号const templates=&#123; 'vue':&#123; url:\"https://github.com/linjiad/vue_template.git\", description:\"vue模板\", downloadUrl:\"direct:https://github.com:linjiad/vue_template#master\" &#125;, 'react':&#123; url:\"https://github.com/linjiad/react_template.git\", description:\"react模板\", downloadUrl:\"direct:https://github.com:linjiad/react_template#master\" &#125;, 'angular':&#123; url:\"https://github.com/linjiad/angular_template.git\", description:\"angular模板\", downloadUrl:\"direct:https://github.com:linjiad/angular_template#master\" &#125;&#125;program .command('init &lt;template&gt; &lt;project&gt;') //命令 .description('初始化项目模板') .action(function(template, project)&#123; //下载之前做loading提示 const spinner = ora('正在下载模板...').start(); const &#123;downloadUrl&#125; = templates[template]; //根据模板名下载对应模板，并命名为project //第一个参数：仓库地址 //第二个参数：下载路径,下载到哪 download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; if(err)&#123; spinner.fail('下载失败');//下载失败提示 return console.log(logSymbols.error,chalk.red(err)) &#125; spinner.succeed('下载成功'); //下载成功提示 // 把项目下的package.json读取 // 采取向导方式采集用户输入的值 // 使用模板引擎把用户输入的数据解析到package.json // 解析之后的结果从新写入package.json inquirer.prompt([ &#123; typ: 'input', name: 'name', message: '请输入项目名称' &#125;, &#123; typ: 'input', name: 'description', message: '请输入项目简介' &#125;, &#123; typ: 'input', name: 'author', message: '请输入作者姓名' &#125;, ]).then((answers)=&gt;&#123; const packagePath = `$&#123;project&#125;/package.json`; //把数据替换到package.json中 const packageContent = fs.readFileSync(packagePath,'utf8'); const packageResult = handlebars.compile(packageContent)(answers); fs.writeFileSync(packagePath,packageResult) console.log(logSymbols.success,chalk.green(\"初始化模板成功\")) &#125;) &#125;) &#125;);program .command('list') //命令 .description('查看所有可用模板') .action(()=&gt;&#123; for(const key in templates)&#123; console.log(`$&#123;key&#125;:$&#123;templates[key].description&#125;.`) &#125; &#125;);program .command('setup [env]') //命令 .description('run setup commands for all envs') .option(\"-s, --setup_mode [mode]\", \"Which setup mode to use\") .action(function(env, options)&#123; var mode = options.setup_mode || \"normal\"; env = env || 'all'; console.log('setup for %s env(s) with %s mode', env, mode); &#125;);program .command('exec &lt;cmd&gt;') .alias('ex') .description('execute the given remote cmd') .option(\"-e, --exec_mode &lt;mode&gt;\", \"Which exec mode to use\") .action(function(cmd, options)&#123; console.log('exec \"%s\" using %s mode', cmd, options.exec_mode); &#125;).on('--help', function() &#123; console.log(''); console.log('Examples:'); console.log(''); console.log(' $ deploy exec sequential'); console.log(' $ deploy exec async');&#125;);program .command('*') //其他的命令 .action(function(env)&#123; console.log('不存在 \"%s\"命令', env); &#125;);program.parse(process.argv); 5npm发布包 打开npm官网 注册一个npm账号 在npm官网上搜索是否有重名4.讲package.json中的那么修改为发布到npm上的名 和本地项目名称没有关系 5.打开控制台，执行npm login，在控制台输入登录6.登陆成功后，在项目下执行npm publish进行发布7 在其他电脑上就可以安装成全局变量了 这样一个脚手架就搭建完毕了"},{"title":"Nginx服务2","date":"2018-11-11T01:09:07.000Z","path":"2018/11/11/Nginx服务2/","text":"5 权限管理5.1 简单权限控制有时候我们的服务器只允许特定主机访问，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在location里进行配置。可以直接在default.conf里进行配置。1234location / &#123; deny 123.9.51.42; allow 45.76.202.231;&#125; 5.2 复杂访问控制权限匹配在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。上面的需求，配置代码如下：123456location =/img&#123; allow all; &#125;location =/admin&#123; deny all;&#125; =号代表精确匹配，使用了=后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全。 5.3 使用正则表达式设置访问权限只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。代码如下：123location ~\\.php$ &#123; deny all;&#125; 6 Nginx设置虚拟主机6.1基于端口号配置虚拟主机基于端口号来配置虚拟主机，算是Nginx中最简单的一种方式了。原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。我们可以直接配置在主文件里etc/nginx/nginx.conf文件里， 也可以配置在子配置文件里etc/nginx/conf.d/default.conf。我这里为了配置方便，就配置在子文件里了。当然你也可以再新建一个文件，只要在conf.d文件夹下就可以了。添加配置文件中的server选项，这时候就会有两个server。123456server&#123; listen 8001; server_name localhost; root /usr/share/nginx/html/html8001; index index.html; &#125; 编在usr/share/nginx/html/html8001/目录下的index.html文件并查看结果。1&lt;h1&gt;welcome port 8001&lt;/h1&gt; 最后在浏览器中分别访问地址和带端口的地址。看到的结果是不同的。然后我们就可以在浏览器中访问http://112.74.164.244:8001了。 6.2基于IP的虚拟主机基于IP和基于端口的配置几乎一样，只是把server_name选项，配置成IP就可以了。比如上面的配置，我们可以修改为：123456server&#123; listen 80; server_name 112.74.164.244; root /usr/share/nginx/html/html8001; index index.html; &#125; 7 Nginx使用域名这里我购买的是腾讯云，所以根据提示直接在腾讯云上进行配置按照提示填写即可修改配置即可123456server&#123; listen 80; server_name www.linjiad.cn; root /usr/share/nginx/html/html8001; index index.html; &#125; 8Nginx反向代理8.1正向代理和反向代理大家都知道，我们现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。正向代理:如果你觉的反向代理不好理解，那先来了解一下正向代理。我相信作为一个手速远超正常人的程序员来说，你一定用过翻墙工具（我这里说的不是物理梯子），它就是一个典型的正向代理工具。它会把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做proxy服务器，再转发给客户。简单来说就是你想访问目标服务器的权限，但是没有权限。这时候代理服务器有权限访问服务器，并且你有访问代理服务器的权限，这时候你就可以通过访问代理服务器，代理服务器访问真实服务器，把内容给你呈现出来。 反向代理:反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。反向代理的用途和好处: 安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。 功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡8.2最简单的反向代理现在我们要访问http://www.linjiad.cn:8002/然后反向代理到http://www.linjiad.cn这个网站。我们直接到etc/nginx/con.d/8001.conf进行修改。添加个配置文件如下：1234567server&#123; listen 8002; server_name localhost; location / &#123; proxy_pass http://www.linjiad.cn; &#125;&#125; 一般我们反向代理的都是一个IP，但是我这里代理了一个域名也是可以的。其实这时候我们反向代理就算成功了，我们可以在浏览器中打开 8.3其它反向代理指令反向代理还有些常用的指令，我在这里给大家列出： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。9Nginx适配PC或移动设备现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。$http_user_agent的使用：Nginx通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。操作步骤如下： 在/usr/share/nginx/目录下新建两个文件夹，分别为：pc和mobile目录 输入命令如下 cd /usr/share/nginx mkdir pc mkdir mobile 在pc和miblic目录下，新建两个index.html文件，文件里下面内容 12&lt;h1&gt;I am pc!&lt;/h1&gt;&lt;h1&gt;I am mobile!&lt;/h1&gt; 进入etc/nginx/conf.d目录下，修改8001.conf文件，改为下面的形式: 1234567891011server&#123; listen 80; server_name nginx2.jspang.com; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &apos;(Android|webOS|iPhone|iPod|BlackBerry)&apos;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; 10Nginx的Gzip压缩配置10.1Gzip技术Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持从上图可以清楚的明白，gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。 10.2gzip的配置项Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。10.3gzip最简单的配置123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。如果你是windows操作系统，你可以按F12键打开开发者工具，单机当前的请求，在标签中选择Headers，查看HTTP响应头信息。你可以清楚的看见Content-Encoding为gzip类型。"},{"title":"Nginx服务1","date":"2018-11-10T12:32:46.000Z","path":"2018/11/10/Nginx服务1/","text":"0前期准备0.1 安装基础环境 yum -y install gcc gcc-c++ autoconf pcre-devel make automake yum -y install wget httpd-tools vim 0.2建立根目录 进入系统后，在目录下建立了一个linjiad的文件夹，命令是 mkdir linjiad。 进入 linjiad文件夹 ,命令是 cd linjiad。 分别使用mkdir建立 app,backup,download,logs,work文件夹。 1安装Nginx1.1准备安装 yum list | grep nginx 结果显示nginx的各个版本，如图所示： 创建一个文件 vim /etc/yum.repos.d/nginx.repo 复制进去这些配置 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/gpgcheck=0enabled=1 因为我的是centos和7的版本，所以改为这样。 1baseurl=http://nginx.org/packages/centos/7/$basearch/ 1.2开始安装安装的命令非常简单： yum install nginx 出现如图所示则证明安装成功 2修改Nginx的配置2.1查看nginx的安装查看nginx安装到哪里 rpm -ql nginx出现如图所示 其中nginx.conf 文件是Nginx总配置文件，在我们搭建服务器时经常调整的文件。 2.2配置nginx.conf进入etc/nginx目录下，然后用vim进行打开 cd /etc/nginxvim nginx.conf 配置如下: 1234567891011121314151617181920212223242526272829303132333435363738#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; # 单个后台进程的最大并发数 worker_connections 1024;&#125;http &#123; #文件扩展名与类型映射表 include /etc/nginx/mime.types; #默认文件类型 default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #nginx访问日志存放位置 access_log /var/log/nginx/access.log main; #开启高效传输模式 sendfile on; #减少网络报文段的数量 #tcp_nopush on; #保持连接的时间，也叫超时时间 keepalive_timeout 65; #开启gzip压缩 #gzip on; #包含的子配置项位置和文件 include /etc/nginx/conf.d/*.conf;&#125; 进入进入conf.d目录vim default.conf进行查看。conf.d目录下的配置相当于子配置，配置如下1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123;listen 80; #配置监听端口server_name localhost; //配置域名#charset koi8-r; #access_log /var/log/nginx/host.access.log main;location / &#123;root /usr/share/nginx/html; #服务默认启动目录index index.html index.htm; #默认访问文件&#125;#error_page 404 /404.html; # 配置404页面# redirect server error pages to the static page /50x.html#error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启location = /50x.html &#123;root /usr/share/nginx/html;&#125;# proxy the PHP scripts to Apache listening on 127.0.0.1:80##location ~ \\.php$ &#123;# proxy_pass http://127.0.0.1;#&#125;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \\.php$ &#123;# root html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;# include fastcgi_params;#&#125;# deny access to .htaccess files, if Apache&apos;s document root# concurs with nginx&apos;s one##location ~ /\\.ht &#123;# deny all;#&#125;&#125; 通过这个配置我们可以知道我们的服务目录放在了/usr/share/nginx/html下，可以使用命令进入看一下目录下的文件 cd /usr/share/nginx/html ls 3Nginx的命令3.1启动Nginx服务在CentOS7.4版本里（低版本是不行的），是可以直接直接使用nginx启动服务的。 Nginx 使用systemctl命令启动还可以使用个Linux的命令进行启动，我一般都是采用这种方法进行使用。因为这种方法无论启动什么服务，都是一样的，只是换一下服务的名字（不用增加额外的记忆点）。 systemctl start nginx.service 输入命令后，没有任何提示，那我们如何知道Nginx服务已经启动了哪？可以使用Linux的组合命令，进行查询服务的运行状况。 ps aux | grep nginx 如果启动成功会出现如下图片中类似的结果。 3.2停止Nginx服务停止Nginx 方法有很多种，可以根据需求采用不一样的方法。 立即停止服务 ：这种方法比较强硬，无论进程是否在工作，都直接停止进程。 nginx -s stop 从容停止服务:这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。 nginx -s quit killall 方法杀死进程:这种方法也是比较野蛮的，我们直接杀死进程，但是在上面使用没有效果时，我们用这种方法还是比较好的 killall nginx systemctl 停止 systemctl stop nginx.service 3.2重启Nginx服务 重启Nginx服务 systemctl restart nginx.service 重新载入配置文件:重新编写或者修改Nginx的配置文件后，都需要作一下重新载入 nginx -s reload 3.3查看端口号在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用netstat -tlnp命令查看端口号的占用情况。 netstat -tlnp 4 自定义错误页面4.1 通用错误页面在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。 error_page 500 502 503 504 /50x.html; error_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误代码，/50.html 用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。 4.2 单独错误页面 单独为错误置顶处理方式有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下： error_page 404 /404_error.html; 然后到网站目录下新建一个404_error.html 文件，并写入一些信息。123456&lt;html&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;body&gt;&lt;h1&gt;404页面没有找到!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 然后重启我们的服务，再进行访问，你会发现404页面发生了变化。 4.3 错误页面换成地址把错误码换成一个地址处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。 error_page 404 http://www.baidu.com;我们使用了百度作为404页面没有找到的提示，就形成了，没有找到文件，就直接跳到了百度上了。"},{"title":"npm包管理服务器","date":"2018-11-10T09:46:54.000Z","path":"2018/11/10/npm包管理服务器/","text":"npm包管理，搭建自己前端的私库 0前期准备0.1 安装node环境首先介绍一下，可以购买云服务器，也可以自己搭建一个虚机。这里我购买的是腾讯云，购买就不多说了，购买之后下过如下之后去node官网下载node包，下载linux版之后放到linux下面某个目录，根据个人喜好之后进行解压 解压 tar xf node-v10.9.0-linux-x64.tar.xz 这里作为一个强迫症患者，我习惯把解压后的文件进行改名为nodejs 改名 mv node-v10.9.0-linux-x64 nodejs 下一步是配置软连接，可以理解为WIN系统下配置环境变量 配置软连接cd到目录下 ln -s /nodejs/bin/npm /usr/local/bin/ ln -s /nodejs/bin/node /usr/local/bin/ 为了方便以后下载包，我们可以下载一个cnpm 安装cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org 同样建立软连接就不多说了 0.2 下载Sinopia npm install -g sinopia 这里也需要建立软连接 ln -s /usr/download/nodejs/lib/node_modules/sinopia/bin/sinopia /usr/local/bin/ 0.3 下载pm2 npm install -g pm2 建立软连接 ln -s /download/nodejs/lib/node_modules/pm2/bin/pm2 /usr/local/bin/ 1配置Sinopia1.1 首先开通端口号我这里用的是腾讯云，开通端口号在安全组中配置，如图所示 这里还有个坑，仅仅开通了端口号是不够的,还需要配置config.yml文件否则还是访问不到的 1.2 配置config.yaml文件打开config.yml文件，这个文件地址在 vim /root/.config/sinopia/config.yaml 在配置最后添加监听 listen: 0.0.0.0:4873 如图所示 config.config.yaml整体配置如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 库存路径，需要考虑磁盘空间storage: ./storage web: # 自定义web项，即浏览器访问页面 # web interface is disabled by default in 0.x, will be enabled soon in 1.x # when all its issues will be fixed # # set this to `true` if you want to experiment with web ui now; # this has a lot of issues, e.g. no auth yet, so use at your own risk #enable: true title: linjiad # logo: logo.png # template: custom.hbsauth: htpasswd: # 添加用户（npm adduser）后自动创建，保存用户信息，可以初始化用户 file: ./htpasswd # Maximum amount of users allowed to register, defaults to \"+inf\". # You can set this to -1 to disable registration. #max_users: 1000 设置为-1不能npm adduser# a list of other known repositories we can talk to # 可以配置多个上游地址，后面packages中的proxy指定用哪个uplinks: npmjs: url: https://registry.npmjs.org/ # amount of time to wait for repository to respond # before giving up and use the local cached copy #timeout: 30s # 请求上游地址超时时间 # maximum time in which data is considered up to date # # default is 2 minutes, so server won't request the same data from # uplink if a similar request was made less than 2 minutes ago #maxage: 2m # 包过期时间 # if two subsequent requests fail, no further requests will be sent to # this uplink for five minutes #max_fails: 2 # 容许依赖请求最大失败数 #fail_timeout: 5m # 依赖请求超时时间 # 包的权限管理，$all为所有人，$authenticated为通过验证人packages: '@*/*': # 跟package.json中的name属性进行匹配 # scoped packages access: $all publish: $authenticated '*': # allow all users (including non-authenticated users) to read and # publish all packages # # you can specify usernames/groupnames (depending on your auth plugin) # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\" access: $all # allow all known users to publish packages # (anyone can register by default, remember?) publish: $authenticated # if package is not available locally, proxy requests to 'npmjs' registry proxy: npmjs# log settingslogs: - &#123;type: stdout, format: pretty, level: http&#125; #- &#123;type: file, path: sinopia.log, level: info&#125;# 设置监听地址，0.0.0.0匹配本机地址listen: 0.0.0.0:4873 这时候可以访问以下看看如图所示 1.3 用pm2管理项目为了一直启动需要安装pm2对项目进行管理用pm2启动sinopia pm2 start sinopia 设置开机启动 pm2 startup ubuntu # 或centos，看具体环境 保存设置 pm2 save 客户端操作通过以上步骤服务器端基本配置完毕，下面我们修改客户端来实现从我们自己的服务器下载包在客户端下载nrmnrm是个方便的npm源管理工具，来做快速registry切换，当然你也可以不用下载，直接修改本地的npm下载路径即可 npm install -g nrm 查看目前的路径 nrm ls 如图所示加入新创建的私有库地址 nrm add xgnpm http://{ip}:{port}/ 切换下载地址为私有库地址 nrm use xgnpm 然后我们可以实验一下随变下载一个包就会发现如果私有库没有这个包就会去npm下载并存在/root/.config/sinopia/sinopia里面如果有就会直接下载 备注：添加用户可以再客户端通过命令： npm adduser 来添加 3导言由于上一个服务器搭建成功后发现无法下载@的包，简直是坑有木有，上网上收集了一些资料发现原来sinopia早已不更新了，大家可以看我的报错如下：简直坑有木有 4安装verdaccio基于上一个服务器安装这里就不需要安装node等基础环境了，直接安装1安装verdaccio就可以 npm install -g verdaccio –unsafe-perm 配置软连接 ln -s /usr/download/nodejs/lib/node_modules/verdaccio/bin/verdaccio /usr/local/bin/ 这里可以查看一下我们都软连接了哪些命令 cd /user/local/binls 5修改verdaccio的配置和sinopia一样你在哪个目录运行，它的就会在对应的目录下创建自己的文件。目录下默认有两个文件：config.yaml和storage，htpasswd 是添加用户之后自动创建的;这里我和sinopia放在了一起。配置啥的都参照sinopia这里就不多说了之后用pm2启动就可以了。"},{"title":"商业模式新生代","date":"2018-05-26T01:57:25.000Z","path":"2018/05/26/商业模式新生代/","text":"这本书讲述了商业模式，好像是废话，不多说了看看本书的结构吧 1商业模式画布1.1商业模式定义商业模式描述了企业如何创造价值、传递价值和获取价值的基本原理。本书提供一个了商业模式的框架，它使得我们能够描述和思组织、竞争对手和其他企业的商业模式。该框架提供了一种描述商业模式的共同语言，有了它方便我们分析其他企业的商业模式并寻找商业上的创新。通过9个基本构造块就可以很好地描述并定义商业模式，它们可以展示出企业创造收入的逻辑。 1.29基本构造块CS客户细分CS客户细分，Customer Segments，企业或机构所服务的一个或多个客户分类群体。为了更好地满足客户，企业可能把客户分成不同的细分区隔，每个细分区隔中的客户具有共同的需求、共同的行为和其他共同的属性。企业必须做出合理决议，到底该服务哪些客户细分群体，该忽略哪些客户细分群体。然后凭借对特定客户群体需求的深刻理解，设计相应的商业模式。 VP价值主张VP价值主张，Value Propositions，通过价值主张来解决客户难题和满足客户需求。价值主张构造块用来描绘为特定客户细分创造价值的系列产品和服务，它是用户选择你的原因，是公司提供给用户的利益集合。 CH渠道通路CH渠道通路，Channels，通过沟通、分销和销售渠道向客户传递价值主张。作用：提升公司产品和服务在客户中的认知:帮助客户评估公司价值主张:协助客户购买特定产品和服务:向客户传递价值主张:提供售后客户支持。 CR客户关系CR客户关系，Customer Relationships，在每一个客户细分市场建立和维系客户关系。动机：客户获取；客户维系；提升销量。 R$收入来源R$收入来源，Revenue Streams，收入来源产生于成功提供给客户的价值主张。用于描述公司从每个用户群体获取的现金收入，需要从创收中扣除成本。 KR核心资源KR核心资源，Key Resources，核心资源是用来描绘商业模式有效运转所必须得最重要因素。如：实体资产；知识资产；人力资源；金融资产等。 KA关键业务KA关键业务，Key Activities，通过执行一些关键业务活动，运转商业模式。用来描绘为了确保其商业模式可行，企业必须做的最重要的事情。如：制造产品；问题解决；平台/网络。 KP重要合作KP重要合作，Key Partnerships，有些业务要外包，而另外一些资源需要从企业外部获得。用来描述让商业模式有效运作所需的供应商与合作伙伴的网络。 C$成本结构C$成本结构，Cost Structure，商业模式上述要素所引发的成本构成。成本结构特点：固定成本；可变成本；规模经济；范围经济。 2 式样本书说明了以下几种式样 2.1 非绑定式商业模式有三种不同的基本业务类型:客户关系型业务、产品创新型业务和基础设施型业务。每种类型都包含不同的经济驱动因素、竞争驱动因素和文化驱动因素。这三种类型可能同时存在于一家公司里，但是理论上这三种业务“分离”成独立的实体，以便避免冲突或不利的权衡妥协。 2.2 长尾式商业模式长尾式商业模式的核心是多样少量:他们关注于为利基市场提供大量产品，每种产品相对而言卖得都少。利基产品销售总额可以与凭借少量畅销产品产生绝大多数销售额的传统模式相媲美。.长尾模式需要低库存成本和强大的平台，并使得利基产品对于兴趣买家来说容易获得。 2.3 多边平台式商业模式多边平台将两个或者更多有明显区别但又相互依赖的客户群体集合在一起。只有相关客户群体同时存在的时候，这样的平台才具有价值。多边平台通过促进各方客户群体之间的互动来创造价值。多边平台需要提升其价值，直到它达到可以吸引更多用户的程度，这种现象被称为网络效应。比如：信用卡连接了商家和持卡人;计算机操作系统连接了硬件生产商、应用开发商和用户:报纸连接了读者和广告主;家用视频游戏机连接了游戏开发商和游戏玩家。这里的关键是多边平台必须能同时吸引和服务所有的客户群体并以此来创造价值。多边平台对于某个特定用户群体的价值本质上依赖于这个平台“其他边”的用户数量。如果有足够多的游戏，一款家用游戏机平台就能吸引足够多的玩家。另一方面，如果有足够的游戏玩家已经在玩游戏了，游戏开发商也会为新的视频游戏机开发(更多的)游戏二所以多边平台经常会面临着一个“先有鸡还是先有蛋”左右为难的困境。解决这个问题的方法是针对一个群体。尽管多边平台的运营商最主要的成本是运营费用，但是他们经常会通过为一个群体提供低价甚至免费的服务来吸引他们，并依靠这个群体来吸引与之相对的另一个群体。多边平台的运营商所面临的困难是选择哪个群体，以及以什么价格来吸引他们。 2.4 免费式商业模式在免费式商业模式中，至少有一个庞大的客户细分群体可以享受持续的免费服务。免费服务可以来自多种模式。通过该商业模式的其他部分或其他客户细分群体，给非付费客户细分群体提供财务支持。 免费广告：多变平台的式样基于广告的免费商业模式是多边平台的一个表现形式。平台的一边被设计成以免费的内容、产品或服务来吸引用户，平台的另一边通过销售广告位来产生收入。 费增收商业模式:基础免费，增值收费免费增收模式中有大量基础用户受益于没有任何附加条件的免费产品或服务。大部分免费用户永远不会变成付费客户:只有一小部分，通常不超过所有用户的10%的用户会订阅收费的增值服务。这一小部分付费用户群体所支付的费用将用来补贴免费用户。只有在服务额外免费用户的边际成本极低的时候这种模式才成为可能。在免费增收模式中，关键的指标是为单位用户提供免费服务的成本和免费用户变成付费用户的转化率。 开源:变形的免费增收模式例举RedHat的案例，我理解的是：类似短信服务平台从运营商那里购买短信通道，然后租赁给多个企业使用赚取服务费，因为没有企业愿意承担直接从运营商购买短信通道的高额费用。 保险模式:颠倒的免费增收在免费增收模式中，少量为高级服务付费的客户补贴大量非付费客户。而保险模式则相反，在保险模式中，大量用户定期支付小额费用，来保护自己预防那些一旦发生在财务上就是毁灭性的小概率事件。简而言之，大量付费客户补贴有实际需求的少量客户，而且付费客户可以在任何时间成为受益客户群中的一员(即获赔客户)。 诱钓模式诱钓指的是通过廉价的、有吸引力的甚至是免费的初始产品或服务，来促进相关产品或服务未来的重复购买的商业模式式样。这种模式也称为亏损特价品或剃刀与刀片模式。亏损特价品指的是最初补贴甚至亏本提供，目的是从客户后续购买产生利润的产品或服务。 剃刀与刀片用来描述使用最初产品或服务引诱客户而从后续销售中赚取收入的普遍想法。移动通信行就是个好案例，移动网络运营商提供绑定服务订阅的免费手机已经是标准的做法了。运营商起初赔钱免费赠送手机，但他们很容易通过后续的月服务费弥补损失。运营商以免费产品提供瞬间愉悦，随后产生经常性收入。 1904年，金·吉列将第一款可替换刀片剃须刀推向市场，并以极低的折扣销售刀架，甚至作为其他产品的赠品来销售，以此创造一次性刀片的需求。这种模式的关键是找到便宜甚至免费的初始产品和后续重复消费产品之间的紧密联系。控制这种“锁定”关系是成功的关键。通过专利限制，激烈保证了竞争对手无法为吉列刀架提供更便宜的刀片。剃须刀是世界上专利保护最完善的消费产品，有超过1000种专利/低价打印机，高价墨盒/最后我们来看一下这章脑图 2.5 开放式商业模式开放式商业模式可以用于那些通过与外部伙伴系统性合作，来创造和捕捉价值的企业。这种模式可以是“由外到内”，将外部的创意引入公司内部，也可以是“由内到外”，将企业内部闲置的创意和资产提供给外部伙伴。 3 设计 3.1 客户洞察基于客户洞察建立商业模式。我们要从客户的角度来看待商业模式，这可以让我们找到全新的机会。这并不意味着全按照客户的思维来设计商业模式，但是在评估商业模式的时候需要把客户的思维融入进来。创新的成功需要依靠对客户的深人理解，包括环境、日常事务、客户关心的焦点及愿望。采用客户视角是整个商业模式设计过程的指导原则，应该让客户视角来指引我们关于价值主张、渠道通路、客户关系和收入来源的选择。 真正的挑战在于建立对客户的彻底理解，并基于这种理解进行商业模式设计的选择。在产品和服务设计领域，许多领先企业都与社会学家合作，加深对客户的理解。创新的挑战是建立在对客户的深刻理解上，而不是简单的问他们需要什么。 另一个挑战在于要知道该听取哪些客户和忽略哪些客户的意见。应避免过于聚焦于现有客户细分群体，而应该盯着新的和为满足的客户细分群体。许多商业模式创新的成功，正是因为它们满足了新客户未得到满足的需求。 移情图（empathy map）首先找出客户细分群体，并选择一个开始客户描述分析。先给这个客户一个名字和一些人口统计特征，诸如收入、婚姻情况等。然后询问和回答以下六个问题，在活动挂图或白板上描绘你的新命名的客户。我们的目标是建立一种客户的视角，来持续质疑你的商业模式中的各种假设。 3.2 创意构思需要产生大量商业模式创意，并筛选出最好的创意生成全新商业模式创意。设计新的商业模式需要产生大量商业模式创意，并筛选出最好的创意，这个收集和筛选的过程叫做创意构思。设计新的商业模式时，面对的挑战是忽略现状和暂停关注运营的问题，这样我们才能得到真正的全新创意。 创意构思的两个阶段：创意生成，这个阶段重视数量。创意合成，讨论所有的创意，加以组合，并缩减到少量可行的可选方案。这些方案不一定要代表颠覆性的商业模式，也许只是把你现有的商业模式略做扩展。 商业模式创新的多个集中点我们可以把创新区分为4类不同集中点的商业模式创新，这4个集中点每一个都可以成为主要商业模式变化的起点。有时，商业模式可以引发自多个集中点。 资源驱动型创新起源于一个组织现有的基础设施，抑或合作关系拓展，抑或转变现有商业模式。 产品/服务驱动型创新是以建立新的价值主张的方式来影响其他商业模式构造块。 客户驱动型创新是基于客户需求、降低获取成本或提高便利性的。就像所有从单一集中点所引发的创新一样，来自客户驱动的创新同样可以影响商业模式的构造块。 财务驱动创新是由收入来源、定价机制或成本结构来驱动的，同样影响商业模式的其他构造块。 多中心驱动创新是由多个集中点驱动的，并会显著影响商业模式的其他多个构造块。 3.3 可视思考可视思考的价值。对于商业模式的相关工作来说，可视思考是必不可少的。我们所谓的可视思考，是指使用诸如图片、草图、图表和便利贴等视觉化工具来构建和讨论事情。因为商业模式是由各种构造块及其相互关系所组成的复杂概念，不把它描绘出来将很难真正理解一个模式。 可视化的商业模式画布的好处视觉化的语法。为勾画商业模式所需要的信息提供了视觉和文字指导，因为它会告诉你把哪些信息放入商业模式的哪个部分。 抓住大局。通过描绘出商业模式画布上的所有元素，可以直观的展示出商业模式大局。 查看关系。商业画布可以清晰的表达出各个商业元素之间的关系。 收集参考点。可以把心理得假设贴出来变成明确的信息作为参考。 共同的语言。提供了词汇表和语法帮助人们更好的理解对方，提高凝聚力。 共同的埋解。不同部门员工缺乏对商业模式全貌的认识，商业画布能让所有人快速理解商业模式。 灵感触发器。商业画布中的创意会引发更多创意。 演示。帮助你彻底思考修改某个商业模式元素后所带来的系统性影响。 内/外部推销。把创意和计划清晰的让内/外部人员理解。 3.4 故事讲述讲故事的目的是要把商业模式以形象具体的呈现出来，可以从不同的视角塑造出不同的人物形象，比如下面两种视角： 公司视角,让员工成为故事的主人公，因为员工频繁地关注着客户的烦恼，而新的模式就可以解决这些烦恼。在这样的故事中，员工体现的是商业模式的内部运作机制、为推行新的模式提供了依据。 客户视角，客户道出困扰他的烦恼和他必须解决的问题。然后讲述你们公司是如何帮他创造价值的。在故事中，她描述了她得到了什么样的产品和服务，这些产品和服务是如何解决他的问题的，以及作为一个消费者，他所愿意掏钱的产品和服务是什么样的。 3.5 情景推测作用：通过细化设计环境，帮助我们熟悉商业模式的设计流程基于情景的商业模式设计。情景推测吧抽象的概念变成具体的模型。下面是两种情景推测： 客户情景推测，客户是如何使用产品和服务的，什么类型的客户在使用它们，客户的顾虑、愿望和目的分别是什么。这种建立在客户洞察之上的情景推测更进一步，把对客户的了解融入一组独特、具体的图像。通过描述特定的场景，关于客户的情景推测就能把客户洞察具体形象地表现出来。 未来情景推测，说白了就是臆测未来，假设未来会发生何种变化，然后针对每一种变化设计并检验商业模式。此方法以商业创新为目的，帮助公司更好的应对未来发展。 4 战略 4.1 商业模式环境商业模式是在特定的环境中进行设计和执行的。建议把商业环境大体上映像成四块主要领域范畴： 1市场影响因素市场问题。从客户和提供给客户的产品或服务的视角发现驱动和改变市场的关键因索。 市场细分。发现主要的细分市场，描述它们的吸引力，寻找新的细分市场。 需要和需求。罗列出市场需求，分析市场需求目前的服务水平。 转换成本。描述与客户投靠竟争对手行为相关的因素。 收益吸引力。寻找出与收益吸引力和定价能力相关的因素。 2行业影响因素竞争对手。发现当前竞争对手和它们的相对优势。 行业新入者。发现新的崛起的行业对手，判断它们是否利用不同于你的商业模式与你竟争。 替代性产品和服务。描述你公司的产品和服务潜在替代品，包括其他市场和行业的产品和服务。 供应商和其他价值链参与者。在你公司所在的市场中，描述出目前关键的价值链参与者，并发现新崛起的参与者。 利益相关者。确认哪些参与者可能会影响你的公司和商业模式。 3关键趋势技术趋势。发现能威胁、改变或改良你的公司的商业模式的技术趋势。 监管法规趋势。描述影响你的商业模式的法规及其变化趋势。 社会和文化趋势。发现可能会，影响你的商业摸式的主要社会趋势。 社会经济趋势。概括与你的商业模式相关的主要社会经济趋势。 4宏观经济影响力全球市场情况。从宏观的经济视角总结全球市场目前的整体状况。 资本市场。描绘出与你的资本需求密切相关的资本市场状况。 商品和其他资源。重点关注你的商业模式中所需资源的当前价格及其未来趋势。 经济基础。描绘你的业务运营环境中的经济基础。 4.2 评估商业模式如同每年做身体检查一样，定期评估商业模式是一种重要的管理工具，它可以评估出组织在行业内的“健康”程度，并适时地做出一些相应的调整。这种健康检查可以成为商业模式不断改进优化的基础。商业模式视角下的蓝海战略《蓝海战略》这本书可以看看。管理多个商业模式 商业评估工具SWOT(优势，劣势，威胁，机会) 4.3 蓝海战略蓝海战略：通过改变现有的商业模式来区分与竞争对手的模式，从而创造出新的行业 去除：那些被行业认为理所应当的存在应该被去除 降低：哪种因素应该被降低到标准之下 提升：哪种因素应该被提高到标准之上 创造：哪种行业中没有的因素应该被创造出来 5 流程5.1 创新四大目标商业模式创新的目标：满足市场，满足被忽视的市场需求。 投放市场，把新技术、产品和服务推向市场。 改善市场，通过更好的商业模式来改进、颠覆或变革现有的市场。 创造市场，建立全新的市场。 5.2 五大阶段动员为一个成功的商业模式设计项目做好准备工作。 活动：确定项目目标、测试初步商业想法、规划、组件设计团队。 关键：合适的队友、经验和知识。 风险：高估了初始想法的价值。 理解研究和分析商业模式所需要的元素。 活动：环境分析、研究潜在客户、采访行业专家、研究前人做法（失败案例）、收集想法。 关键：对潜在目标市场的深入理解、超越传统目标市场定义的界限。 风险：研究过度（研究和目标脱节）、收到预先想法的影响，研究结果不客观。 设计构建和测试可行的商业模式可选方案，并挑选最佳的方案。 活动：头脑风暴、原型制作、测试、选择。 关键：与不同部门的员工一起设计、透过现状看本质的能力、投入时间，探索多种商业模式。 风险：低估或打压大胆想法、过快的钟情于某个想法。 实施在实际环境中实施商业模式原型。 活动：交流和参与、执行。 关键：最佳项目管理、快速调整商业模式的能力和意愿、平衡好旧模式和新模式。 风险：积极性降低、减弱。 管理结合市场反馈来调整和修改商业模式。 活动：分析环境、持续的评估你的商业模式、换一个角度思考你的商业模式、调整商业模式，配合公司整体战略、处理模式间的协同效应和冲突问题。 关键：目光长远、积极主动、商业模式的管理。 风险：成为成功的牺牲品，满足于现状而未能及时作出调整。 最后贴一个脑图地址吧"},{"title":"weex","date":"2018-05-24T01:43:24.000Z","path":"2018/05/24/weex/","text":"0.安装0.1 安装nodejs这个不多说了不会的面壁吧。 0.2 安装weex-toolkit这个是个坑啊，官方给出的安装是 npm install weex-toolkit -g 不过这个安装可能会各种失败，失败之后再安装就无法安装了。即使再用淘宝镜像。那怎么办呢？首先我们需要卸载一下weex-toolkit npm uninstall weex-toolkit -g 其次我们需要去电脑中删除些文件还有这个也需要删除删除了这些，我们再安装，注意要用管理员运行cmd这次我们用淘宝镜像，没有cnpm自己安装下就可以了 cnpm install -g weex-toolkit 安装之后查看版本 npm uninstall weex-toolkit -g 出现版本号既可以了 0.3 安装java及配置0.4 安装git0.5 安装webpack0.6 安装android-studio安装android-studio这儿啦下一步下一步就好啦现在安装android-studio不带android-sdk，所以需要自己装之后还会安装一起android包，这时候需要翻墙，要访问谷歌这里强烈建议用国内镜像如图所示 大连东软信息学院镜像服务器地址:http://mirrors.neusoft.edu.cn 端口：80 接着点击close，关闭对话框，再重新启动SDK Manager就行啦。经过漫长的下载安装过程后，我们可以看到，之前选中安装的项目后面的状态都由之前的“Not installed”变为了如今的“Installed”，这就表示我们已经安装成功了！之后再配置android-sdk打开环境变量路径：控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量。新建：ANDROID_HOME 并把我们刚才赋值的sdk路径作为值插入添加path值，与配置java相同 ;%ANDROID_SDK_HOME%\\platform-tools; 保证系统能找到platform-tools下的adb.exe即可输入adb查看，出现下面情况即配置成功。接着刚才安装android-studio由于本机没有安装过Android Studio，因此这里也没有可导入的配置信息。点击OK。点击Setup Proxy。按上图设置代理。点击OK。点击Next。安装类型选择为”Custom”，并点击Next。将UI主题选择为Darcula(此风格看起来更加极客)。点击Next。选择之前安装Android Studio的路径，可以看到看下上图所述提示。点击Next。点击FinishAndroid SDK已经是最新。点击Finish。点击”Start a new Android Studio project”即可开始第一个Android程序的开发。 1.开启weex之旅吧1.1建立weex项目目录建立weex项目名称为helloWeex weex create helloWeex 建立时和vue一样，输入项目名称是否为helloWeex项目描述项目作者是否用eslint，一个js语法标准是否测试之后项目就建好了,目录结构如下添加Android应用支持 weex platform add android 如果你要支持IOS平台的话，你还要添加IOS应用，但是抱歉的是我没有苹果电脑，所以这里就不演示苹果的添加了。 1.2在Android Studio里运行weex"},{"title":"Swagger2","date":"2018-05-21T09:50:05.000Z","path":"2018/05/21/Swagger2/","text":"Swagger2主要解决接口文档，有了它妈妈再也不用担心接口太多不方便管理了，只需要在写代码时候简单加入些注解即可，方便简单。 0.安装pom文件直接在pom中用Maven下载jar包12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 1.创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.dataacquisition;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author colin * @version 1.0.0 * @date 17/10/24 下午12:02. */@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; ParameterBuilder parameterBuilder = new ParameterBuilder(); List&lt;Parameter&gt; parameters = new ArrayList&lt;Parameter&gt;(); parameterBuilder.name(\"Content-Type\") .description(\"header\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false).build(); parameters.add(parameterBuilder.build()); parameterBuilder.name(\"Accept\") .description(\"header\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false).build(); parameters.add(parameterBuilder.build()); //上面是设置header return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 选择那些路径和api会生成document .apis(RequestHandlerSelectors.basePackage(\"com.iss.rest\"))// 对所有api进行监控// .apis(RequestHandlerSelectors.any())// 对所有路径进行监控 .paths(PathSelectors.any()) .build() .globalOperationParameters(parameters) .apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"经济运行大数据API\") .description(\"经济大数据\") .termsOfServiceUrl(\"www.baidu.com\") .contact(\"colin\") .version(\"1.0\") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。看一下这个目录结构这里还要说明一下引包 PathSelectors import springfox.documentation.builders.PathSelectors; 1.添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容GET接口 对于传统参数为？的123456789101112131415161718192021222324252627@ApiOperation(value = \"上传Excel\", notes = \"上传Excel并存入数据库\", code = 200, produces = \"application/json\")@ApiImplicitParams(&#123;@ApiImplicitParam(name = \"userId\",value = \"用户ID\",required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"filepath\", value = \"上传文件路径地址用“/”\",paramType = \"query\", required = true, dataType = \"String\"), @ApiImplicitParam( name = \"type\", value = \"上传文件类型\", required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"productId\", value = \"上传文件productId\", required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"version\", value = \"上传文件版本\", required = false,paramType = \"query\", dataType = \"String\")&#125;)@RequestMapping(value = \"/uploadExcel\", method = RequestMethod.GET)public String uploadExcel(HttpServletRequest request) &#123; String filepath = WebUtils.findParameterValue(request, \"filepath\"); String productId = WebUtils.findParameterValue(request, \"productId\"); if(StringUtils.isBlank(filepath)||!new File(filepath).exists())&#123; return \"请输入正确文件路径\"; &#125; if(!configProductService.selectProductByProductId(productId))&#123; return \"productId不存在，请输入正确的productId\"; &#125; String userId = WebUtils.findParameterValue(request, \"userId\"); String type = WebUtils.findParameterValue(request, \"type\"); if(StringUtils.isBlank(type))&#123; return \"请输入上传Excel的种类（type=）\"; &#125; String version = WebUtils.findParameterValue(request, \"version\"); String result = uploadExcelService.uploadExcel(filepath,userId,type,version,productId); String result2 = uploadExcelService.upload(filepath); return result;&#125; GET接口 对于参数为/的123456789101112131415161718192021222324252627282930313233@ApiOperation(value = \"获取所有新闻\", notes = \"获取所有新闻\", code = 200, produces = \"application/json\") @ApiImplicitParams(&#123;@ApiImplicitParam(name = \"infoType\",value = \"行业动态等类别\",required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"type\", value = \"所属行业\",paramType = \"query\", required = true, dataType = \"String\"), &#125;) @RequestMapping(value = \"/queryAllNewsNew/&#123;infoType&#125;/&#123;type&#125;/&#123;startTime&#125;/&#123;endTime&#125;/&#123;region&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;\", method = RequestMethod.GET, produces = &#123;\"application/json\"&#125;, consumes = &#123;\"application/json\"&#125;) public Result queryAllNewsNew(@PathVariable(\"infoType\") String infoType, @PathVariable(\"type\") String type, @PathVariable(\"startTime\") String startTime, @PathVariable(\"endTime\") String endTime, @PathVariable(\"region\") String region, @PathVariable(\"pageNum\") String pageNum, @PathVariable(\"pageSize\") String pageSize) &#123; if (StringUtils.isBlank(pageNum)) &#123; pageNum = \"1\"; &#125; if (StringUtils.isBlank(pageSize)) &#123; pageSize = \"10\"; &#125; ResultEducationInfo resultEducationInfo = new ResultEducationInfo(); resultEducationInfo.setRegion(region); resultEducationInfo.setCityName(region); resultEducationInfo.setInfoType(infoType); resultEducationInfo.setCrawlType(type);// resultEducationInfo.setTime(time); resultEducationInfo.setStartTime(startTime); resultEducationInfo.setEndTime(endTime); resultEducationInfo.setPageNum(pageNum); resultEducationInfo.setPageSize(pageSize); Result result = jsonSearchService.queryAllNews(resultEducationInfo); return result; //Result.success(result); &#125; POST接口1234567891011@ApiOperation(value = \"解析Excel\", notes = \"解析Excel\", code = 200, produces = \"application/json\")@ApiImplicitParam(name = \"filepath\", value = \"上传文件路径地址用“/”\",paramType = \"query\", required = true, dataType = \"String\")@RequestMapping(value = \"/analysisExcel\", method = RequestMethod.POST)public Map analysisExcel(HttpServletRequest request) &#123; String filepath = WebUtils.findParameterValue(request, \"filepath\"); if(StringUtils.isBlank(filepath)||!new File(filepath).exists())&#123; return null; &#125; Map result = uploadExcelService.analysisExcel(filepath); return result;&#125; 结果如图所示"},{"title":"jQuery生成二维码","date":"2018-05-18T08:59:40.000Z","path":"2018/05/18/jQuery生成二维码/","text":"还是扫描二维码登录的需求，既然和二维码相关肯定需要实现二维码生成啦！ 0安装生成二维码的包不止一种，这里一个坑 qrcode 包，他也可以生成二维码，但是很难设置二维码大小，颜色等，强烈不建议安装这个。我已经掉坑里过。那么推荐使用jquery.qrcode。 npm install jquery.qrcode -s 这里前提是需要安装jquery并且在webpack中配好，先说一下代码，以后会详细说明123456plugins:[ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\" &#125;), ] 1使用之后引用jquery.qrcode1require('jquery.qrcode') 在之后在Html中定义div容器1&lt;div id=\"query\"&gt;&lt;/div&gt; 这里可以不用设置div大小，因为可以再js中设置二维码大小 再之后是js部分 1234567891011//动态生成二维码 $(\"#query\").qrcode(&#123; render: \"canvas\", // 渲染方式有table方式和canvas方式 width: 256, //默认宽度 height: 256, //默认高度 text: encodeURI(\"http://www.cnblogs.com/HtmlCss3/\"）, //二维码内容 typeNumber: -1, //计算模式一般默认为-1 correctLevel: 2, //二维码纠错级别 background: \"#ffffff\", //背景颜色 foreground: \"#000000\" //二维码颜色&#125;); 说明下encodeURI是为了防止中文乱码。应该不会怎么用上。至于如果想在二维码中间添加图片，目前不支持添加图片，不过我们可以自己把图片移到中间位置"},{"title":"websocket+Springboot","date":"2018-05-18T06:54:16.000Z","path":"2018/05/18/websocket/","text":"今天要做一个手机扫描登录，功能拆分，需要websocket推送信息到页面，不废话了直接开始吧。 0.导言0.1什么是websocket它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 0.2准备都需要什么准备呢？毫无疑问需要客户端（浏览器），服务端（后台），这里后台我们用的是Springboot。 1.后台Springboot1.1引包在pom中引用webpack包123456&lt;!-- 操作websoket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2注入ServerEndpointExporter使用springboot内置tomcat进行部署的话，在编写websocket具体实现类之前，要注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint。1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;/** * Created by linjiad on 2018/5/18. */@Configurationpublic class WebSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 1.3写自己的实现类直接先看代码吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import net.sf.ehcache.util.concurrent.ConcurrentHashMap;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.Map;/** * Created by linjiad on 2018/5/18. */@ServerEndpoint(value = \"/websocket\")@Componentpublic class MyWebSocket &#123; //统计在线人数 private static int onlineCount = 0; //用本地线程保存session private static ThreadLocal&lt;Session&gt; sessions = new ThreadLocal&lt;Session&gt;(); //保存所有连接上的session private static Map&lt;String, Session&gt; sessionMap = new ConcurrentHashMap&lt;String, Session&gt;(); public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; onlineCount--; &#125; //连接 @OnOpen public void onOpen(Session session) &#123; sessions.set(session); addOnlineCount(); sessionMap.put(session.getId(), session); System.out.println(\"【\" + session.getId() + \"】连接上服务器======当前在线人数【\" + getOnlineCount() + \"】\"); //连接上后给客户端一个消息 sendMsg(session, \"恭喜你连接服务器成功！\"+session.getId()); &#125; //关闭 @OnClose public void onClose(Session session) &#123; subOnlineCount(); sessionMap.remove(session.getId()); System.out.println(\"【\" + session.getId() + \"】退出了连接======当前在线人数【\" + getOnlineCount() + \"】\"); &#125; //接收消息 客户端发送过来的消息 @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(\"【\" + session.getId() + \"】客户端的发送消息======内容【\" + message + \"】\"); String[] split = message.split(\",\"); String sessionId = split[0]; Session ss = sessionMap.get(sessionId); if (ss != null) &#123; String msgTo = \"【\" + session.getId() + \"】发送给【您】的消息:\\n【\" + split[1] + \"】\"; String msgMe = \"【我】发送消息给【\"+ss.getId()+\"】:\\n\"+split[1]; sendMsg(ss, msgTo); sendMsg(session,msgMe); &#125;else &#123; for (Session s : sessionMap.values()) &#123; if (!s.getId().equals(session.getId())) &#123; sendMsg(s, \"【\" + session.getId() + \"】发送给【您】的广播消息:\\n【\" + message + \"】\"); &#125; else &#123; sendMsg(session,\"【我】发送广播消息给大家\\n\"+message); &#125; &#125; &#125; &#125; //异常 @OnError public void onError(Session session, Throwable throwable) &#123; System.out.println(\"发生异常!\"); throwable.printStackTrace(); &#125; //统一的发送消息方法 public synchronized void sendMsg(Session session, String msg) &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这段代码里面注释都很清晰了，不多说了，重点是在 onMessage 方法中。后端就这么多久搞定了，很简单，把后端项目跑起来等待前端信息就可以了 2.前端2.1 页面HTMLHTML就很简单了，一个div,一个输入框，一个按钮就搞定1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jspang webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = \"message\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"ceshi\"&gt; &lt;button id=\"a\"&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 别问我为啥没引用js，因为我用的是webpack这个之后再讲。 2.2 js实现这个地方我分成了两部分，用import形式引入websocket部分先看index.js123456import websocket_config from './js/websocket_config.js';let websocket = new websocket_config.Websocket();$(\"#a\").on('click', function() &#123; let message = document.getElementById('ceshi').value; websocket.send(message); &#125;) 这段代码就是点击按钮把’ceshi’信息传给后台另一个websocket_config，我是把websocket部分封装进来12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Websocket&#123; constructor(url=\"ws://localhost:11000/websocket\") &#123; let self = this; self.url=url; let websocket = null; //判断当前浏览器是否支持WebSocket if('WebSocket' in window)&#123; self.websocket = new WebSocket(this.url); &#125; else&#123; alert(\"您当前浏览器不支持websocket\") &#125; //连接发生错误的回调方法 self.websocket.onerror = function()&#123; self.setMessageInnerHTML(\"error\"); &#125;; //连接成功建立的回调方法 self.websocket.onopen = function(event)&#123; self.setMessageInnerHTML(\"open\"); &#125; //接收到消息的回调方法 self.websocket.onmessage = function(event)&#123; console.log(event); self.setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 self.websocket.onclose = function()&#123; self.setMessageInnerHTML(\"close\"); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; self.websocket.close(); &#125; &#125; setMessageInnerHTML(innerHTML) &#123; document.getElementById('message').innerHTML += innerHTML + '&lt;br/&gt;'; &#125; closeWebSocket()&#123; this.websocket.close(); &#125; //发送消息 send(message)&#123; this.websocket.send(message); &#125;&#125;export default &#123;Websocket&#125;; 敲黑板划重点，这里有个坑，就是Class里面的this，前面我们这么写的 let self = this; 否则后面function里面this指向自己的function 3 看看具体效果吧直接输入信息会广播出去给所有人，如图所示所有人都会看到信息因为在后台代码12345678910111213141516171819202122232425262728293031//接收消息 客户端发送过来的消息 @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(\"【\" + session.getId() + \"】客户端的发送消息======内容【\" + message + \"】\"); String[] split = message.split(\",\"); String sessionId = split[0]; Session ss = sessionMap.get(sessionId); if (ss != null) &#123; String msgTo = \"【\" + session.getId() + \"】发送给【您】的消息:\\n【\" + split[1] + \"】\"; String msgMe = \"【我】发送消息给【\"+ss.getId()+\"】:\\n\"+split[1]; sendMsg(ss, msgTo); sendMsg(session,msgMe); &#125;else &#123; for (Session s : sessionMap.values()) &#123; if (!s.getId().equals(session.getId())) &#123; sendMsg(s, \"【\" + session.getId() + \"】发送给【您】的广播消息:\\n【\" + message + \"】\"); &#125; else &#123; sendMsg(session,\"【我】发送广播消息给大家\\n\"+message); &#125; &#125; &#125; &#125; //统一的发送消息方法 public synchronized void sendMsg(Session session, String msg) &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 如果，前面没有id则会循环sessionMap发给所有人如果，前面有id则单独发给一个人 session.getBasicRemote().sendText(msg);谁获取了什么消息"},{"title":"css3-grid网格化布局","date":"2018-05-17T08:32:49.000Z","path":"2018/05/17/css3-grid网格化布局/","text":"1.第一个 Grid 布局CSS Grid 布局由两个核心组成部分是: wrapper（父元素）和 items（子元素）。下面是一个 wrapper 元素，内部包含6个 items ：HTML部分12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个 grid(网格)，只要简单地把其 display 属性设置为 grid 即可：123.wrapper &#123; display: grid;&#125; 仅仅是这样并没有什么用处结果如图所示： 2.Columns(列) 和 rows(行)为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用 grid-template-row 和 grid-template-column 属性。 12345.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; //设置三列（1-4条线） grid-template-rows: 50px 50px;//设置两行（1-3条线）&#125; 记住几条线是接下来需要用的这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）如果这样设置12345.wrapper &#123; display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;&#125; 结果就是这样注意这里评分宽度尽量用（可以自适应） grid-template-columns: repeat(6, 1fr); 页面宽度平均分成6份，每个占一份 3.放置 items(子元素)3.1行要定位和调整 items(子元素) 大小，我们将使用 grid-column 和 grid-row 属性来设置：1234.item1 &#123; grid-column-start: 1; grid-column-end: 4;&#125; 当然也可以这么写123.item1 &#123; grid-column: 1 / 4;&#125; item1 占据从第一条网格线开始，到第四条网格线结束换句话说，它将独立占据整行.结果如图所示：这是怎么回事呢？为啥是1,4呢，原因如图 3.2列同理。列也就不用多说了，直接看代码123456789101112.item1 &#123; grid-column-start: 1; grid-column-end: 3;&#125;.item3 &#123; grid-row-start: 2; grid-row-end: 4;&#125;.item4 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 结果如下：基本布局这些就够了 4.矩阵布局——grid-template-areas直接代码讲解吧123456789101112131415161718192021.item-1 &#123; grid-area: header;&#125;.item-2 &#123; grid-area: main;&#125;.item-3 &#123; grid-area: sidebar;&#125;.item-4 &#123; grid-area: footer;&#125; .wrapper &#123; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: &quot;header header header header&quot; &quot;main main . sidebar&quot; &quot;footer footer footer footer&quot;;&#125; 把每个div起一个别名： .item-a { grid-area: header;} 开始布局 grid-template-areas: “header header header header” “main main . sidebar” “footer footer footer footer”; 其中.代表空占位结果如图所示： 5指定网格线(grid lines)的大小属性这么设置1234.wrapper &#123; grid-column-gap: &lt;line-size&gt;; grid-row-gap: &lt;line-size&gt;;&#125; 具体事例123456.container &#123; grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-column-gap: 10px; grid-row-gap: 15px;&#125; 6 每个网格中的格式6.1整体设置 -justify-items123.container &#123; align-items: start | end | center | stretch;&#125; start：将内容对齐到网格区域(grid area)的顶部end：将内容对齐到网格区域的底部center：将内容对齐到网格区域的中间（垂直居中）stretch：填满网格区域高度（默认值）示例：123.container &#123; align-items: start;&#125; 示例：123.container &#123; align-items: end;&#125; 示例：123.container &#123; align-items: center;&#125; 示例：123.container &#123; align-items: stretch;&#125; 6.2单个设置 -justify-self规则和上面一样，这里就不多说了示例：123.item-a &#123; justify-self: start;&#125; 示例：123.item-a &#123; justify-self: end;&#125; 示例：123.item-a &#123; justify-self: center;&#125; 示例：123.item-a &#123; justify-self: stretch;&#125; 7.非自适应布局对齐方式7.1沿—X轴线有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像px这样的非灵活单位设置大小，在这种情况下，您可以设置网格容器内的网格的对齐方式start：将网格对齐到 网格容器(grid container) 的左边end：将网格对齐到 网格容器 的右边center：将网格对齐到 网格容器 的中间（水平居中）stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间space-evenly：在每个栅格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间示例：123.container &#123; justify-content: start;&#125; 123.container &#123; justify-content: end;&#125; 123.container &#123; justify-content: center;&#125; 123.container &#123; justify-content: stretch;&#125; 123.container &#123; justify-content: space-around;&#125; 123.container &#123; justify-content: space-between;&#125; 123.container &#123; justify-content: space-evenly;&#125; 7.2沿—Y轴线和x轴基本一样示例：123.container &#123; align-content: start;&#125; 123.container &#123; align-content: end;&#125; 123.container &#123; align-content: center;&#125; 123.container &#123; align-content: stretch;&#125; 123.container &#123; align-content: space-around;&#125; 123.container &#123; align-content: space-between;&#125; 123.container &#123; align-content: space-evenly;&#125; 总结常用的基本就这些了如果需要了解更多，这儿啦"},{"title":"echarts-字符云","date":"2018-05-17T02:31:25.000Z","path":"2018/05/17/echarts-字符云/","text":"首先要说下，从echarts2.0之后，字符云就被分离出来，需要独自安装 1.安装1.1安装其他安装不说了，单独说下需要安装echarts和echarts-wordcloud npm install echarts-wordcloud -s 1.2引用在总的js中123let echarts = require(&apos;echarts&apos;);window.echarts=echarts;require(&apos;echarts-wordcloud&apos;); 2.使用heml部分代码就不强调了，直接写js部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let colorlist = [&quot;#4ad2ff &quot;, &quot;#36ffb1&quot;, &quot;#23ff4f&quot;, &quot;#3dff27&quot;, &quot;#7aff1a&quot;, &quot;#bdff1c&quot;, &quot;#e2ff15&quot;, &quot;#fdff52&quot;]; let myChart = echarts.init(document.getElementById(&quot;portrait&quot;)); let option = &#123; tooltip: &#123;&#125;, series: [&#123; type: &apos;wordCloud&apos;, gridSize: 10, //sizeRange: [22, 50], //rotationRange: [0, 0], //shape: &apos;circle&apos;, textStyle: &#123; normal: &#123; color: function() &#123; return colorlist[parseInt(10*Math.random())]; &#125; &#125;, /*emphasis: &#123; shadowBlur: 10, shadowColor: &apos;#333&apos; &#125;*/ &#125;, data: [&#123; name: &apos;企业&apos;, value: 10000, &#125;, &#123; name: &apos;公务员&apos;, value: 6181 &#125;, &#123; name: &apos;2018&apos;, value: 4386 &#125;, &#123; name: &apos;上下游&apos;, value: 4055 &#125;, &#123; name: &apos;公司&apos;, value: 2467 &#125;, &#123; name: &apos;项目&apos;, value: 2244 &#125;, &#123; name: &apos;十二月份&apos;, value: 1898 &#125;, &#123; name: &apos;一批&apos;, value: 1484 &#125;, &#123; name: &apos;大连&apos;, value: 1112 &#125;, &#123; name: &apos;北京&apos;, value: 965 &#125;, &#123; name: &apos;全国&apos;, value: 847 &#125;, &#123; name: &apos;采购&apos;, value: 582 &#125;, &#123; name: &apos;考试&apos;, value: 555 &#125;, &#123; name: &apos;示范&apos;, value: 550 &#125;,] &#125;] &#125;; myChart.setOption(option) 一个简单的字符云就出来了，更多功能以后待更新"},{"title":"css3-文字特效和背景透明","date":"2018-05-16T02:18:35.000Z","path":"2018/05/16/css3-文字特效和背景透明/","text":"直接上图，需要用CSS3实现这样的效果 1.html部分html这里需要一个 标签包含 之后每组字都是自己的 之所以是div是需要给每组字限定大小。1234567891011&lt;ul&gt; &lt;li class = &quot;li_title&quot;&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;区域占有率&lt;/div&gt;&lt;div&gt;主营产品&lt;/div&gt;&lt;div&gt;来源&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; 2.CSS部分2.1 li背景这里的li分为两部分，标题部分和其他行，这里如果用less的话就非常方便，less以后会在less专题中说，这里还是用css1234567.li_title&#123; margin-left: -50px; //内边距向左50 height: 30px; //每行高30px list-style-type : none; //去掉li前面的· background-color: rgb(46,154,254,0.6); //设置背景颜色，并且透明度为0.6 border-radius:10px; //拐角度为10px&#125; 后面的行无非就是改个颜色12345678.li_list&#123; margin-left: -50px; height: 30px; margin-top: 15px; list-style-type : none; background-color: rgb(28,28,28,0.6); border-radius:10px;&#125; 2.2 文字特效这里的特效就是多余的文字变成…直接代码讲解吧12345678910ul div&#123; color : #FFFFFF; //文字颜色白色 font-size : 18px; //字体大小18px float:left; //文字靠左浮动 margin-left: 8%; //左边距为8%，也就是每个字之间的间距 width:110px; //规定div大小，也就是文字框大小（主要） white-space:nowrap; //规定文字不能换行（主要） overflow:hidden; //规定多余的文字隐藏（主要） text-overflow:ellipsis; //规定文字超出的话···（主要）&#125; 这些之后图片的效果就回显现 3.左侧按钮特效直接上图，需要用CSS3实现这样的效果要实现这个效果首先要在左面定义一个 3.1左侧div_html123456789&lt;div class = &quot;menu&quot;&gt; &lt;ul&gt; &lt;li value = &quot;reaches&quot;&gt;行业上下游&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;xiehui&quot;&gt;协会理事会&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;gongxu&quot;&gt;供需平台&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;shejiao&quot;&gt;社交平台&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;qita&quot;&gt;其他&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 3.2.左侧CSS样式首先是menu的样式123456.menu&#123; width: 13%; //定义宽度 height: 736px; //定义高度 float:left; //浮动到左侧 transform:skew(0deg,20deg); //敲黑板划重点，倾斜，两个参数，这里是沿着x轴向下倾斜20度&#125; 之后设定ul样式，这个样式没有什么好说的12345.menu ul &#123; float:left; margin-top: 25%; margin-left: -20%;&#125; 再之后设置li样式，划重点1234567891011121314.menu li &#123; width: 100%; //li宽度 height: 100px; //高度 margin-top: 5%; //内置上边距 color : #FFFFFF; //颜色（字体） font-size : 20px; //字体大小 border:1px solid #ffffff; //边界线粗细为1px。边界线颜色为白色 list-style-type : none; //不显示· float:left; //左浮动 display: flex; //（划重点）用flex布局，这样设置里面字居中 align-items:center; // 上下居中 justify-content: center;// 左右居中 cursor: pointer; //鼠标经过变成手指&#125; 未被选择的li需要一个透明的背景色，如同前面一样，直接上代码123.menu_select&#123; background-color: rgb(110,110,110,0.3);&#125; 3.3实现点击切换效果js循环ul的children，如果和点击的li相同则删除menu_select样式，否则添加menu_select样式123456789101112$(&quot;.menu li&quot;).on(&apos;click&apos;, function() &#123; for (let child of $(&quot;.menu ul&quot;).children()) &#123; if(child.innerHTML != this.innerHTML)&#123; $(child).addClass(&quot;menu_select&quot;); $(&quot;#&quot;+child.attributes.value.value).hide() &#125; else&#123; $(child).removeClass(&quot;menu_select&quot;); $(&quot;#&quot;+child.attributes.value.value).show() &#125; &#125; &#125;)"},{"title":"echarts_地图","date":"2018-05-16T01:43:31.000Z","path":"2018/05/16/echarts-地图/","text":"echarts构建数据可视化 1.安装1.1 安装nodejs构建webpack项目，需要安装nodejs，告别传统直接1&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 标签引用，nodejs安装和webpack构建这里先不说了，以后专门写webpack时候再说。nodejs前面也说过安装就不多说了。 1.2 安装echarts直接使用命令1npm install echarts -s 这里说明一下，有个坑，echarts地图显示存在版本冲突，所以可以@你的版本号避免这种冲突。 1.3 引用echarts在webpack构建的项目里，在index.js或者main.js，即页面直接引用的js引用echarts12let echarts = require('echarts');window.echarts=echarts; 这里说明一下，也可以用import，这两个区别在以后的nodejs中回去讲解。 2.地图实现2.1 html部分首先在html中需要有放地图的位置，并且有自己的id，这里必须给该 大小，否则echarts显示不出来12&lt;div id = &quot;map&quot; style=&quot;width:600px;height:500px;&quot;&gt;&lt;/div&gt; 2.2 js部分首先把地图对应的json传给echarts1echarts.registerMap(city, resultJson); 之后获取div1let myChart = echarts.init(document.getElementById(&quot;map&quot;)); 之后setoption12345678910111213141516171819202122232425262728293031323334353637383940414243myChart.setOption(&#123; tooltip: &#123;//配置鼠标方式显示提示样式 trigger: &apos;item&apos;, formatter: &apos;&#123;b&#125;:&#123;c&#125;&apos; &#125;, series : [&#123; type: &apos;map&apos;, //设置地图样式，未选中板块的样式和选中板块的样式 itemStyle: &#123; normal: &#123; areaColor: &quot;#00BFFF&quot;, borderWidth: 1, borderColor: &apos;#fff&apos;, color: &apos;#00BFFF&apos;, label: &#123; show: true &#125; &#125;, emphasis: &#123; // 也是选中样式 borderWidth: 1, areaColor: &quot;#58FA82&quot;, borderColor: &apos;#fff&apos;, color: &apos;#32cd32&apos;, label: &#123; show: true, textStyle: &#123; color: &apos;#fff&apos; &#125; &#125; &#125; &#125;, map: city,//要和echarts.registerMap（）中第一个参数一致 label: &#123; normal: &#123; show: true &#125;, emphasis: &#123; show: true &#125; &#125;, data : [&#123;name:&apos;广东&apos;, selected:true , value:100&#125;] &#125;] &#125;) 3.效果 未完，以后关于在地图上添加各种标记也会写在这篇文章中"},{"title":"nodeppt(三)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt3/","text":"6.装逼利器文字强调6.1 加粗加粗 6.2 字体闪烁em这时按下 H em会闪烁 6.3 放大增加了zoom.js的支持，在演示过程中使用alt+鼠标点击，则点击的地方就开始放大，再次alt+click则回复原状 6.4 使用note笔记用[note][/note]标签包含笔记文字 [note]这里是note笔记使用n键，才能显示[/note] 按下键盘【N】键打开[note]之中内容，否则不显示 7.图片处理7.1 引入图片1![小萝莉](nodeppt3/girl.jpg \"小萝莉\") 和1&lt;img src=\"/girl.jpg\"&gt; 都可以引入图片并且点击图片可放大 7.1 图片禁止放大只需要加个样式即可1&lt;img src=\"/girl.jpg\" class=\"no-screenfull\"&gt; 8.nodeppt的函数和事件8.1 单个slide事件[slide] 中使用data-on-X来指定一个全局函数名123build：当触发下一步操作的时会触发，event具有stop方法keypress：在当前页面按键触发，event具有stop方法enter/leave：进入/离开 此页面触发的事件，event无stop方法 8.2 回调123456[slide data-on-leave=\"fnName\"]进入执行回调incallback函数[slide data-on-enter=\"fnName\"]退出执行outcallback函数亦可以组合写：[slide data-on-leave=\"foo\" data-on-enter=\"bar\"] 8.3 远程执行函数开玩笑远程现在还不好用呢等以后在更新吧 9.后记了解更多内容请点击源代码下载PPT实例请点击，摘自源代码 10 补充10.1 启动项目 先下建立一个.md文件，nodeppt会找是否有.md文件 然后再启动命令启动10.2 手机控制目前手机控制还不算完美，只是翻页控制的还行。 先把本地的防火墙关闭 查看计算机的ip 启动项目 nodeppt start -p 8080 -d D:\\MyJob\\nodeppt -H 192.168.1.8 10.3 导出静态页面使用命令 nodeppt generate D:\\MyJob\\nodeppt\\demo.md D:\\ppt -a 打开连接选远程控制 确保手机能连上电脑的情况下用手机扫码（用手机自带的，别用微信）"},{"title":"nodeppt(二)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt2/","text":"4.nodeppt书写nodeppt只要是符合markdown语法即可，也支持HTML混编 4.2 总的配置title: 这是title，网页名称speaker: 演讲者名称url:transition: 全局转场动效files: 引入的js和css文件，多个以半角逗号隔开theme: 皮肤样式highlightStyle: 代码高亮样式，默认monokai_sublimeusemathjax: yes 启用MathJax渲染公式 4.2 每一页间隔[slide]nodeppt用[slide]来区分每一页PPT [slide]第一页[slide]第二页[slide] 4.3 样式基于GFM的markdown语法编写 {:&amp;.rollIn} 需要改变样式的话后面直接加{:&amp;.flexbox.vleft}(该样式为居左) 4.4 背景图片完全style写法，更加灵活，视频背景、repeat背景更不在话下 [slide style=”background-image:url(‘/img/bg1.png’)”] 4.5 上下分界线 四个”-“是上下分界线 4.6 表格 Less Sass Stylus 环境 js/nodejs Ruby(这列右对齐) nodejs(高亮) {:.highlight} 扩展名 .less .scss/.sass .styl 特点 老牌，用户多，支持js解析 功能全，有成型框架，发展快 语法多样，小众 案例/框架 Bootstrap Compass Bootstrap Foundation Bourbon Base.Sass 123456| Less | Sass | Stylus:-------|:------:|-------:|--------环境 |js/nodejs | Ruby(这列右对齐) | nodejs(高亮) &#123;:.highlight&#125;扩展名 | .less | .scss/.sass | .styl特点 | 老牌，用户多，支持js解析 | 功能全，有成型框架，发展快 | 语法多样，小众案例/框架 | [Bootstrap](http://getbootstrap.com/) | [Compass](http://beta.compass-style.org) [Bootstrap](http://getbootstrap.com/css/#sass) [Foundation](http://foundation.zurb.com/) [Bourbon](http://bourbon.io) [Base.Sass](https://github.com/jsw0528/base.sass) | 4.7 text文字样式如图所示：展示如图效果12345678910&lt;span class=\"text-danger\"&gt;.text-danger&lt;/span&gt; &lt;span class=\"text-success\"&gt;.text-success&lt;/span&gt;&lt;span class=\"text-primary\"&gt;.text-primary&lt;/span&gt;&lt;span class=\"text-warning\"&gt;.text-warning&lt;/span&gt;&lt;span class=\"text-info\"&gt;.text-info&lt;/span&gt;&lt;span class=\"text-white\"&gt;.text-white&lt;/span&gt;&lt;span class=\"text-dark\"&gt;.text-dark&lt;/span&gt;&lt;span class=\"blue\"&gt;.blue&lt;/span&gt;&lt;span class=\"blue2\"&gt;.blue2&lt;/span&gt;&lt;span class=\"blue3\"&gt;.blue3&lt;/span&gt;&lt;span class=\"gray\"&gt;.gray&lt;/span&gt;&lt;span class=\"gray2\"&gt;.gray2&lt;/span&gt;&lt;span class=\"gray3\"&gt;.gray3&lt;/span&gt;&lt;span class=\"red\"&gt;.red&lt;/span&gt;&lt;span class=\"red2\"&gt;.red2&lt;/span&gt;&lt;span class=\"red3\"&gt;.red3&lt;/span&gt;&lt;span class=\"yellow\"&gt;.yellow&lt;/span&gt;&lt;span class=\"yellow2\"&gt;.yellow2&lt;/span&gt;&lt;span class=\"yellow3\"&gt;.yellow3&lt;/span&gt;&lt;span class=\"green\"&gt;.green&lt;/span&gt;&lt;span class=\"green2\"&gt;.green2&lt;/span&gt;&lt;span class=\"green3\"&gt;.green3&lt;/span&gt; 4.8 label如图所示：展示如图效果12345&lt;span class=\"label label-primary\"&gt;.label.label-primary&lt;/span&gt;&lt;span class=\"label label-warning\"&gt;.label.label-warning&lt;/span&gt;&lt;span class=\"label label-danger\"&gt;.label.label-danger&lt;/span&gt;&lt;span class=\"label label-default\"&gt;.label.label-default&lt;/span&gt;&lt;span class=\"label label-success\"&gt;.label.label-success&lt;/span&gt;&lt;span class=\"label label-info\"&gt;.label.label-info&lt;/span&gt;&lt;a href=\"#\"&gt;link style&lt;/a&gt; &lt;mark&gt;mark&lt;/mark&gt; 4.9 blockquoteblockquote ：如图所示：12nodeppt可能是迄今为止最好用的web presentation &lt;small&gt;三水清&lt;/small&gt;这是一个class是：pull-right的blockquote &lt;small&gt;small一下&lt;/small&gt; &#123;:&amp;.pull-right&#125; 4.10 buttons如图所示：123456&lt;button class=\"btn btn-default\"&gt;.btn .btn-default&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;.btn.btn-lg.btn-primary&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;.btn.btn-waring&lt;/button&gt; &lt;button class=\"btn btn-success\"&gt;.btn.btn-success&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;.btn.btn-danger&lt;/button&gt;&lt;button class=\"btn btn-lg btn-default\"&gt;.btn.btn-lg.btn-default&lt;/button&gt; &lt;button class=\"btn btn-xs btn-success\"&gt;.btn.btn-xs.btn-success&lt;/button&gt; &lt;button class=\"btn btn-sm btn-primary\"&gt;.btn.btn-sm.btn-primary&lt;/button&gt; &lt;button class=\"btn btn-rounded btn-warning\"&gt;.btn.btn-rounded.btn-waring&lt;/button&gt; &lt;button class=\"btn btn-danger\" disabled=\"disabled\"&gt;disabled.btn.btn-danger&lt;/button&gt;&lt;button class=\"btn btn-success\"&gt;&lt;i class=\"fa fa-share mr5\"&gt;&lt;/i&gt;&lt;/button&gt; 4.11 icons如图所示：1234567891011&lt;i class=\"fa fa-apple\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-android\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-github\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-google\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-linux\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-css3\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-html5\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-usd\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-pie-chart\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-file-video-o\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-cog\"&gt;&lt;/i&gt; 4.12 代码格式化使用 highlightjs 进行语法高亮如图所示：1234567891011121314151617181920212223242526&lt;div class=\"columns-2\"&gt; &lt;pre&gt;&lt;code class=\"javascript\"&gt;(function(window, document)&#123; var a = 1; var test = function()&#123; var b = 1; alert(b); &#125;; //泛数组转换为数组 function toArray(arrayLike) &#123; return [].slice.call(arrayLike); &#125;&#125;(window, document)); &lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=\"javascript\"&gt;(function(window, document)&#123; var a = 1; var test = function()&#123; var b = 1; alert(b); &#125;; //泛数组转换为数组 function toArray(arrayLike) &#123; return [].slice.call(arrayLike); &#125;&#125;(window, document)); &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; 4.13 语法混编使用 highlightjs 进行语法高亮如图所示：12345678910111213141516171819&lt;div class=\"file-setting\"&gt; &lt;p&gt;这是html&lt;/p&gt;&lt;/div&gt;&lt;p id=\"css-demo\"&gt;这是css样式&lt;/p&gt;&lt;p&gt;将html代码直接混编到**markdown**文件中即可&lt;/p&gt;我是js控制的颜色 black &#123;:#testScriptTag&#125;&lt;script&gt; function testScriptTag()&#123; document.getElementById('testScriptTag').style.color = 'black'; &#125;&lt;/script&gt;&lt;style&gt;#css-demo&#123; color: red;&#125;&lt;/style&gt; 4.14 iframe如图所示：1&lt;iframe data-src=\"http://www.baidu.com\" src=\"about:blank;\"&gt;&lt;/iframe&gt; 4.15 链接标签链接到百度1[链接到百度](https://www.baidu.com) 5.效果设置5.1 多种皮肤修改url可以改变皮肤如图所示：也可以通过代码点击实现1234567&lt;div class=\"columns6\"&gt; &lt;a href=\"?theme=color\" &gt;color&lt;/a&gt; &lt;a href=\"?theme=blue\"&gt;blue&lt;/a&gt; &lt;a href=\"?theme=dark\"&gt;dark&lt;/a&gt; &lt;a href=\"?theme=green\"&gt;green&lt;/a&gt; &lt;a href=\"?theme=light\"&gt;light&lt;/a&gt;&lt;/div&gt; 5.1 单页面转场设置[magic]中data-transition属性设置转场效果[magic][/magic]中间用========隔开两个div1234567891011121314[magic data-transition=\"earthquake\"]&lt;div class=\"columns3\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt;&lt;/div&gt;========&lt;div class=\"columns4\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt;&lt;/div&gt;[/magic] 5.2 相同页面转场设置 列表支持渐显动效哦 {:&amp;.动效类型} markdown列表第一条加上：{:&amp;.动效类型} markdown列表第一条加上： markdown列表第一条加上： 动效类型 fadeIn淡出淡入 {:&amp;.动效类型} rollIn从后向前放大 bounceIn弹出并震动 moveIn zoomIn从后向前放大 5.3 全局设置前面说过在PPT开头 transition: glue 5.4 页面之间设置在每个页面可以设置自己的转场效果 [slide data-transition=”zoomin”] 5.5 转场url设置在url后加上?transition=newspaper如图所示 slide/slide2/slide3newspapergluekontext/vkontextmove/circlehorizontal/horizontal3dvertical3dzoomin/zoomoutcardsearthquake/pulse/stick 这些转场效果慢慢试吧"},{"title":"个人微博——hexo(二)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/hexo2/","text":"4.配置_config.yml4.1 _config.yml常用结构说明直接上我的配置吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Site 网站# 网站标题 title: linjiad_个人博客#网站副标题subtitle: 柳外轻雷池上雨，雨声滴碎荷声#网站描述description: 这个人很懒什么也没写keywords:#您的名字author: linjiad#网站使用的语言language: JS#网站时区。timezone:# URL 网址#网址url: http://linjiad.github.io#网站根目录root: /#文章的 永久链接 格式 :year/:month/:day/:title/permalink: :year/:month/:day/:title/#永久链接中各部分的默认值 permalink_defaults: # Directory 目录# 资源文件夹，这个文件夹用来存放内容。 source_dir: source# 公共文件夹，这个文件夹用于存放生成的站点文件。public_dir: public# 标签文件夹tag_dir: tags# 归档文件夹archive_dir: archives# 分类文件夹category_dir: categories# Include code 文件夹code_dir: downloads/code# 国际化（i18n）文件夹i18n_dir: :lang# 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径skip_render:# Writing 文章# 新文章的文件名称new_post_name: :title.md # File name of new posts#预设布局，以后就在source下的_post下查看文章default_layout: post#把标题转换为 title casetitlecase: false # Transform title into titlecase#在新标签中打开链接external_link: true # Open external links in new tab#把文件名称转换为 (1) 小写或 (2) 大写 filename_case: 0#显示草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: true#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting分页index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tag 分类 &amp; 标签、# 默认分类default_category: uncategorized#分类别名 category_map:#标签别名tag_map: # Date / Time format 日期 / 时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/#日期格式date_format: YYYY-MM-DD#时间格式time_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable pagination#每页显示的文章量 (0 = 关闭分页功能)per_page: 10#分页目录pagination_dir: page# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#当前主题名称。值为false时禁用主题theme: miho# Deployment## Docs: https://hexo.io/docs/deployment.html#部署部分的设置deploy: type: git repo: https://账号:密码@github.com/你的名字/你的名字.github.io.git branch: master 5.主题themes5.1下载themes主题可以在这里找都是免费的哦！看好的主题可以再github中搜索名字，比如我的主题是，miho可以直接搜索点击进入后可以下载成.zip文件，之后再把文件解压到themes下 5.2配置themes之后再设置_config.yml中theme theme: miho 6.图片处理6.1下载图片处理包下载图片处理包 npm install hexo-asset-image –save 6.2配置_config.yml把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true post_asset_folder: true 6.3创建markdown文档再运行hexo new” xxxx” 生成md文件时source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 6.4放置和调用图片在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：1![你想输入的替代文字](xxxx/图片名.jpg) 7.MIHO主题7.1MIHO配置说明在该主题下会有一个_congig.yml文件，该文件是主题的配置文件_congig.yml配置就不一一说明可以参看README.md或者看这里 7.2MIHO列表图片踩坑这里面还有个大坑，就是列表图片总找不到，原因是路径不对坑在这里改成这个样子123456&lt;% if (post.cover_picture) &#123; %&gt; &lt;img src=\"&lt;%- (/^(http:|https:)?\\/\\//.test(post.cover_picture) ? post.cover_picture :config.url.replace(/\\/$/, '') + '/' + post.cover_picture )%&gt;\" alt=\"&lt;%- post.title %&gt;\" title=\"&lt;%- post.title %&gt;\"&gt; &lt;% &#125; else &#123; %&gt; &lt;img src=\"&lt;%- (/^(http:|https:)?\\/\\//.test(theme.cover_picture) ? theme.cover_picture : config.url.replace(/\\/$/, '') + '/' + theme.cover_picture ) %&gt;\" alt=\"&lt;%- post.title %&gt;\" title=\"&lt;%- post.title %&gt;\"&gt; &lt;% &#125; %&gt; 之后在引用图片的时候需要加日期12345678---title: date: 2018-05-11 09:48:26tags: categories: author: cover_picture: 2018/05/11/hexo2/menu.png--- 图片日期需要和date保持一致 8.尾声常用命令12345678910hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo generate 生成静态文件。hexo deploy 部署网站hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式hexo new page \"about\" 创建新的连接目录hexo new '文章名' 创建新的文件 更多需求可查询hexo官网更多miho主题可查询miho该项目地址放在这儿啦"},{"title":"个人微博——hexo(一)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/hexo1/","text":"用hexo和github搭建个人 免费 博客免费 对我我这种穷人来说显得弥足珍贵 0.导言0.1 个人微博技术个人微博技术有很对，4-12日尤大神发布了VuePress，大神本来想写文档，结果码出了一套框架（容我做一个悲伤的表情），大神就是大神。不过新框架还在不断完善，存在太多坑，这里就先不说VuePress，以后框架完善后再说。这里就聊一聊老牌的微博框架hexo 0.2 hexohexo是一个框架，简洁明朗，基于node，一键部署，并且支持MarkDown，现在微博基本上内容都是用MarkDown来写，而且还有很多 免费 框架哦！之前想写一个微博，用nodejs后台，前端用vue来写，还得弄服务器什么的，超级麻烦。后来学了下hexo，真的超级轻量！(我的废话真多)。 1.安装1.1 安装nodejshexo是基于nodejs，需要nodejs，还不会可以面壁了 1.2 安装hexohexo需要安装全局变量 npm install hexo-cli -g 1.3 安装git去这里https://git-scm.com/downloads毫无压力的进行安装吧 2.快速在本地开始2.1 开始命令 hexo i blog //init的缩写 blog是项目名 hexo初始化hexo cd blog //切换到站点根目录 切换到该目录下，或者直接在该目录下打开控制台 hexo g //generetor的缩写 在此之前可以先clean下，然后生成项目 hexo s //server的缩写 启动本地服务器 2.2 查看成果 打开浏览器输入localhost:4000查看： 2.3 目录结构在初始化的目录下会看到该目录结构一个崭新的博客页面出现在面前123456789node_modules：是依赖包public：存放的是生成的页面;clean会删除;generetor会生成scaffolds：命令生成文章等的模板source：用命令创建的各种文章，以后都在这里写自己的文章themes：主题；存放自己喜欢的主题并使用_config.yml：整个博客的配置db.json：source解析所得到的(我也不大清楚)package.json：项目所需模块项目的配置信息package-lock.json：nodejs升级后存储更细节的包版本，以后写nodejs会详细说明 2.4 安装hexo-server这里需要踩个坑，exo 3.0把服务器独立成个别模块，需要单独安装： npm i hexo-server 3.配置github3.1 在github上创建项目没有账号的自己注册创建新的项目创建项目，输入地址名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用！并且以后yourname.github.io就是你的博客地址，之后点击2创建 3.2 配置github私钥个人觉得这个配置后只能在该电脑使用，像我一样在公司台式机的朋友梦用其他电脑配置会哭的，这里就先不用私钥的办法，后面会说一个更好的方法。 3.2 安装deployer安装deployer后才能美美哒配置发布到网上 npm install hexo-deployer-git –save 之后需要在_config.yml末尾处加入一段代码1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 重点说明一下repo:1https://+用户名:密码+@+github.com/+ 1+.git 这里可以接刚才说的更好的方法 3.2 发布博客这时候小伙伴可以愉快的发布了建议执行命令按顺序执行123hexo cleanhexo generatehexo deploy 3.4 查看博客在浏览器中输入https://刚才的名字.github.io/进行访问"},{"title":"nodeppt(一)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt1/","text":"是时候放弃微软的PPT,改用一款够装X够D的利器，nodeppt 0.导言0.1 nodeppt好处基于markdown编写,支持HTML混编对于程序员来说更方便 1.开始1.1 安装前准备不多说了，既然是nodeppt，顾名思义需要安装node，去官网下载即可,好无悬念下一步下一步，安装成功后再控制台查看版本，出现版本号即为安装成功。 1.2 安装nodepptnodeppt需要全局安装 npm install -g nodeppt 同样安装之后查看版本号 nodeppt -v 效果如图这样nodeppt就安装成功，安装成功后可以在控制台打开任意位置的markdown文件，开始表演真正的技术啦！Show Time！ 2.nodeppt命令2.1 获取帮助通过命令获取帮助，查看更多命令 nodeppt start -h 2.2 启动nodeppt-p为端口号-d为路径 nodeppt start -p -d path/for/ppts 例如： nodeppt start -p 8080 -d E:\\私人办公\\ppts 2.3 启动成功启动成功后弹出页面如图所示点击即可弹出页面 3.nodeppt基本操作3.0 页面菜单如图所示，在该位置分别有按钮上一页，下一页，画笔，浏览模式。可分别点击进行操作 3.1 翻页可以按 空格 ，向右 进行下一页/下一步。向左 上一步/上一页 3.2 画笔按 P 打开画笔 ，再次按 P 清空画板 ，按 C 清空画板并关闭画笔画板打开期间可以用 1-4 来选择画笔粗细， B Y G等颜色首字母选择颜色 3.3 表格放大在展示表格的页面按 w 使表格放大 3.4 浏览模式按 O 打开浏览模式，如图所示：，可以浏览选择需要的PPT页面 3.5 多窗口演示可以电脑分屏，自己看一个窗口，分享另一个窗口，这样演讲起来可以预先组织语言。 网址改成url?_multiscreen=1, 这里有个坑，这时候可能多窗口无法使用，请看浏览器右上角收藏旁边，点开，点允许即可。 3.6 打开note笔记按下键盘【N】打开note笔记 3.7 手机控制目前还没成功"}]
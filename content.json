[{"title":"ionic-03","date":"2019-04-09T07:57:49.000Z","path":"2019/04/09/ionic-03/","text":"9 上拉下拉9.1 上拉scroll首先写一个列表再写一个下拉的画面 threshold 距离底部多少处罚方法 (ionInfinite) 监听方法 loadingSpinner 下拉的图标 loadingText 下拉的文字1234567891011&lt;ion-list&gt; &lt;ion-item *ngFor=\"let item of data\"&gt; &#123;&#123;item&#125;&#125; &lt;/ion-item&gt; &lt;/ion-list&gt; &lt;ion-infinite-scroll threshold=\"100px\" (ionInfinite)=\"loadData($event)\"&gt; &lt;ion-infinite-scroll-content loadingSpinner=\"bubbles\" loadingText=\"Loading more data...\"&gt; &lt;/ion-infinite-scroll-content&gt; &lt;/ion-infinite-scroll&gt; 引入下拉组件1import &#123; IonInfiniteScroll &#125; from '@ionic/angular'; 初始化数据123456public data: any[] = []; constructor() &#123; for (const i = 0; i &lt; 20; i ++) &#123; this.data.push(`这是第$&#123;i&#125;条数据`); &#125; &#125; 下拉事件123456789loadData(event) &#123; setTimeout(() =&gt; &#123; for (const i = 0 ; i &lt; 10; i ++) &#123; this.data.push(`这是第$&#123;i&#125;条数据`); &#125; console.log('Done'); event.target.complete(); &#125;, 500); &#125; 这里有BUG，第一次可以下拉，第二次不行 所以必须调用event.target.complete();所以在html中需要这样调(ionInfinite)=&quot;loadData($event)&quot; 9.2 关闭上拉event.target.disabled = true; 1. 下拉到极限关闭下拉需要在下拉事件中添加判断12345678910111213loadData(event) &#123; setTimeout(() =&gt; &#123; for (const i = 0 ; i &lt; 10; i ++) &#123; this.data.push(`这是第$&#123;i&#125;条数据`); &#125; console.log('Done'); event.target.complete(); // 当大于1000条时关闭下拉 if (this.data.length === 1000) &#123; event.target.disabled = true; &#125; &#125;, 500); &#125; 2. 按钮关闭下拉首先我们定义一个按钮 1&lt;ion-button (click)=\"toggleInfiniteScroll()\"&gt;关闭下拉&lt;/ion-button&gt; 为了获取到下拉，我们需要下拉的id123456&lt;ion-infinite-scroll #myInfiniteScroll threshold=\"100px\" (ionInfinite)=\"loadData($event)\"&gt; &lt;ion-infinite-scroll-content loadingSpinner=\"bubbles\" loadingText=\"Loading more data...\"&gt; &lt;/ion-infinite-scroll-content&gt; &lt;/ion-infinite-scroll&gt; 在js中引入获取id的包,并且通过id获取dom12import &#123; Component , ViewChild &#125; from '@angular/core';@ViewChild('myInfiniteScroll') infiniteScroll: IonInfiniteScroll; 写点击事件1234// 关闭就打开，打开就关闭toggleInfiniteScroll() &#123; this.infiniteScroll.disabled = !this.infiniteScroll.disabled; &#125; 9.3 请求后台数据1. 首先在app.module.ts 中引入并加载数据请求模块12345678910111213import &#123;HttpClientModule&#125; from '@angular/common/http';@NgModule(&#123; declarations: [AppComponent], // 声明组件 entryComponents: [], // 配置不会再模板中使用的组件 imports: [BrowserModule, IonicModule.forRoot(), AppRoutingModule, HttpClientModule], // 配置项目所需要的模块 providers: [ // 配置项目所需要的服务 StatusBar, SplashScreen, &#123; provide: RouteReuseStrategy, useClass: IonicRouteStrategy &#125; ], bootstrap: [AppComponent] // 项目启动的组件&#125;) 2. 创建一个请求服务 ionic g service services/httpservice 3. 在服务中引用并注入 123456789import &#123; Injectable &#125; from '@angular/core';import &#123;HttpClient&#125; from '@angular/common/http';@Injectable(&#123; providedIn: 'root'&#125;)export class HttpserviceService &#123; constructor(public http: HttpClient) &#123; &#125;&#125; 4. 封装get方法 123456789get(api) &#123; return new Promise((resovel, err) =&gt; &#123; this.http.get(api).subscribe((response) =&gt; &#123; resovel(response); &#125;, (error) =&gt; &#123; err(error); &#125;); &#125;); &#125; 5. 在根模块中注入服务 在app.module.ts 中引入并加载数刚才创建的服务 1234567891011121314import &#123;HttpserviceService&#125; from './services/httpservice.service';@NgModule(&#123; declarations: [AppComponent], // 声明组件 entryComponents: [], // 配置不会再模板中使用的组件 imports: [BrowserModule, IonicModule.forRoot(), AppRoutingModule, HttpClientModule], // 配置项目所需要的模块 providers: [ // 配置项目所需要的服务 StatusBar, SplashScreen, HttpserviceService, &#123; provide: RouteReuseStrategy, useClass: IonicRouteStrategy &#125; ], bootstrap: [AppComponent] // 项目启动的组件&#125;) 6. 应用在需要的地方引入服务并注入之后写一个请求方法如下：12345678910111213141516171819202122import &#123; Component, OnInit &#125; from '@angular/core';import &#123;HttpserviceService&#125; from '../services/httpservice.service';@Component(&#123; selector: 'app-tab4', templateUrl: './tab4.page.html', styleUrls: ['./tab4.page.scss'],&#125;)export class Tab4Page implements OnInit &#123; constructor(public httpserviceService: HttpserviceService) &#123; &#125; ngOnInit() &#123; this.getData(); &#125; getData() &#123; const api = 'http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=1'; this.httpserviceService.get(api).then((response) =&gt; &#123; console.log(response); &#125;); &#125;&#125; 9.4 上拉请求更多1234567891011121314&lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-item *ngFor=\"let item of list\"&gt; &#123;&#123;item.title&#125;&#125; &lt;/ion-item&gt; &lt;/ion-list&gt; &lt;p *ngIf=\"hasmore\"&gt;---------我也是有底线的---------&lt;/p&gt; &lt;ion-infinite-scroll threshold=\"10%\" (ionInfinite)=\"loadData($event)\"&gt; &lt;ion-infinite-scroll-content loadingSpinner=\"bubbles\" loadingText=\"Loading more data...\"&gt; &lt;/ion-infinite-scroll-content&gt; &lt;/ion-infinite-scroll&gt;&lt;/ion-content&gt; js逻辑123456789101112131415161718192021222324252627282930313233343536import &#123; Component, OnInit, NgZone &#125; from '@angular/core'; // 这里还需要引入强制刷新import &#123;HttpserviceService&#125; from '../services/httpservice.service';@Component(&#123; selector: 'app-tab4', templateUrl: './tab4.page.html', styleUrls: ['./tab4.page.scss'],&#125;)export class Tab4Page implements OnInit &#123; public list: any[] = []; // 展现列表 public page: any = 1; // 页面计数 public hasmore: any = true; // 底部提示 constructor(public httpserviceService: HttpserviceService) &#123; this.getData(); // 初始化的时候就请求数据 &#125; ngOnInit() &#123;&#125; getData(event= false) &#123; // 判断是下拉的还是初始化的 const api = 'http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&amp;page=' + this.page;// 动态页码参数 this.httpserviceService.get(api).then((response: any) =&gt; &#123; this.ngZone.run(() =&gt; &#123; // 强制刷新页面 this.list = [...this.list, ...response.result]; // 拼接数据 this.page ++; // 页面+1 (event) ? event.target.complete() : event = false; // 判断是下拉的请求还是初始化的请求，如果是下拉则关闭下拉 // 判断下一页是否有数据 if (response.result.length &lt; 20) &#123; event.target.disabled = true; // 禁止再拉了 this.hasmore = false; // 让底部的提示显示 &#125; &#125;) &#125;); &#125; loadData(event) &#123; // 下拉触发方法 this.getData(event); &#125;&#125; 9.5 下拉 ionRefresh 触发的方法 pullingText 下拉时候提示文字 pullingIcon 下来时候提示图标 refreshingText 下拉中的文字（手指放开后） refreshingSpinner 下拉中的图标（手指放开后）12345678&lt;ion-refresher slot=\"fixed\" (ionRefresh)=\"doRefresh($event)\" text=\"客官别急\"&gt; &lt;ion-refresher-content pullingIcon=\"arrow-dropdown\" pullingText=\"Pull to refresh\" refreshingSpinner=\"circles\" refreshingText=\"Refreshing...\" &gt;&lt;/ion-refresher-content&gt; &lt;/ion-refresher&gt; 下拉方法123456789101112doRefresh(event) &#123; setTimeout(() =&gt; &#123; setTimeout(() =&gt; &#123; for (let i = 10; i &lt; 20; i++) &#123; this.list.unshift(&#123; title: i, &#125;); &#125; &#125;) event.target.complete(); // 与上拉相同都需要关闭 &#125;, 2000); &#125; 10 路由跳转10.1 普通路由跳转匹配的是路由中的path1234567&lt;ion-button [routerLink]=\"['/pinfo']\"&gt; 跳转到详情&lt;/ion-button&gt;&lt;ion-button color=\"primary\" routerLink=\"/button\"&gt; 跳转到按钮页面&lt;/ion-button&gt; 10.2 跳转传值123&lt;ion-button color=\"primary\" routerLink=\"/button\" [queryParams]=\"&#123;cid:cid ,aid:'1234'&#125;\"&gt; 跳转到按钮页面&lt;/ion-button&gt; 在跳转页面中接收值 123456789101112131415161718import &#123; Component, OnInit &#125; from '@angular/core';import &#123; ActivatedRoute &#125; from '@angular/router'; // 引入对应模块@Component(&#123; selector: 'app-button', templateUrl: './button.page.html', styleUrls: ['./button.page.scss'],&#125;)export class ButtonPage implements OnInit &#123; constructor(public route:ActivatedRoute) &#123; &#125; ngOnInit() &#123; this.route.queryParams.subscribe((data) =&gt; &#123; // 获取传过来的值 console.log(data); &#125;); &#125;&#125; 10.3 返回上一页正常情况下返回上一页没有问题 123&lt;ion-buttons slot=\"start\"&gt; &lt;ion-back-button defaultHref=\"/tabs/tab1\" text=\"返回\"&gt;&lt;/ion-back-button&gt;&lt;/ion-buttons&gt; 如果在tab2中用这个的话会出现BUG返回会返回到tab1在这时候我们需要用到NavController来返回上一页 12345&lt;ion-buttons slot=\"start\"&gt; &lt;ion-button (click)=\"goBack()\"&gt; &lt;ion-icon slot=\"icon-only\" name=\"arrow-back\"&gt;&lt;/ion-icon&gt; &lt;/ion-button&gt;&lt;/ion-buttons&gt; 12345goBack() &#123; // tthis.nav.back(); 返回历史记录的上一页 this.nav.navigateBack('/tabs/tab2'); // 跳转到指定页面 // this.nav.navigateRoot('/tabs/tab2'); 直接回到根 &#125;"},{"title":"ionic-02","date":"2019-04-02T03:15:09.000Z","path":"2019/04/02/ionic-02/","text":"4 轮播,搜索,切换4.1 轮播图Ionic4.x 中的轮播图组件是基于 swiper 插件，所以配置 slides 的属性需要在 swiper 的 api 中找 Swiper Api：http://idangero.us/swiper/api/ 123456789101112131415161718192021import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-slide', templateUrl: './slide.component.html', styleUrls: ['./slide.component.scss'],&#125;)export class SlideComponent implements OnInit &#123; slideOpts = &#123; effect: 'flip', speed: 400, loop: true, autoplay: &#123; delay: 2000 &#125; &#125;; constructor() &#123; &#125; ngOnInit() &#123;&#125;&#125; 如果是内容则如下：1234567891011&lt;ion-slides pager=\"true\" [options]=\"slideOpts\"&gt; &lt;ion-slide&gt; &lt;h1&gt;Slide 1&lt;/h1&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;h1&gt;Slide 2&lt;/h1&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;h1&gt;Slide 3&lt;/h1&gt; &lt;/ion-slide&gt;&lt;/ion-slides&gt; 如果是图片如下1234567891011&lt;ion-slides pager=\"true\" [options]=\"slideOpts\"&gt; &lt;ion-slide&gt; &lt;img src=\"/assets/03.png\"&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;img src=\"/assets/02.png\"&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;img src=\"/assets/01.png\"&gt; &lt;/ion-slide&gt;&lt;/ion-slides&gt; 轮播属性： 12345678slideOpts = &#123; effect: 'flip', // 轮播效果 speed: 400, loop: true, // 循环轮播 autoplay: &#123; // 自动轮播 delay: 2000 // 延迟2秒 &#125; &#125;; 轮播图高级获取 slide 对象之第一步，定义名称1234567891011121314&lt;ion-slides pager=\"true\" [options]=\"slideOpts\" #slide1 (ionSlideTouchEnd)=\"ionSlideTouchEnd()\"&gt; &lt;ion-slide&gt; &lt;img src=\"/assets/03.png\"&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;img src=\"/assets/02.png\"&gt; &lt;/ion-slide&gt; &lt;ion-slide&gt; &lt;img src=\"/assets/01.png\"&gt; &lt;/ion-slide&gt;&lt;/ion-slides&gt;&lt;ion-button (click)=\"slideNext()\"&gt;点击按钮切换到下一页&lt;/ion-button&gt;&lt;ion-button (click)=\"slidePrev()\"&gt;点击按钮切换到上一页&lt;/ion-button&gt; 引入 ViewChild 获取 slide 对象123456789101112131415161718192021222324252627282930313233343536import &#123; Component, OnInit, ViewChild &#125; from '@angular/core';@Component(&#123; selector: 'app-slide', templateUrl: './slide.component.html', styleUrls: ['./slide.component.scss'],&#125;)export class SlideComponent implements OnInit &#123; @ViewChild('slide1') slide; slideOpts = &#123; effect: 'flip', // 轮播效果 speed: 400, loop: true, // 循环轮播 autoplay: &#123; // 自动轮播 delay: 2000 // 延迟2秒 &#125; &#125;; slideNext() &#123; this.slide.slideNext(); // 触发方法轮播到下一页 &#125; slidePrev() &#123; this.slide.slidePrev(); // 触发方法轮播到上一页 &#125; slideUpdate() &#123; this.slide.slideUpdate(); // 请求时局完成后更新轮播图 &#125; ionSlideTouchEnd() &#123; this.slide.startAutoplay(); // 解决手动轮播后不自动轮播 &#125; constructor() &#123; &#125; ngOnInit() &#123;&#125;&#125; 4.2 搜索ion-searchbar placeholder: 默认内容animated：添加动画效果type：指定输出的类型debounce: 防抖动，就是延迟方法ionChange: 值改变后触发的方法1&lt;ion-searchbar placeholder=\"请输入搜索内容\" animated type=\"number\" debounce=\"500\" (ionChange)=\"doChange()\"&gt;&lt;/ion-searchbar&gt; 4.3 Tab切换ion-segment1. 第一种获取值得方法1234567891011&lt;ion-segment (ionChange)=\"segmentChanged($event)\"&gt; &lt;ion-segment-button value=\"首页\"&gt; &lt;ion-label&gt;首页&lt;/ion-label&gt; &lt;/ion-segment-button&gt; &lt;ion-segment-button value=\"详情\"&gt; &lt;ion-label&gt;详情&lt;/ion-label&gt; &lt;/ion-segment-button&gt; &lt;ion-segment-button value=\"评论\"&gt; &lt;ion-label&gt;评论&lt;/ion-label&gt; &lt;/ion-segment-button&gt;&lt;/ion-segment&gt; 123segmentChanged(ev: any) &#123; console.log('Segment changed', ev.detail.value); &#125; 2. 第二种获取值得方法 12345678910111213&lt;ion-segment [(ngModel)]=\"tab\"&gt; &lt;ion-segment-button value=\"tab1\"&gt; &lt;ion-label&gt;首页&lt;/ion-label&gt; &lt;/ion-segment-button&gt; &lt;ion-segment-button value=\"tab2\"&gt; &lt;ion-label&gt;详情&lt;/ion-label&gt; &lt;/ion-segment-button&gt; &lt;ion-segment-button value=\"tab3\"&gt; &lt;ion-label&gt;评论&lt;/ion-label&gt; &lt;/ion-segment-button&gt;&lt;/ion-segment&gt;&#123;&#123;tab&#125;&#125; 这个模块需要引入如下： 1234567import &#123; FormsModule, ReactiveFormsModule &#125; from '@angular/forms';@NgModule(&#123; imports: [ FormsModule, ReactiveFormsModule ],&#125;) 定义初始的tab1public tab = 'tab1'; 3. 切换tab 利用ngSwitch实现tab切换 注意value中双引号还要有单引号 12345678910111213141516171819202122&lt;ion-segment [(ngModel)]=\"tab\"&gt; &lt;ion-segment-button value=\"tab1\"&gt; &lt;ion-label&gt;首页&lt;/ion-label&gt; &lt;/ion-segment-button&gt; &lt;ion-segment-button value=\"tab2\"&gt; &lt;ion-label&gt;详情&lt;/ion-label&gt; &lt;/ion-segment-button&gt; &lt;ion-segment-button value=\"tab3\"&gt; &lt;ion-label&gt;评论&lt;/ion-label&gt; &lt;/ion-segment-button&gt;&lt;/ion-segment&gt;&lt;div class=\"info\" [ngSwitch]=\"tab\"&gt; &lt;div *ngSwitchCase=\"'tab1'\"&gt; 首页 &lt;/div&gt; &lt;div *ngSwitchCase=\"'tab2'\"&gt; 详情 &lt;/div&gt; &lt;div *ngSwitchCase=\"'tab3'\"&gt; 评论 &lt;/div&gt;&lt;/div&gt; 5 日期5.1 基本用法display-format: 表示时间的展示形式（2019-06-01）picker-format：表示选择时间显示那些，这里显示年月日YYYY显示（2019）YY显示（19）min：起始时间max：结束时间1234&lt;ion-item&gt; &lt;ion-label&gt;Date&lt;/ion-label&gt; &lt;ion-datetime display-format=\"YYYY-MM-DD\" picker-format=\"YYYY MM DD\" min=\"1989-06-04\" max=\"2004-08-23\"&gt;&lt;/ion-datetime&gt;&lt;/ion-item&gt; 5.2 数据绑定前提还是在模块中引入ngModle模块，同上12345&lt;ion-item&gt; &lt;ion-label&gt;Date&lt;/ion-label&gt; &lt;ion-datetime display-format=\"YYYY-MM-DD\" picker-format=\"YYYY MM DD\" [(ngModel)]=\"day\"&gt;&lt;/ion-datetime&gt;&lt;/ion-item&gt;&#123;&#123;day&#125;&#125; 12// 这里的格式必须是YYYY-MM-DD相同的模式day = '2019-03-21'; 5.3 显示当前日期首先安装时间格式化包 npm install silly-datetime 引入该模块格式化时间 1234import sd from 'silly-datetime';constructor() &#123; this.day = sd.format(new Date(), 'YYYY-MM-DD'); &#125; 5.4 监听事件1. 通过变量获取时间12345&lt;ion-item&gt; &lt;ion-label&gt;Date&lt;/ion-label&gt; &lt;ion-datetime display-format=\"YYYY-MM-DD\" picker-format=\"YYYY MM DD\" [(ngModel)]=\"day\" (ionChange)=\"changeTime()\"&gt;&lt;/ion-datetime&gt;&lt;/ion-item&gt; 12345678910111213141516171819import &#123; Component, OnInit, ViewChild &#125; from '@angular/core';import sd from 'silly-datetime';@Component(&#123; selector: 'app-slide', templateUrl: './slide.component.html', styleUrls: ['./slide.component.scss'],&#125;)export class SlideComponent implements OnInit &#123; day = '2019-03-21'; changeTime() &#123; console.log(sd.format(this.day, 'YYYY-MM-DD')); &#125; constructor() &#123; this.day = sd.format(new Date(), 'YYYY-MM-DD'); &#125; ngOnInit() &#123;&#125;&#125; 2. 通过event获取时间 12345&lt;ion-item&gt; &lt;ion-label&gt;Date&lt;/ion-label&gt; &lt;ion-datetime display-format=\"YYYY-MM-DD\" picker-format=\"YYYY MM DD\" [(ngModel)]=\"day\" (ionChange)=\"changeTime($event)\"&gt;&lt;/ion-datetime&gt;&lt;/ion-item&gt; 12345678910111213141516171819import &#123; Component, OnInit, ViewChild &#125; from '@angular/core';import sd from 'silly-datetime';@Component(&#123; selector: 'app-slide', templateUrl: './slide.component.html', styleUrls: ['./slide.component.scss'],&#125;)export class SlideComponent implements OnInit &#123; day = '2019-03-21'; changeTime(e) &#123; console.log(sd.format(e.detail.value, 'YYYY-MM-DD')); &#125; constructor() &#123; this.day = sd.format(new Date(), 'YYYY-MM-DD'); &#125; ngOnInit() &#123;&#125;&#125; 5.4 日期组件的 Options可以修改弹出的点击按钮文字，及监听事件 1234&lt;ion-item&gt; &lt;ion-label&gt;Date&lt;/ion-label&gt; &lt;ion-datetime display-format=\"YYYY-MM-DD\" [pickerOptions]=\"customPickerOptions\" &gt;&lt;/ion-datetime&gt;&lt;/ion-item&gt; 1234567891011121314public customPickerOptions = &#123; buttons: [&#123; text: '取消', handler: () =&gt; &#123; console.log('Clicked Log. Do not Dismiss.'); return false; &#125; &#125;, &#123; text: '保存', handler: (e) =&gt; &#123; this.day = e.year.text + '-' + e.month.text + '-' + e.day.text; return true; &#125; &#125;] &#125;; return false 表示弹窗不会关闭 如果修改这个属性，上面监听方法都会失效，需要自己在handler中再写监听方法 6 侧边栏6.1 创建侧边栏项目创建一个侧边栏的项目 ionic start myApp3 sidemenu side: 按钮的位置menuId：侧边栏唯一标识type：侧边栏弹出方式swipe-gesture： 滑动弹出侧边栏 12345678910111213141516&lt;ion-menu side=\"start\" menuId=\"first\"&gt; &lt;ion-header&gt; &lt;ion-toolbar color=\"primary\"&gt; &lt;ion-title&gt;Start Menu&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;/ion-list&gt; &lt;/ion-content&gt; &lt;/ion-menu&gt; ion-menu-toggle 点击列表时菜单消失 123456789&lt;ion-list&gt; &lt;ion-menu-toggle&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;/ion-menu-toggle&gt;&lt;/ion-list&gt; 6.2 按钮控制左右菜单在Home中添加菜单按钮1234567891011&lt;ion-toolbar&gt; &lt;ion-buttons slot=\"start\"&gt; &lt;ion-menu-button menu=\"start1\"&gt;&lt;/ion-menu-button&gt; &lt;/ion-buttons&gt; &lt;ion-buttons slot=\"end\"&gt; &lt;ion-menu-button menu=\"end1\"&gt;&lt;/ion-menu-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt; Home &lt;/ion-title&gt;&lt;/ion-toolbar&gt; 其中menu属性是控制哪个菜单的id 在主页配置菜单 1234567891011121314151617181920212223242526272829303132 &lt;ion-menu side=\"start\" menuId=\"start1\"&gt; &lt;ion-header&gt; &lt;ion-toolbar color=\"primary\"&gt; &lt;ion-title&gt;Start Menu&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-menu-toggle&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;/ion-menu-toggle&gt; &lt;/ion-list&gt; &lt;/ion-content&gt;&lt;/ion-menu&gt;&lt;ion-menu side=\"end\" menuId=\"end1\"&gt; &lt;ion-header&gt; &lt;ion-toolbar color=\"success\"&gt; &lt;ion-title&gt;End Menu&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-menu-toggle&gt; &lt;ion-item&gt;Menu Item&lt;/ion-item&gt; &lt;/ion-menu-toggle&gt; &lt;/ion-list&gt; &lt;/ion-content&gt;&lt;/ion-menu&gt; 这样两个按钮就分别控制两个菜单 6.3 JS控制菜单接上面代码，在需要控制菜单的页面导入模块 1234567891011121314151617import &#123; Component &#125; from '@angular/core';import &#123; MenuController &#125; from '@ionic/angular';@Component(&#123; selector: 'app-home', templateUrl: 'home.page.html', styleUrls: ['home.page.scss'],&#125;)export class HomePage &#123; constructor(private menu: MenuController) &#123; &#125; doOPenMenu() &#123; this.menu.open('start1'); &#125; doOPenMenu2() &#123; this.menu.open('end1'); &#125;&#125; 123456789101112131415161718&lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-buttons slot=\"start\"&gt; &lt;ion-menu-button menu=\"start1\"&gt;&lt;/ion-menu-button&gt; &lt;/ion-buttons&gt; &lt;ion-buttons slot=\"end\"&gt; &lt;ion-menu-button menu=\"end1\"&gt;&lt;/ion-menu-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt; Home &lt;/ion-title&gt; &lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;ion-content&gt; &lt;ion-button color=\"primary\" (click)=\"doOPenMenu()\"&gt;打开左侧菜单&lt;/ion-button&gt; &lt;ion-button color=\"primary\" (click)=\"doOPenMenu2()\"&gt;打开右侧菜单&lt;/ion-button&gt;&lt;/ion-content&gt; 6.4 在Tabs中使用侧边栏在app.component.html中添加侧面菜单 123456789101112131415161718192021222324252627282930313233343536373839&lt;ion-app&gt; &lt;ion-menu side=\"start\" menuId=\"start1\"&gt; &lt;ion-header&gt; &lt;ion-toolbar color=\"primary\"&gt; &lt;ion-title&gt;用户信息&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-menu-toggle&gt; &lt;ion-item [routerDirection]=\"root\" [routerLink]=\"['/button']\"&gt; button &lt;ion-icon slot=\"start\" name=\"home\"&gt;&lt;/ion-icon&gt; &lt;/ion-item&gt; &lt;ion-item [routerLink]=\"['/news']\"&gt; news &lt;ion-icon slot=\"start\" name=\"home\"&gt;&lt;/ion-icon&gt; &lt;/ion-item&gt; &lt;/ion-menu-toggle&gt; &lt;/ion-list&gt; &lt;/ion-content&gt; &lt;/ion-menu&gt; &lt;ion-menu side=\"end\" menuId=\"end1\"&gt; &lt;ion-header&gt; &lt;ion-toolbar color=\"primary\"&gt; &lt;ion-title&gt;用户信息2&lt;/ion-title&gt; &lt;/ion-toolbar&gt; &lt;/ion-header&gt; &lt;ion-content&gt; &lt;ion-list&gt; &lt;ion-menu-toggle&gt; &lt;ion-item&gt;我的商品&lt;/ion-item&gt; &lt;ion-item&gt;我的商品&lt;/ion-item&gt; &lt;/ion-menu-toggle&gt; &lt;/ion-list&gt; &lt;/ion-content&gt; &lt;/ion-menu&gt; &lt;ion-router-outlet main&gt;&lt;/ion-router-outlet&gt;&lt;/ion-app&gt; 这里一定要加main在tab1中添加header按钮12345678910111213141516171819&lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-buttons slot=\"start\"&gt; &lt;ion-menu-button menu=\"start1\"&gt;&lt;/ion-menu-button&gt; &lt;/ion-buttons&gt; &lt;ion-buttons slot=\"end\"&gt; &lt;ion-menu-button menu=\"end1\"&gt;&lt;/ion-menu-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt; Home &lt;/ion-title&gt; &lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;ion-content&gt; &lt;ion-button color=\"primary\" routerLink=\"/button\"&gt;跳转到按钮页面&lt;/ion-button&gt; &lt;ion-button color=\"primary\" routerLink=\"/news\"&gt;跳转到news页面&lt;/ion-button&gt; &lt;ion-button color=\"primary\" routerLink=\"/product\"&gt;跳转到product页面&lt;/ion-button&gt;&lt;/ion-content&gt; [routerDirection]=”root” 加上这个是在第二层先改变页面 7 Ionic高级7.1 底部弹出action-sheethttps://ionicframework.com/docs/api/action-sheet 在html中写一个按钮 123&lt;ion-content&gt;&lt;ion-button (click)=\"presentActionSheet()\"&gt;弹出&lt;/ion-button&gt;&lt;/ion-content&gt; 在js中首先引入ActionSheetController 1import &#123; ActionSheetController &#125; from '@ionic/angular'; 其次依赖注入1constructor(public actionSheetController: ActionSheetController) &#123; &#125; 再写弹出事件12345678910111213141516171819202122232425262728293031323334353637383940async presentActionSheet() &#123; const actionSheet = await this.actionSheetController.create(&#123; header: 'Albums', // 标题 mode: 'ios', // 模拟平台 buttons: [&#123; // 按钮们 text: 'Delete', // 文本内容 role: 'destructive', // 角色 （这个是删除角色，在iphon中显示红色） icon: 'trash', // 图标 handler: () =&gt; &#123; // 点击触发的方法 console.log('Delete clicked'); &#125; &#125;, &#123; text: 'Share', icon: 'share', handler: () =&gt; &#123; console.log('Share clicked'); &#125; &#125;, &#123; text: 'Play (open modal)', icon: 'arrow-dropright-circle', handler: () =&gt; &#123; console.log('Play clicked'); &#125; &#125;, &#123; text: 'Favorite', icon: 'heart', handler: () =&gt; &#123; console.log('Favorite clicked'); &#125; &#125;, &#123; text: 'Cancel', icon: 'close', role: 'cancel', // 这个是取消角色，显示隔行 handler: () =&gt; &#123; console.log('Cancel clicked'); &#125; &#125;] &#125;); await actionSheet.present(); &#125; 7.2 弹出黑框toast在html中写一个按钮12&lt;ion-button (click)=\"presentToast()\"&gt;弹出1&lt;/ion-button&gt;&lt;ion-button (click)=\"presentToastWithOptions()\"&gt;弹出2&lt;/ion-button&gt; 在js中首先引入ToastController 1import &#123; ToastController &#125; from '@ionic/angular'; 其次依赖注入1constructor(public toastController: ToastController) &#123; &#125; 再写弹出事件123456789101112131415161718async presentToast() &#123; const toast = await this.toastController.create(&#123; message: 'Your settings have been saved.', // 弹出信息 duration: 2000 ,// 2秒后自动关闭 color: 'warning', // 弹出颜色 cssClass: 'mytoast', // 样式名称（必须写在全局globa.sass） &#125;); toast.present(); // 调用 &#125; async presentToastWithOptions() &#123; const toast = await this.toastController.create(&#123; message: 'Click to Close', showCloseButton: true, // 显示关闭按钮 position: 'top', // 弹出位置 closeButtonText: 'Done' // 按钮text &#125;); toast.present(); &#125; 7.3 等待loading在html中写一个按钮12&lt;ion-button (click)=\"presentLoading()\"&gt;loading&lt;/ion-button&gt;&lt;ion-button (click)=\"presentLoadingWithOptions()\"&gt;loading2&lt;/ion-button&gt; 在js中首先引入LoadingController 1import &#123; LoadingController &#125; from '@ionic/angular'; 其次依赖注入1constructor(public loadingController: LoadingController,) &#123; &#125; 再写弹出事件1234567891011121314151617181920212223async presentLoading() &#123; const loading = await this.loadingController.create(&#123; message: 'Hellooo', // 提示信息 duration: 2000 // 2秒后关闭 &#125;); await loading.present(); // 执行弹出 const &#123; role, data &#125; = await loading.onDidDismiss(); console.log('Loading dismissed!'); &#125; async presentLoadingWithOptions() &#123; const loading = await this.loadingController.create(&#123; spinner: null, // 图标（这里是不显示转圈圈） duration: 5000, message: 'Please wait...', showBackdrop: false, // 是否开启遮罩层 translucent: false, // 指示器半透明效果 cssClass: 'custom-class custom-loading' // 自定义样式（写在全局同上） &#125;); return await loading.present(); &#125; 7.4 弹出alert在html中写一个按钮123456&lt;ion-button (click)=\"presentAlert()\"&gt;Show Alert&lt;/ion-button&gt;&lt;ion-button (click)=\"presentAlertMultipleButtons()\"&gt;Show Alert (multiple buttons)&lt;/ion-button&gt;&lt;ion-button (click)=\"presentAlertConfirm()\"&gt;Show Alert (confirm)&lt;/ion-button&gt;&lt;ion-button (click)=\"presentAlertPrompt()\"&gt;Show Alert (prompt)&lt;/ion-button&gt;&lt;ion-button (click)=\"presentAlertRadio()\"&gt;Show Alert (radio)&lt;/ion-button&gt;&lt;ion-button (click)=\"presentAlertCheckbox()\"&gt;Show Alert (checkbox)&lt;/ion-button&gt; 在js中首先引入AlertController 1import &#123; AlertController &#125; from '@ionic/angular'; 其次依赖注入1constructor(public alertController: AlertController,) &#123; &#125; 再写弹出事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241// 这就是一个确认按钮没有啥用 async presentAlert() &#123; const alert = await this.alertController.create(&#123; header: 'Alert', subHeader: 'Subtitle', message: 'This is an alert message.', buttons: ['OK'] &#125;); await alert.present(); &#125;// 这就是几个按钮没有啥用async presentAlertMultipleButtons() &#123; const alert = await this.alertController.create(&#123; header: 'Alert', subHeader: 'Subtitle', message: 'This is an alert message.', buttons: ['Cancel', 'Open Modal', 'Delete'] &#125;); await alert.present();&#125;// 可以判断点击了那个按钮async presentAlertConfirm() &#123; const alert = await this.alertController.create(&#123; header: 'Confirm!', message: 'Message &lt;strong&gt;text&lt;/strong&gt;!!!', buttons: [ &#123; text: 'Cancel', role: 'cancel', cssClass: 'secondary', handler: (blah) =&gt; &#123; console.log('Confirm Cancel: blah'); &#125; &#125;, &#123; text: 'Okay', handler: () =&gt; &#123; console.log('Confirm Okay'); &#125; &#125; ] &#125;); await alert.present();&#125;// 可以获取弹出表单的数据async presentAlertPrompt() &#123; const alert = await this.alertController.create(&#123; header: 'Prompt!', inputs: [ &#123; name: 'name1', type: 'text', placeholder: 'Placeholder 1' &#125;, &#123; name: 'name2', type: 'text', id: 'name2-id', value: 'hello', placeholder: 'Placeholder 2' &#125;, &#123; name: 'name3', value: 'http://ionicframework.com', type: 'url', placeholder: 'Favorite site ever' &#125;, // input date with min &amp; max &#123; name: 'name4', type: 'date', min: '2017-03-01', max: '2018-01-12' &#125;, // input date without min nor max &#123; name: 'name5', type: 'date' &#125;, &#123; name: 'name6', type: 'number', min: -5, max: 10 &#125;, &#123; name: 'name7', type: 'number' &#125; ], buttons: [ &#123; text: 'Cancel', role: 'cancel', cssClass: 'secondary', handler: () =&gt; &#123; console.log('Confirm Cancel'); &#125; &#125;, &#123; text: 'Ok', handler: (e) =&gt; &#123; console.log(e); // 获取表单的信息然后做点儿什么 &#125; &#125; ] &#125;); await alert.present();&#125; // 可以获取弹出单选的数据async presentAlertRadio() &#123; const alert = await this.alertController.create(&#123; header: 'Radio', inputs: [ &#123; name: 'radio1', type: 'radio', label: 'Radio 1', value: 'value1', checked: true &#125;, &#123; name: 'radio2', type: 'radio', label: 'Radio 2', value: 'value2' &#125;, &#123; name: 'radio3', type: 'radio', label: 'Radio 3', value: 'value3' &#125;, &#123; name: 'radio4', type: 'radio', label: 'Radio 4', value: 'value4' &#125;, &#123; name: 'radio5', type: 'radio', label: 'Radio 5', value: 'value5' &#125;, &#123; name: 'radio6', type: 'radio', label: 'Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 Radio 6 ', value: 'value6' &#125; ], buttons: [ &#123; text: 'Cancel', role: 'cancel', cssClass: 'secondary', handler: () =&gt; &#123; console.log('Confirm Cancel'); &#125; &#125;, &#123; text: 'Ok', handler: () =&gt; &#123; console.log('Confirm Ok'); &#125; &#125; ] &#125;); await alert.present();&#125;// 可以获取弹出多选的数据async presentAlertCheckbox() &#123; const alert = await this.alertController.create(&#123; header: 'Checkbox', inputs: [ &#123; name: 'checkbox1', type: 'checkbox', label: 'Checkbox 1', value: 'value1', checked: true &#125;, &#123; name: 'checkbox2', type: 'checkbox', label: 'Checkbox 2', value: 'value2' &#125;, &#123; name: 'checkbox3', type: 'checkbox', label: 'Checkbox 3', value: 'value3' &#125;, &#123; name: 'checkbox4', type: 'checkbox', label: 'Checkbox 4', value: 'value4' &#125;, &#123; name: 'checkbox5', type: 'checkbox', label: 'Checkbox 5', value: 'value5' &#125;, &#123; name: 'checkbox6', type: 'checkbox', label: 'Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6 Checkbox 6', value: 'value6' &#125; ], buttons: [ &#123; text: 'Cancel', role: 'cancel', cssClass: 'secondary', handler: () =&gt; &#123; console.log('Confirm Cancel'); &#125; &#125;, &#123; text: 'Ok', handler: (e) =&gt; &#123; console.log(e); &#125; &#125; ] &#125;); await alert.present();&#125; 7.5 手势事件ionic4 中的 gestures 手势事件包括: tap, press, pan, swipe, rotate, and pinchevents 等。 在ionic4 中需要引用，而ionic3不需要引用 在移动端的click会有300毫秒的延迟，所以点击建议使用tap 1. 首先需要安装 hammerjs npm install hammerjs –save 2. 在项目的 src/main.ts 中引入 hammerjs import ‘hammerjs’; 在项目中使用 123456&lt;ion-button (press)=\"doPress()\"&gt;长按触发的事件&lt;/ion-button&gt;&lt;ion-button (tap)=\"doTap()\"&gt;点击触发的事件&lt;/ion-button&gt; 说明：如果未来的 ionic4.x 版本可以直接使用手势事件的话忽略上面的安装引入过程。 8 模态对话框ModalModal 模态对话框主要用于登录注册页面，我们可以把它理解为从页面底部弹出的另一个页面。 8.1 创建modal1、新建一个 model 页面以及在 model 页面下面新建一个组件。 ionic g page model ionic g component model/component/login 2. 在 model 页面所在的模块中引入刚才创建的 login 组件，并声明 12345678910111213import &#123; LoginComponent&#125; from './component/login/login.component';// 引入组件@NgModule(&#123; imports: [ CommonModule, FormsModule, IonicModule, RouterModule.forChild(routes) ], declarations: [ModelPage, LoginComponent], entryComponents: [LoginComponent]&#125;) 3. 在 modal 页面中引入刚才创建的 login 组件，并且引入 ModalController 弹出模态对话框 12345678910111213141516171819202122import &#123; Component, OnInit &#125; from '@angular/core';import &#123; ModalController &#125; from '@ionic/angular';import &#123; LoginComponent&#125; from './component/login/login.component';@Component(&#123; selector: 'app-model', templateUrl: './model.page.html', styleUrls: ['./model.page.scss'],&#125;)export class ModelPage implements OnInit &#123; constructor(public modalController: ModalController) &#123; &#125; async presentModal() &#123; const modal = await this.modalController.create(&#123; component: LoginComponent, componentProps: &#123; value: 123 &#125; &#125;); return await modal.present(); &#125; ngOnInit() &#123; &#125;&#125; 8.2 Modal传值1、modal 页面在 componentProps 中给弹出的组件页面传值 12345678constructor(public modalController: ModalController) &#123; &#125; async presentModal() &#123; const modal = await this.modalController.create(&#123; component: LoginComponent, componentProps: &#123; value: 123 &#125; &#125;); return await modal.present(); &#125; 2、弹出的组件页面通过 NavParams 接受 modal 页面的传值 123456789101112131415161718import &#123; Component, OnInit , Input&#125; from '@angular/core';import &#123; NavParams &#125; from '@ionic/angular';@Component(&#123; selector: 'app-login', templateUrl: './login.component.html', styleUrls: ['./login.component.scss'],&#125;)export class LoginComponent implements OnInit &#123; @Input() aid: any; constructor(public navParams: NavParams) &#123; console.log(this.navParams); &#125; ngOnInit() &#123;&#125;&#125; 8.3 关闭Modal时传值1. modal 监听关闭事件 12345678910async presentModal() &#123; const modal = await this.modalController.create(&#123; component: LoginComponent, componentProps: &#123; aid: '123' &#125; &#125;); await modal.present(); //监听销毁的事件 const &#123; data &#125; = await modal.onDidDismiss(); console.log(data); &#125; 2. Login 组件关闭的时候传入数据 1&lt;ion-button (click)=\"closeModel()\"&gt;关闭对话框&lt;/ion-button&gt; 1234closeModel() &#123; this.navParams.data.modal.dismiss(&#123; 'result': '消失的时候返回的内容' &#125;); &#125;"},{"title":"Ionic-01","date":"2019-03-27T01:36:28.000Z","path":"2019/03/27/Ionic-01/","text":"0 安装ionic0.1 JAVA环境下载jdk然后配置环境变量（此处略） 0.2 安卓开发环境 下载安卓SDK 先去官网下载安卓SDKhttp://www.android-studio.org/index.php/download 下载之后安装，然后打开 这里我们可以配置镜像地址1.mirrors.neusoft.edu.cn //东软信息学院2.ubuntu.buct.edu.cn/ubuntu.buct.cn //北京化工大学3.mirrors.opencas.cn (mirrors.opencas.org/mirrors.opencas.ac.cn) //中国科学院开源协会4.sdk.gdgshanghai.com 端口：8000 //上海GDG镜像服务器5.mirrors.dormforce.net //（栋力无限）电子科技大学 输入android 输入abd 输入android -h 0.3 安装gradle下载地址：https://gradle.org/releases/下载之后解压 配置gradle的环境变量 在命令窗口中输入gradle -v 0.4 安装ionic前提是已经安装完node环境了接着在终端输入: npm install -g ionic 安装cordova npm install -g cordova 0.5 初始化ionic初始化一个带底部tab的项目 ionic start myApp tabs 解决ionic4在android启动白屏问题原因：build完www中index.html文件的js引用路径不正确导致解决：修改src-index.html如下内容：将：&lt;base href=&quot;/&quot; /&gt; 替换为：&lt;base href=&quot;.&quot; /&gt; 添加安卓打包 ionic cordova platform add android 打包安卓 ionic cordova build android –release ionic cordova build android –prod –release 然后第一次可能他会自己下gradle-4.1那就等待，这是个漫长的过程 这个就是安装包的地址 0.7 生成签名将Ionic生成的文件先命名为app.apk，然后复制一份当前的bin目录里，执行命令1，生成自己的签名文件，名为:zhangqiang.keystrore，别名也是这个，有效期20000天，仅仅在第一次生成签名文件，以后不需要。 keytool -genkey -v -keystore [姓名].keystore -alias [姓名].keystore -keyalg RSA -validity 20000 然后给文件签名使用刚才生成的 signer 来给 app 签名，Usage: jarsigner -verbose -keystore [姓名].keystore -signedjar complete.apk app.apk [姓名].keystore 1 Ionic目录及核心1.1 Ionic的目录结构生成的ionic项目目录结构如下 e2e：端对端测试文件node_modules ：项目所需要的依赖包resources ：android/ios 资源（更换图标和启动动画）src：开发工作目录，页面、样式、脚本和图片都放在这个目录下www：静态文件，ionic build –prod 生成的单页面静态资源文件platforms：生成 android 或者 ios 安装包需要的资源—(cordova platform add android 后会生成)plugins：插件文件夹，里面放置各种 cordova 安装的插件config.xml: 打包成 app 的配置文件package.json: 配置项目的元数据和管理项目所需要的依赖ionic.config.json、ionic.starter.json：ionic 配置文件angular.json angular 配置文件tsconfig.json: TypeScript 项目的根目录，指定用来编译这个项目的根文件和编译选项tslint.json：格式化和校验 typescript 我们主要编写的代码都在src下面 1.2 src文件分析 app：应用根目录 （组件、页面、服务、模块…）assets：资源目录（静态文件（图片，js 框架…）theme：主题文件，里面有一个 scss 文件，设置主题信息。global.scss：全局 css 文件index.html：index 入口文件main.ts：主入口文件karma.conf.js/test.js：测试相关的配置文件polyfills.ts: 这个文件包含 Angular 需要的填充，并在应用程序之前加载 1.4 执行流程1. index.html项目启动后首先展示的是index.html 1&lt;base href=\"./\" /&gt; 就会依赖该目录下的main.ts 2. main.tsmain里面引入了根模块 1234import &#123; AppModule &#125; from './app/app.module';platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =&gt; console.log(err)); 4. app.module main.ts分析 1234567891011121314151617181920212223242526272829303132// 跟模块告诉ionic如何组装应用// ionic核心模块import &#123; NgModule &#125; from '@angular/core';// 浏览器解析模块import &#123; BrowserModule &#125; from '@angular/platform-browser';// 路由模块import &#123; RouteReuseStrategy &#125; from '@angular/router';// ionic核心模块import &#123; IonicModule, IonicRouteStrategy &#125; from '@ionic/angular';// 服务ionic打包之后启动画面，以及导航条的服务import &#123; SplashScreen &#125; from '@ionic-native/splash-screen/ngx';// 导航条插件相关服务import &#123; StatusBar &#125; from '@ionic-native/status-bar/ngx';// 引入路由配置文件import &#123; AppRoutingModule &#125; from './app-routing.module';// 引入根组件import &#123; AppComponent &#125; from './app.component';@NgModule(&#123; declarations: [AppComponent], // 声明组件 entryComponents: [], // 配置不会再模板中使用的组件 imports: [BrowserModule, IonicModule.forRoot(), AppRoutingModule], // 配置项目所需要的模块 providers: [ // 配置项目所需要的服务 StatusBar, SplashScreen, &#123; provide: RouteReuseStrategy, useClass: IonicRouteStrategy &#125; ], bootstrap: [AppComponent] // 项目启动的组件&#125;)export class AppModule &#123;&#125; 这里主要说明两个地方 12// 引入路由配置文件import &#123; AppRoutingModule &#125; from './app-routing.module'; 12// 引入根组件import &#123; AppComponent &#125; from './app.component'; 配置路由如果路径后面没有接任何信息，直接饮用tabs.module模块 5. app.component 定义这个组件的名字是页面为app.component.html1234@Component(&#123; selector: 'app-root', templateUrl: 'app.component.html'&#125;) 所以在index页面中才可以如此引用123&lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt;&lt;/body&gt; 6. app.component.html 为子组件显示的地方（嵌套） 123&lt;ion-app&gt; &lt;ion-router-outlet&gt;&lt;/ion-router-outlet&gt;&lt;/ion-app&gt; 7. app-routing.module反过来我们看路由配置app-routing.module为路由 123const routes: Routes = [ &#123; path: '', loadChildren: './tabs/tabs.module#TabsPageModule' &#125;]; 当没定义路径时引用tabs.module模块 8. tabs.module tabs.module也是一个模块，解读方法和上面类似引入tabs的路由1import &#123; TabsPageRoutingModule &#125; from './tabs.router.module'; 模块的页面12import &#123; TabsPage &#125; from './tabs.page';declarations: [TabsPage] 9. tabs.pagetabs.page是一个页面定义它的标签和页面还有样式12345@Component(&#123; selector: 'app-tabs', templateUrl: 'tabs.page.html', styleUrls: ['tabs.page.scss']&#125;) 10. tabs.page.html在ionic4中可以省略其实这段代码就省略了上面的显示部分上面显示哪部分需要去路由中查看1234567891011121314151617181920&lt;ion-tabs&gt; &lt;ion-tab-bar slot=\"bottom\"&gt; &lt;ion-tab-button tab=\"tab1\"&gt; &lt;ion-icon name=\"flash\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;Tab One&lt;/ion-label&gt; &lt;/ion-tab-button&gt; &lt;ion-tab-button tab=\"tab2\"&gt; &lt;ion-icon name=\"apps\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;Tab Two&lt;/ion-label&gt; &lt;/ion-tab-button&gt; &lt;ion-tab-button tab=\"tab3\"&gt; &lt;ion-icon name=\"send\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;Tab Three&lt;/ion-label&gt; &lt;/ion-tab-button&gt; &lt;/ion-tab-bar&gt;&lt;/ion-tabs&gt; 11. tabs.router.module 配置tabs的路由其中说明的地方默认显示哪一页12345&#123; path: '', redirectTo: '/tabs/tab1', pathMatch: 'full' &#125; 1.5 创建页面以及页面跳转1、cd 到我们的项目目录2、通过 ionic g page 页面名称 ionic g page button 我们也可以通过ionic -g help来查看我们都能创建那些 3、创建完成组件以后会在 src 目录下面多一个 button 的目录，它既是一个页面也是一个模块。 同时在路由中会自动生成button路由 在 tab1 里面写一个按钮点击跳转到 button 页面 1&lt;ion-button color=\"primary\" routerLink=\"/button\"&gt;跳转到按钮页面&lt;/ion-button&gt; 其中color=”primary”，primary是在theme中配置的颜色 添加返回按钮ionic4.x 中跳转到其他页面不会默认加返回按钮，如果我们想给 button 页面加返回的话需要找到 button 对应的 button.page.html，然后在再头部加入 ion-back-button。 123&lt;ion-buttons slot=\"start\"&gt; &lt;ion-back-button defaultHref=\"/tabs/tab1\"&gt;&lt;/ion-back-button&gt;&lt;/ion-buttons&gt; 其中slot表示它的位置 1.6 新增底部tabs页面1. 创建 tab4 模块 ionic g page tab4 2. 修改根目录里 app-routing.module.ts 文件里面的路由配置，去掉默认增加的路由 3. tabs.router.module.ts 中新增路由 123&#123; path: 'tab4', loadChildren: '../tab4/tab4.module#Tab4PageModule' &#125; 注意这里是../如果在app-routing.module.ts里配置的路由就不会显示底部标签了 4. tabs.page.html 中新增底部 tab 切换按钮 1234&lt;ion-tab-button tab=\"tab4\"&gt; &lt;ion-icon name=\"send\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;Tab 4&lt;/ion-label&gt; &lt;/ion-tab-button&gt; 1.7 定义公共模块1. 创建公共模块以及组件 ionic g module module/slide ionic g component module/slide 2. 公共模块 slide.module.ts 中暴露对应的组件 1234567891011import &#123; NgModule &#125; from '@angular/core';import &#123; CommonModule &#125; from '@angular/common';import &#123; SlideComponent &#125; from './slide.component';@NgModule(&#123; declarations: [SlideComponent], imports: [ CommonModule ], exports: [SlideComponent]&#125;)export class SlideModule &#123; &#125; 3. 模块的组件slide.component 1234567891011121314import &#123; Component, OnInit &#125; from '@angular/core';@Component(&#123; selector: 'app-slide', templateUrl: './slide.component.html', styleUrls: ['./slide.component.scss'],&#125;)export class SlideComponent implements OnInit &#123; constructor() &#123; &#125; ngOnInit() &#123;&#125;&#125; 4. 用到的地方引入自定义模块，并依赖注入自定义模块这里以刚才的button为例12345678910111213import &#123; SlideModule &#125; from '../module/slide/slide.module';@NgModule(&#123; imports: [ CommonModule, FormsModule, IonicModule, SlideModule, RouterModule.forChild(routes) ], declarations: [ButtonPage]&#125;)export class ButtonPageModule &#123;&#125; 5. 使用自定义模块 1&lt;app-slide&gt;&lt;/app-slide&gt; 6. 使用ionic组件如果要使用ionic组件需要先在module中引入12345678910import &#123;IonicModule&#125; from '@ionic/angular';@NgModule(&#123; declarations: [SlideComponent], imports: [ CommonModule, IonicModule ], exports: [SlideComponent]&#125;)export class SlideModule &#123; &#125; 2 Ionic UI2.1 Ionic内置颜色ionic的内置颜色：primary secondary tertiary success warning danger dark medium light 配置在theme中 用法： 12&lt;ion-button color=\"primary\"&gt; primary &lt;/ion-button&gt;&lt;ion-button color=\"secondary\"&gt; secondary &lt;/ion-button&gt; 2.2 Ionic4中的按钮1. ion-button 组件可以定义一个按钮 1&lt;ion-button&gt;Default&lt;/ion-button&gt; 2. color 属性定义按钮的颜色 123456789&lt;ion-button color=\"primary\"&gt; primary &lt;/ion-button&gt;&lt;ion-button color=\"secondary\"&gt; secondary &lt;/ion-button&gt;&lt;ion-button color=\"tertiary\"&gt; tertiary &lt;/ion-button&gt;&lt;ion-button color=\"success\"&gt; success &lt;/ion-button&gt;&lt;ion-button color=\"warning\"&gt; warning &lt;/ion-button&gt;&lt;ion-button color=\"danger\"&gt; danger &lt;/ion-button&gt;&lt;ion-button color=\"dark\"&gt; dark &lt;/ion-button&gt;&lt;ion-button color=\"medium\"&gt; medium &lt;/ion-button&gt;&lt;ion-button color=\"light\"&gt; light &lt;/ion-button&gt; 3. expand 宽度 block: 全行圆角按钮full: 全行直角按钮12&lt;ion-button color=\"primary\" expand=\"block\"&gt; button &lt;/ion-button&gt;&lt;ion-button color=\"primary\" expand=\"full\"&gt; button &lt;/ion-button&gt; 4. fill 背景填充 clear： 只显示文字outline：填充色为空，只显示边线和文字solid： 全部都显示 12345678&lt;ion-button expand=\"full\" fill=\"outline\"&gt;Outline + Full&lt;/ion-button&gt; &lt;ion-button fill=\"clear\" color=\"success\"&gt; &lt;ion-icon slot=\"icon-only\" name=\"add\"&gt;&lt;/ion-icon&gt; &lt;/ion-button&gt; &lt;ion-button fill=\"solid\"&gt; &lt;ion-icon name=\"ios-arrow-back\" slot=\"start\"&gt;&lt;/ion-icon&gt; 返回 &lt;/ion-button&gt; 5. size 设置按钮的大小 small: 小按钮default: 默认按钮large: 大按钮123&lt;ion-button size=\"large\"&gt;Large&lt;/ion-button&gt;&lt;ion-button&gt;Default&lt;/ion-button&gt;&lt;ion-button size=\"small\"&gt;Small&lt;/ion-button&gt; 6. mode平台样式 ios:ios平台md:安卓平台12&lt;ion-button mode='ios' color=\"primary\"&gt; ios 平台的按钮 &lt;/ion-button&gt;&lt;ion-button mode='md' color=\"primary\"&gt;android 平台的按钮 &lt;/ion-button&gt; 按钮结合图标其中slot的start表示在左侧头部end表示在右侧尾部12345678&lt;ion-button&gt; &lt;ion-icon slot=\"start\" name=\"star\"&gt;&lt;/ion-icon&gt; Left Icon&lt;/ion-button&gt;&lt;ion-button&gt; &lt;ion-icon slot=\"end\" name=\"star\"&gt;&lt;/ion-icon&gt; Right Icon&lt;/ion-button&gt; 2.3 ionic中的图标ionic 图标官网：https://ionicons.com/ 1&lt;ion-icon name=\"apps\"&gt;&lt;/ion-icon&gt; slot 指定图标的位置:其中slot的start表示在左侧头部end表示在右侧尾部具体同上2.2 2.4 ion-toolbar ion-header 头部 ion-content 内容 ion-footer 底部 ion-toolbar 主要用于头部和底部，固定在页面顶部或者底部。 ion-title 放在 ion-toolbar 里面指定导航的名称 ion-buttons 按钮组，主要用在 ion-toolbar 中，工具栏中的按钮应该放在 ion-buttons 的内部。 ion-back-button 返回按钮，放在 ion-buttons 里面 123456789101112&lt;ion-header&gt; &lt;ion-toolbar&gt; &lt;ion-buttons slot=\"start\"&gt; &lt;ion-back-button defaultHref=\"/tabs/tab1\"&gt;&lt;/ion-back-button&gt; &lt;/ion-buttons&gt; &lt;ion-title&gt;button&lt;/ion-title&gt; &lt;/ion-toolbar&gt;&lt;/ion-header&gt;&lt;ion-content&gt; &lt;app-slide&gt;&lt;/app-slide&gt;&lt;/ion-content&gt; 2.5 添加Ionic内置主题Ionic4.x 修改主题颜色的话需要在 src/theme/variables.scss 文件中修改。 https://ionicframework.com/docs/theming/advanced 找到 src/theme/variables.scss 文件，如下代码新增 favorite 颜色 1234567.ion-color-favorite &#123; // 定义主题名称--ion-color-base: #69bb7b; // 基本颜色--ion-color-base-rgb: 105,187,123; // 基本颜色的rgb格式--ion-color-contrast: #ffffff; // 对比颜色--ion-color-contrast-rgb: 255,255,255; // 对比颜色的rgb--ion-color-shade: #5ca56c; --ion-color-tint: #78c288; // 阴影颜色&#125; 在需要的地方可以使用 123&lt;ion-button color=\"favorite\"&gt;自定义颜色&lt;/ion-button&gt; 3 Ionic列表3.1 普通列表12345678&lt;ion-list&gt; &lt;ion-item&gt; &lt;ion-label&gt;Peperoni&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-label&gt;Hawaii&lt;/ion-label&gt; &lt;/ion-item&gt;&lt;/ion-list&gt; 如果普通列表加上路由跳转的话列表将会自动加上箭头。 3.2 分组列表ion-item-divider 123456789101112131415161718&lt;ion-list&gt; &lt;ion-item-divider&gt; &lt;ion-label&gt; Section A &lt;/ion-label&gt; &lt;/ion-item-divider&gt; &lt;ion-item&gt;&lt;ion-label&gt;A1&lt;/ion-label&gt;&lt;/ion-item&gt; &lt;ion-item&gt;&lt;ion-label&gt;A2&lt;/ion-label&gt;&lt;/ion-item&gt; &lt;ion-item&gt;&lt;ion-label&gt;A3&lt;/ion-label&gt;&lt;/ion-item&gt; &lt;ion-item-divider&gt; &lt;ion-label&gt; Section B &lt;/ion-label&gt; &lt;/ion-item-divider&gt; &lt;ion-item&gt;&lt;ion-label&gt;B1&lt;/ion-label&gt;&lt;/ion-item&gt; &lt;ion-item&gt;&lt;ion-label&gt;B2&lt;/ion-label&gt;&lt;/ion-item&gt; &lt;ion-item&gt;&lt;ion-label&gt;B3&lt;/ion-label&gt;&lt;/ion-item&gt;&lt;/ion-list&gt; 3.3 列表中带图标123456789101112&lt;ion-list&gt; &lt;ion-item&gt; &lt;ion-icon slot=\"start\" name=\"people\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;个人中心&lt;/ion-label&gt; &lt;ion-icon slot=\"end\" name=\"arrow-forward\"&gt;&lt;/ion-icon&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-icon slot=\"start\" name=\"wallet\" color=\"success\"&gt;&lt;/ion-icon&gt; &lt;ion-label&gt;钱包&lt;/ion-label&gt; &lt;ion-icon slot=\"end\" name=\"arrow-forward\"&gt;&lt;/ion-icon&gt; &lt;/ion-item&gt;&lt;/ion-list&gt; 3.4 列表中的头像ion-avatar img 的src路径直接用assets/加上地址就可以 1234567891011121314151617181920&lt;ion-list&gt; &lt;ion-item&gt; &lt;ion-avatar&gt; &lt;img src=\"assets/01.png\"&gt; &lt;/ion-avatar&gt; &lt;ion-label&gt;沃尔玛无人收银系统&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-avatar&gt; &lt;img src=\"assets/02.png\"&gt; &lt;/ion-avatar&gt; &lt;ion-label&gt;Hawaii&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-avatar&gt; &lt;img src=\"assets/03.png\"&gt; &lt;/ion-avatar&gt; &lt;ion-label&gt;haha&lt;/ion-label&gt; &lt;/ion-item&gt;&lt;/ion-list&gt; 3.5 列表中的图片ion-thumbnail 1234567891011121314151617181920212223242526272829303132&lt;ion-list&gt; &lt;ion-item&gt; &lt;ion-thumbnail slot=\"start\"&gt; &lt;img src=\"https://gravatar.com/avatar/dba6bae8c566f9d4041fb9cd9ada7741?d=identicon&amp;f=y\"&gt; &lt;/ion-thumbnail&gt; &lt;ion-label&gt;Peperoni&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-thumbnail slot=\"start\"&gt; &lt;img src=\"assets/03.png\"&gt; &lt;/ion-thumbnail&gt; &lt;ion-label&gt;Hawaii&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-thumbnail slot=\"end\"&gt; &lt;img src=\"assets/01.png\"&gt; &lt;/ion-thumbnail&gt; &lt;ion-label&gt;Hawaii&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-thumbnail slot=\"end\"&gt; &lt;img src=\"assets/02.png\"&gt; &lt;/ion-thumbnail&gt; &lt;ion-label&gt;Hawaii&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item&gt; &lt;ion-thumbnail slot=\"end\"&gt; &lt;img src=\"assets/03.png\"&gt; &lt;/ion-thumbnail&gt; &lt;ion-label&gt;Hawaii&lt;/ion-label&gt; &lt;/ion-item&gt;&lt;/ion-list&gt; 3.6 滑块列表ion-item-sliding 1234567891011121314151617181920212223242526&lt;ion-list&gt; &lt;ion-item-sliding&gt; &lt;ion-item&gt; &lt;ion-label&gt;Item1&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item-options side=\"start\"&gt; &lt;ion-item-option (click)=\"favorite(item)\"&gt;Favorite&lt;/ion-item-option&gt; &lt;ion-item-option color=\"primary\" (click)=\"share(item)\"&gt;Share&lt;/ion-item-option&gt; &lt;/ion-item-options&gt; &lt;ion-item-options side=\"end\"&gt; &lt;ion-item-option (click)=\"unread(item)\"&gt;Unread&lt;/ion-item-option&gt; &lt;/ion-item-options&gt; &lt;/ion-item-sliding&gt; &lt;ion-item-sliding&gt; &lt;ion-item&gt; &lt;ion-label&gt;Item2&lt;/ion-label&gt; &lt;/ion-item&gt; &lt;ion-item-options side=\"start\"&gt; &lt;ion-item-option color=\"success\"&gt;Favorite&lt;/ion-item-option&gt; &lt;ion-item-option color=\"primary\" (click)=\"share(item)\"&gt;Share&lt;/ion-item-option&gt; &lt;/ion-item-options&gt; &lt;ion-item-options side=\"end\"&gt; &lt;ion-item-option color=\"success\"&gt;Unread&lt;/ion-item-option&gt; &lt;/ion-item-options&gt; &lt;/ion-item-sliding&gt;&lt;/ion-list&gt;"},{"title":"ES6-3","date":"2019-02-25T06:37:18.000Z","path":"2019/02/25/ES6-3/","text":"7 set和map数据结构7.1 Set基础ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。 12345678var s = new Set();[2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。 初始化 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 1234567891011121314151617181920// 例一var set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三function divs () &#123; return [...document.querySelectorAll('div')];&#125;var set = new Set(divs());set.size // 56// 类似于divs().forEach(div =&gt; set.add(div));set.size // 56 向Set加入值的时候，不会发生类型转换，所以5和”5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 7.2 Set实例的属性和方法1. Set属性 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 2. Set操作数据 Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 1234567891011s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false 去除数组重复成员的一种方法 12345678function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3]// 或者利用解构赋值[...(new Set(array))] 3. 遍历操作 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 （1）keys()，values()，entries() 由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。12345678910111213141516171819202122let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// [\"red\", \"red\"]// [\"green\", \"green\"]// [\"blue\", \"blue\"] Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。这意味着，可以省略values方法，直接用for…of循环遍历Set。 12345678let set = new Set(['red', 'green', 'blue']);for (let x of set) &#123; console.log(x);&#125;// red// green// blue （2）forEach() Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 12345let set = new Set([1, 2, 3]);set.forEach((value, key) =&gt; console.log(value * 2) )// 2// 4// 6 而且，数组的map和filter方法也可以用于Set了。 1234567let set = new Set([1, 2, 3]);set = new Set([...set].map(x =&gt; x * 2));// 返回Set结构：&#123;2, 4, 6&#125;let set = new Set([1, 2, 3, 4, 5]);set = new Set([...set].filter(x =&gt; (x % 2) == 0));// 返回Set结构：&#123;2, 4&#125; 7.3 WeakSetWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 WeakSet的成员只能是对象，而不能是其他类型的值。 WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用 如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。 var ws = new WeakSet(); WeakSet结构有以下三个方法 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。 123456789101112var ws = new WeakSet();var obj = &#123;&#125;;var foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false 7.4 Map它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 123456789var m = new Map();var o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // \"content\"m.has(o) // truem.delete(o) // truem.has(o) // false 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 12345678910var map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // \"张三\"map.has('title') // truemap.get('title') // \"Author\" Map构造函数接受数组作为参数，实际上执行的是下面的算法。123456var items = [ ['name', '张三'], ['title', 'Author']];var map = new Map();items.forEach(([key, value]) =&gt; map.set(key, value)); 如果对同一个键多次赋值，后面的值将覆盖前面的值。 只有对同一个对象的引用，Map结构才将其视为同一个键。 1234var map = new Map();map.set(['a'], 555);map.get(['a']) // undefined 7.5 Map属性和操作方法1. 属性 (1)size属性 size属性返回Map结构的成员总数。 12345let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2 (2)set(key, value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 12345var m = new Map();m.set(\"edition\", 6) // 键是字符串m.set(262, \"standard\") // 键是数值m.set(undefined, \"nah\") // 键是undefined (3)get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 123456var m = new Map();var hello = function() &#123;console.log(\"hello\");&#125;m.set(hello, \"Hello ES6!\") // 键是函数m.get(hello) // Hello ES6! (4)has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中。 12345678910var m = new Map();m.set(\"edition\", 6);m.set(262, \"standard\");m.set(undefined, \"nah\");m.has(\"edition\") // truem.has(\"years\") // falsem.has(262) // truem.has(undefined) // true (5)delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 123456var m = new Map();m.set(undefined, \"nah\");m.has(undefined) // truem.delete(undefined)m.has(undefined) // false (6)clear() clear方法清除所有成员，没有返回值。 1234567let map = new Map();map.set('foo', true);map.set('bar', false);map.size // 2map.clear()map.size // 0 2. 遍历方法 Map原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 Map的遍历顺序就是插入顺序。 (1) keys(),values(),entries() 1234567891011121314151617181920212223242526272829303132let map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// \"F\"// \"T\"for (let value of map.values()) &#123; console.log(value);&#125;// \"no\"// \"yes\"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// \"F\" \"no\"// \"T\" \"yes\"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125; (2) 转换数组Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。 1234567891011121314151617let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] (3) 利用数组 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。 1234567891011121314let map0 = new Map() .set(1, 'a') .set(2, 'b') .set(3, 'c');let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3));// 产生Map结构 &#123;1 =&gt; 'a', 2 =&gt; 'b'&#125;let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, '_' + v]) );// 产生Map结构 &#123;2 =&gt; '_a', 4 =&gt; '_b', 6 =&gt; '_c'&#125; (4) forEach Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 123map.forEach(function(value, key, map) &#123; console.log(\"Key: %s, Value: %s\", key, value);&#125;); forEach方法还可以接受第二个参数，用来绑定this。 123456789var reporter = &#123; report: function(key, value) &#123; console.log(\"Key: %s, Value: %s\", key, value); &#125;&#125;;map.forEach(function(value, key, map) &#123; this.report(key, value);&#125;, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 3. 与其他数据结构的互相转换 （1）Map转为数组 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。123let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);[...myMap]// [ [ true, 7 ], [ &#123; foo: 3 &#125;, [ 'abc' ] ] ] （2）数组转为Map 将数组转入Map构造函数，就可以转为Map。12new Map([[true, 7], [&#123;foo: 3&#125;, ['abc']]])// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; （3）Map转为对象 如果所有Map的键都是字符串，它可以转为对象。 1234567891011function strMapToObj(strMap) &#123; let obj = Object.create(null); for (let [k,v] of strMap) &#123; obj[k] = v; &#125; return obj;&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToObj(myMap)// &#123; yes: true, no: false &#125; （4）对象转为Map 12345678910function objToStrMap(obj) &#123; let strMap = new Map(); for (let k of Object.keys(obj)) &#123; strMap.set(k, obj[k]); &#125; return strMap;&#125;objToStrMap(&#123;yes: true, no: false&#125;)// [ [ 'yes', true ], [ 'no', false ] ] （5）Map转为JSON Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。 1234567function strMapToJson(strMap) &#123; return JSON.stringify(strMapToObj(strMap));&#125;let myMap = new Map().set('yes', true).set('no', false);strMapToJson(myMap)// '&#123;\"yes\":true,\"no\":false&#125;' 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 1234567function mapToArrayJson(map) &#123; return JSON.stringify([...map]);&#125;let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, ['abc']);mapToArrayJson(myMap)// '[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]' （6）JSON转为Map JSON转为Map，正常情况下，所有键名都是字符串。 123456function jsonToStrMap(jsonStr) &#123; return objToStrMap(JSON.parse(jsonStr));&#125;jsonToStrMap('&#123;\"yes\":true,\"no\":false&#125;')// Map &#123;'yes' =&gt; true, 'no' =&gt; false&#125; 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。 123456function jsonToMap(jsonStr) &#123; return new Map(JSON.parse(jsonStr));&#125;jsonToMap('[[true,7],[&#123;\"foo\":3&#125;,[\"abc\"]]]')// Map &#123;true =&gt; 7, Object &#123;foo: 3&#125; =&gt; ['abc']&#125; 7.6 WeakMapWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 WeakMap应用的典型场合就是DOM节点作为键名 123456789let myElement = document.getElementById('logo');let myWeakmap = new WeakMap();myWeakmap.set(myElement, &#123;timesClicked: 0&#125;);myElement.addEventListener('click', function() &#123; let logoData = myWeakmap.get(myElement); logoData.timesClicked++;&#125;, false); 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 8 Proxy 和 Reflect8.1 Proxy在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 var proxy = new Proxy(target, handler); new Proxy()表示生成一个Proxy实例， target参数表示所要拦截的目标对象， handler参数也是一个对象，用来定制拦截行为。 Proxy接受两个参数。 第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象； 第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。 1234567891011121314151617var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 如果handler没有设置任何拦截，那就等同于直接通向原对象。 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = 'b';target.a // \"b\" Proxy 实例也可以作为其他对象的原型对象。 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。 Proxy 支持的拦截操作一览。 1. get(target, propKey, receiver) 拦截对象属性的读取 12345678910111213141516var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(\"Property \\\"\" + property + \"\\\" does not exist.\"); &#125; &#125;&#125;);proxy.name // \"张三\"proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 123456789let proto = new Proxy(&#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log('GET '+propertyKey); return target[propertyKey]; &#125;&#125;);let obj = Object.create(proto);obj.xxx // \"GET xxx\" 2.set(target, propKey, value, receiver) set方法用来拦截某个属性的赋值操作。 1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === 'age') &#123; if (!Number.isInteger(value)) &#123; throw new TypeError('The age is not an integer'); &#125; if (value &gt; 200) &#123; throw new RangeError('The age seems invalid'); &#125; &#125; // 对于age以外的属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = 'young' // 报错person.age = 300 // 报错 3. has(target, propKey) has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 1234567891011var handler = &#123; has (target, key) &#123; if (key[0] === '_') &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: 'foo', prop: 'foo' &#125;;var proxy = new Proxy(target, handler);'_prop' in proxy // false 4. deleteProperty(target, propKey) deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 12345678910111213141516var handler = &#123; deleteProperty (target, key) &#123; invariant(key, 'delete'); return true; &#125;&#125;;function invariant (key, action) &#123; if (key[0] === '_') &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123; _prop: 'foo' &#125;;var proxy = new Proxy(target, handler);delete proxy._prop// Error: Invalid attempt to delete private \"_prop\" property 上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。5. ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回对象所有自身的属性，而Object.keys()仅返回对象可遍历的属性。 6. getOwnPropertyDescriptor(target, propKey) getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor，返回一个属性描述对象或者undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor (target, key) &#123; if (key[0] === '_') &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: 'bar', baz: 'tar' &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, 'wat')// undefinedObject.getOwnPropertyDescriptor(proxy, '_foo')// undefinedObject.getOwnPropertyDescriptor(proxy, 'baz')// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; 对于第一个字符为下划线的属性名会返回undefined。 7. defineProperty(target, propKey, propDesc) Object.defineProperty(obj, prop, descriptor) obj 被定义或修改属性的对象； prop 要定义或修改的属性名称； descriptor 对属性的描述； 1234567891011121314151617181920212223242526272829var o = &#123;&#125;; //创建一个对象//使用数据描述符来为对象添加属性Object.defineProperty(o, 'a', &#123; value: 37, writable: true, enumerable: true, configurable: true&#125;);//属性”a”被设置到对象o上，并且值为37//使用访问器描述符来为对象添加属性var bValue = 38;Object.defineProperty(o, 'b', &#123; get: function() &#123; return bValue; &#125;, set: function(newValue) &#123; bValue = newValue; &#125;, enumerable: true, configurable: true&#125;);o.b; // 38//属性”b”被设置到对象o上，并且值为38。//现在o.b的值指向bValue变量，除非o.b被重新定义//你不能尝试混合数据、访问器两种描述符Object.defineProperty(o, 'conflict', &#123; value: 0x9f91102, get: function() &#123; return 0xdeadbeef; &#125;&#125;);//抛出一个类型错误： value appears only in data descriptors, get appears only in accessor descriptors（value只出现在数据描述符中，get只出现在访问器描述符中） defineProperty方法拦截了Object.defineProperty操作。 123456789var handler = &#123; defineProperty (target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = 'bar'// TypeError: proxy defineProperty handler returned false for property '\"foo\"' 上面代码中，defineProperty方法返回false，导致添加新属性会抛出错误。 8. preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。 9. getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。 10. isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。 11. setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。 如果目标对象是函数，那么还有两种额外操作可以拦截。 123456789101112var twice = &#123; apply (target, ctx, args) &#123; return Reflect.apply(...arguments) * 2; &#125;&#125;;function sum (left, right) &#123; return left + right;&#125;;var proxy = new Proxy(sum, twice);proxy(1, 2) // 6proxy.call(null, 5, 6) // 22proxy.apply(null, [7, 8]) // 30 上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。12. apply(target, object, args) apply方法拦截函数的调用、call和apply操作 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 13. construct(target, args) construct方法用于拦截new命令，下面是拦截对象的写法。 construct方法可以接受两个参数。 target: 目标对象 args：构建函数的参数对象 construct方法返回的必须是一个对象，否则会报错。 12345678910var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, args) &#123; console.log('called: ' + args.join(', ')); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);new p(1).value// \"called: 1\"// 10 8.2 Proxy案例1. 抽离校验模块 这个示例演示了如何使用 Proxy 保障数据类型的准确性：1234567891011121314151617181920let numericDataStore = &#123; count: 0, amount: 1234, total: 14&#125;;numericDataStore = new Proxy(numericDataStore, &#123; set(target, key, value, proxy) &#123; if (typeof value !== 'number') &#123; throw Error(\"Properties in numericDataStore can only be numbers\"); &#125; return Reflect.set(target, key, value, proxy); &#125;&#125;);// 抛出错误，因为 \"foo\" 不是数值numericDataStore.count = \"foo\";// 赋值成功numericDataStore.count = 333; 使用 Proxy 则可以将校验器从核心逻辑分离出来自成一体 12345678910111213141516171819202122232425262728293031323334353637383940414243function createValidator(target, validator) &#123; return new Proxy(target, &#123; _validator: validator, set(target, key, value, proxy) &#123; // 对象是否含有key这个属性 if (target.hasOwnProperty(key)) &#123; // 获取自己配置的该属性的配置 let validator = this._validator[key]; // 判断该数值是否满足自己的配置 if (!!validator(value)) &#123; return Reflect.set(target, key, value, proxy); &#125; else &#123; throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`); &#125; &#125; else &#123; throw Error(`$&#123;key&#125; is not a valid property`) &#125; &#125; &#125;);&#125;const personValidators = &#123; name(val) &#123; return typeof val === 'string'; &#125;, age(val) &#123; return typeof age === 'number' &amp;&amp; age &gt; 18; &#125;&#125;class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; return createValidator(this, personValidators); &#125;&#125;const bill = new Person('Bill', 25);// 以下操作都会报错bill.name = 0; bill.age = 'Bill'; bill.age = 15; 2. 私有属性 12345678910111213141516171819202122232425262728let api = &#123; _apiKey: '123abc456def', getUsers: function()&#123; &#125;, getUser: function(userId)&#123; &#125;, setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = ['_apiKey'];api = new Proxy(api, &#123; get(target, key, proxy) &#123; // 在这里就是判断你所掉的key是不是_apiKey if(RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`); &#125; return Reflect.get(target, key, proxy); &#125;, set(target, key, value, proxy) &#123; // 在这里就是判断你所掉的key是不是_apiKey if(RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error(`$&#123;key&#125; is restricted. Please see api documentation for further info.`); &#125; return Reflect.get(target, key, value, proxy); &#125;&#125;);// 以下操作都会抛出错误console.log(api._apiKey);api._apiKey = '987654321'; 第二种方法是使用 has 拦截 in 操作： 12345678910111213141516171819202122232425var api = &#123; _apiKey: '123abc456def', getUsers: function()&#123; &#125;, getUser: function(userId)&#123; &#125;, setUser: function(userId, config)&#123; &#125;&#125;;const RESTRICTED = ['_apiKey'];api = new Proxy(api, &#123; has(target, key) &#123; return (RESTRICTED.indexOf(key) &gt; -1) ? false : Reflect.has(target, key); &#125;&#125;);console.log(\"_apiKey\" in api); // falsefor (var key in api) &#123; if (api.hasOwnProperty(key) &amp;&amp; key === \"_apiKey\") &#123; console.log(\"This will never be logged because the proxy obscures _apiKey...\") &#125;&#125;// This will never be logged because the proxy obscures _apiKey...// 判断api是否含有key为_apiKey的属性，结果如果输出，就证明存在该属性 3. 访问日志 对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能： 1234567891011121314151617181920212223242526272829let api = &#123; _apiKey: '123abc456def', getUsers: function() &#123; /* ... */ &#125;, getUser: function(userId) &#123; /* ... */ &#125;, setUser: function(userId, config) &#123; /* ... */ &#125;&#125;;function logMethodAsync(timestamp, method) &#123; setTimeout(function() &#123; console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`); &#125;, 0)&#125;api = new Proxy(api, &#123; get: function(target, key, proxy) &#123; var value = target[key]; // 返回一个方法 return function() &#123; // 调用打印时间的方法 logMethodAsync(new Date(), key); // Reflect.get(target, key, value, proxy); // 继续调用get方法 return Reflect.apply(value, target, arguments); &#125;; &#125;&#125;);api.getUsers(); //Tue Feb 26 2019 11:04:17 GMT+0800 (中国标准时间) - Logging getUsers request asynchronously.api.getUser(); // Tue Feb 26 2019 11:11:46 GMT+0800 (中国标准时间) - Logging getUser request asynchronously. 4. 预警和拦截 假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142let dataStore = &#123; noDelete: 1235, oldMethod: function() &#123;/*...*/ &#125;, doNotChange: \"tried and true\"&#125;;const NODELETE = ['noDelete']; const NOCHANGE = ['doNotChange'];const DEPRECATED = ['oldMethod']; dataStore = new Proxy(dataStore, &#123; set(target, key, value, proxy) &#123; if (NOCHANGE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; is immutable.`); &#125; return Reflect.set(target, key, value, proxy); &#125;, deleteProperty(target, key) &#123; if (NODELETE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; cannot be deleted.`); &#125; return Reflect.deleteProperty(target, key); &#125;, get(target, key, proxy) &#123; if (DEPRECATED.includes(key)) &#123; console.warn(`Warning! $&#123;key&#125; is deprecated.`); &#125; var val = target[key]; // 判断这个是方法还是属性，如果是方法就继续该方法，如果是属性就返回属性 return typeof val === 'function' ? function(...args) &#123; Reflect.apply(target[key], target, args); &#125; : val; &#125;&#125;);// these will throw errors or log warnings, respectivelydataStore.doNotChange = \"foo\"; delete dataStore.noDelete; dataStore.oldMethod(); 8.3 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true 上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。 8.4 ReflectReflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 1234567891011121314// 老写法try &#123; Object.defineProperty(target, property, attributes); // success&#125; catch (e) &#123; // failure&#125;// 新写法if (Reflect.defineProperty(target, property, attributes)) &#123; // success&#125; else &#123; // failure&#125; （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 12345// 老写法'assign' in Object // true// 新写法Reflect.has(Object, 'assign') // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log('property ' + name + ' on ' + target + ' set to ' + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，然后再部署额外的功能。 下面是另一个例子。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log('get', target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log('delete' + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log('has' + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 12345// 老写法Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1// 新写法Reflect.apply(Math.floor, undefined, [1.75]) // 1 9 Iterator和for…of循环9.1 Iterator（遍历器）遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator的作用有三个： 一是为各种数据结构，提供一个统一的、简便的访问接口； 二是使得数据结构的成员能够按某种次序排列； 三是ES6创造了一种新的遍历命令for…of循环，Iterator接口主要供for…of消费。 Iterator的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中， value属性是当前成员的值， done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 12345678910111213141516var it = makeIterator(['a', 'b']);it.next() // &#123; value: \"a\", done: false &#125;it.next() // &#123; value: \"b\", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。 12345678910function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++]&#125; : &#123;done: true&#125;; &#125; &#125;;&#125; 凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。 1234567let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。 9.2 添加Iterator接口12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口。 12345NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator];// 或者NodeList.prototype[Symbol.iterator] = [][Symbol.iterator];[...document.querySelectorAll('div')] // 可以执行了 下面是类似数组的对象调用数组的Symbol.iterator方法的例子。 12345678910let iterable = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // 'a', 'b', 'c'&#125; 注意，普通对象部署数组的Symbol.iterator方法，并无效果。 12345678910let iterable = &#123; a: 'a', b: 'b', c: 'c', length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator]&#125;;for (let item of iterable) &#123; console.log(item); // undefined, undefined, undefined&#125; 9.3 遍历器的return()遍历器对象除了具有next方法，还可以具有return方法和throw方法。 return方法的使用场合是，如果for…of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 1234567891011121314function readLinesSync(file) &#123; return &#123; next() &#123; if (file.isAtEndOfFile()) &#123; file.close(); return &#123; done: true &#125;; &#125; &#125;, return() &#123; file.close(); return &#123; done: true &#125;; &#125;, &#125;;&#125; 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面，我们让文件的遍历提前返回，这样就会触发执行return方法。 1234for (let line of readLinesSync(fileName)) &#123; console.log(line); break;&#125; 注意，return方法必须返回一个对象，这是Generator规格决定的。 9.4 for…of循环for…of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象，以及字符串。 1. 数组 123456789101112const arr = ['red', 'green', 'blue'];for(let v of arr) &#123; console.log(v); // red green blue&#125;const obj = &#123;&#125;;obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr);for(let v of obj) &#123; console.log(v); // red green blue&#125; 上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for…of循环，产生了与arr完全一样的结果。 2. Set和Map结构 Set和Map结构也原生具有Iterator接口，可以直接使用for…of循环。 123456789101112131415161718var engines = new Set([\"Gecko\", \"Trident\", \"Webkit\", \"Webkit\"]);for (var e of engines) &#123; console.log(e);&#125;// Gecko// Trident// Webkitvar es6 = new Map();es6.set(\"edition\", 6);es6.set(\"committee\", \"TC39\");es6.set(\"standard\", \"ECMA-262\");for (var [name, value] of es6) &#123; console.log(name + \": \" + value);&#125;// edition: 6// committee: TC39// standard: ECMA-262 3. 计算生成的数据结构 有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 1234567let arr = ['a', 'b', 'c'];for (let pair of arr.entries()) &#123; console.log(pair);&#125;// [0, 'a']// [1, 'b']// [2, 'c'] 4. 类似数组的对象 类似数组的对象包括好几类。下面是for…of循环用于字符串、DOM NodeList对象、arguments对象的例子。 1234567891011121314151617181920212223// 字符串let str = \"hello\";for (let s of str) &#123; console.log(s); // h e l l o&#125;// DOM NodeList对象let paras = document.querySelectorAll(\"p\");for (let p of paras) &#123; p.classList.add(\"test\");&#125;// arguments对象function printArgs() &#123; for (let x of arguments) &#123; console.log(x); &#125;&#125;printArgs('a', 'b');// 'a'// 'b' 并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 1234567891011let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;;// 报错for (let x of arrayLike) &#123; console.log(x);&#125;// 正确for (let x of Array.from(arrayLike)) &#123; console.log(x);&#125; 9.5 对象对于普通的对象，for…of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但是，这样情况下，for…in循环依然可以用来遍历键名。 1234567891011121314151617var es6 = &#123; edition: 6, committee: \"TC39\", standard: \"ECMA-262\"&#125;;for (let e in es6) &#123; console.log(e);&#125;// edition// committee// standardfor (let e of es6) &#123; console.log(e);&#125;// TypeError: es6 is not iterable 上面代码表示，对于普通的对象，for…in循环可以遍历键名，for…of循环会报错。 Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 1234567891011// simple arrayvar arr = ['a', 'b', 'c'];console.log(Object.keys(arr)); // console: ['0', '1', '2']// array like objectvar obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log(Object.keys(obj)); // console: ['0', '1', '2']// array like object with random key orderingvar anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log(Object.keys(anObj)); // console: ['2', '7', '100'] 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 1234567let arrayLike = &#123; length: 2, 0: 'a', 1: 'b' &#125;;for (var key of Object.keys(arrayLike)) &#123; console.log(key + \": \" + arrayLike[key]);&#125;// 0: a// 1: b// length: 2 10 Generator 函数Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。 两个特征: 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield语句，定义不同的内部状态 12345678910111213141516171819function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回的对象的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。 （3）如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 123456789function* f() &#123; console.log('执行了！')&#125;var generator = f();setTimeout(function () &#123; generator.next()&#125;, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。另外需要注意，yield语句不能用在普通函数中，否则会报错。 123456789101112131415161718var arr = [1, [[2, 3], 4], [5, 6]];var flat = function* (a) &#123; var length = a.length; for (var i = 0; i &lt; length; i++) &#123; var item = a[i]; if (typeof item !== 'number') &#123; yield* flat(item); &#125; else &#123; yield item; &#125; &#125;&#125;;for (var f of flat(arr)) &#123; console.log(f);&#125;// 1, 2, 3, 4, 5, 6 10.3 与Iterator接口由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。 12345678var myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被…运算符遍历了。 Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 10.4 next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。 123456789101112function* f() &#123; for(var i=0; true; i++) &#123; var reset = yield i; if(reset) &#123; i = -1; &#125; &#125;&#125;var g = f();g.next() // &#123; value: 0, done: false &#125;g.next() // &#123; value: 1, done: false &#125;g.next(true) // &#123; value: 0, done: false &#125; 上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。"},{"title":"ES6-2","date":"2019-02-23T03:00:12.000Z","path":"2019/02/23/ES6-2/","text":"5 函数的扩展5.1 参数默认值在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 5.2 结合解构赋值参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 双重默认值函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。123456function fetch(url, &#123; method = 'GET' &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')// \"GET\" 5.3 函数的length属性length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 5.4 作用域如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的。即先是当前函数的作用域，然后才是全局作用域。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 123456789let x = 1;function f(y = x) &#123; let x = 2; console.log(y); console.log(x);&#125;f() // 1,2 函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量。 1234567let x = 1;function f(x = x) &#123; console.log(x);&#125;f() // x is not defined 函数foo的默认值x的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量x，但是默认值在x赋值之前先执行了，所以这时属于暂时性死区，任何对x的操作都会报错。 12345678var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3 函数foo的参数y的默认值是一个匿名函数。函数foo调用时，它的参数x的值为undefined，所以y函数内部的x一开始是undefined，后来被重新赋值2。但是，函数foo内部重新声明了一个x，值为3，这两个x是不一样的，互相不产生影响，因此最后输出3。 利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 5.5 rest参数ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 5.6 扩展运算符扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 1. 合并数组 12345678910111213141516// ES5[1, 2].concat(more)// ES6[1, 2, ...more]var arr1 = ['a', 'b'];var arr2 = ['c'];var arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 2. 与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []:const [first, ...rest] = [\"foo\"];first // \"foo\"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 5.6 name属性函数的name属性，返回该函数的函数名。 12function foo() &#123;&#125;foo.name // \"foo\" 如果将一个匿名函数赋值给一个变量，ES5的name属性，会返回空字符串，而ES6的name属性会返回实际的函数名。 1234567var func1 = function () &#123;&#125;;// ES5func1.name // \"\"// ES6func1.name // \"func1\" 如果将一个具名函数赋值给一个变量，则ES5和ES6的name属性都返回这个具名函数原本的名字。 1234567const bar = function baz() &#123;&#125;;// ES5bar.name // \"baz\"// ES6bar.name // \"baz\" 5.7 箭头函数123456// ES5var f = function(v) &#123; return v;&#125;;// ES6 var f = v =&gt; v; 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新(因为代码调用更新的不是timer的s2)。 5.8 绑定 thisES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 1234567foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments); 6 对象的扩展6.1 属性简写ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 1234567891011121314151617181920var foo = 'bar';var baz = &#123;foo&#125;;baz // &#123;foo: \"bar\"&#125;// 等同于var baz = &#123;foo: foo&#125;;// 如果属性名和参数名相同，可以简写function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 6.2 方法简写除了属性简写，方法也可以简写。 12345678910111213var o = &#123; method() &#123; return \"Hello!\"; &#125;&#125;;// 等同于var o = &#123; method: function() &#123; return \"Hello!\"; &#125;&#125;; 下面是一个实际的例子。 12345678910111213var birth = '2000/01/01';var Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; CommonJS模块输出变量，就非常合适使用简洁写法。 123456789101112131415161718192021var ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 如果某个方法的值是一个Generator函数，前面需要加上星号。 12345var obj = &#123; * m()&#123; yield 'hello world'; &#125;&#125;; 6.3 定义对象ES6 允许字面量定义对象 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 表达式还可以用于定义方法名。 1234567let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 6.4 对象新方法1. Object.is()ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 12345678910Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 2. Object.assign() Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 1234567var target = &#123; a: 1 &#125;;var source1 = &#123; b: 2 &#125;;var source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 注意点 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 12345var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。 （1）为对象添加属性 12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; （2）为对象添加方法 12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ...&#125;;SomeClass.prototype.anotherMethod = function () &#123; ...&#125;; （3）克隆对象 123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; （4）合并多个对象 12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); 6.5 原型属性1. proto属性 用来读取或设置当前对象的prototype对象。 123456789// es6的写法var obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es5的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; 2. Object.setPrototypeOf() Object.setPrototypeOf方法的作用与proto相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。 12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 3. Object.getPrototypeOf() 该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。 1234567891011function Rectangle() &#123;&#125;var rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false 6.6 Object一些方法1. Object.keys() ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 123var obj = &#123; foo: \"bar\", baz: 42 &#125;;Object.keys(obj)// [\"foo\", \"baz\"] 2. Object.values() Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。123var obj = &#123; foo: \"bar\", baz: 42 &#125;;Object.values(obj)// [\"bar\", 42] 3. Object.entriesObject.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 123var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ [\"foo\", \"bar\"], [\"baz\", 42] ] 除了返回值不一样，该方法的行为与Object.values基本一致。 6.6 对象的扩展运算符1. 解构赋值 解构赋值要求等号右边是一个对象 解构赋值必须是最后一个参数，否则会报错。 1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 2. 扩展运算符 123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 6.7 对象属性的描述对象ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。 12345678var obj = &#123; p: 'a' &#125;;Object.getOwnPropertyDescriptor(obj, 'p')// Object &#123; value: \"a\",// writable: true,// enumerable: true,// configurable: true// &#125; ES7有一个提案，提出了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 7 symbol使用了一个他人提供的对象，想为这个对象添加新的方法，新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的，这样就从根本上防止了属性名冲突。这就是ES6引入Symbol的原因 它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 123let s = Symbol();typeof s Symbol函数前不能使用new命令，否则会报错。Symbol值不是对象，所以不能添加属性 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 12345678910let firstName = Symbol();let person = &#123;&#125;;person[firstName] = \"666\";person.firstName =\"777\";console.log(person[firstName]); // 666console.log(person.firstName); // 777console.dir(person)//fiestName:\"666\"// Symbol(): \"huochai\"//__proto__:Object 7.1 参数区分Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678var s1 = Symbol('foo');var s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // \"Symbol(foo)\"s2.toString() // \"Symbol(bar)\" 上面代码中，s1和s2是两个Symbol值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 1234567891011// 没有参数的情况var s1 = Symbol();var s2 = Symbol();s1 === s2 // false// 有参数的情况var s1 = Symbol('foo');var s2 = Symbol('foo');s1 === s2 // false 7.2 类型转换Symbol值不能与其他类型的值进行运算，会报错。 123456var sym = Symbol('My symbol');\"your symbol is \" + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 但是，Symbol值可以显式转为字符串。 1234var sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 另外，Symbol值也可以转为布尔值，但是不能转为数值。 12345678910var sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 7.3 作为属性名由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性 1234567891011121314151617var mySymbol = Symbol();// 第一种写法var a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法var a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法var a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" Symbol值作为对象属性名时，不能用点运算符。 123456var mySymbol = Symbol();var a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // \"Hello!\" 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol值。 在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中 7.4 Symbol.for()Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。 12345Symbol.for(\"bar\") === Symbol.for(\"bar\")// trueSymbol(\"bar\") === Symbol(\"bar\")// false Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345var s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"var s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined"},{"title":"ES6","date":"2019-02-19T01:46:25.000Z","path":"2019/02/19/ES6/","text":"ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 1. 定义变量1.1 letES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。let 具有几个特点如下 1. 不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 12345console.log(foo); // 输出undefinedconsole.log(bar); // 报错ReferenceErrorvar foo = 2;let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 2. 代码块内有效 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效 for循环的计数器，就很合适使用let命令。 123456789101112for(let i = 0;i&lt;10;i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0)&#125;// 会输出0-9for(var i = 0;i&lt;10;i++)&#123; setTimeout(function() &#123; console.log(i); &#125;,0)&#125;// 会输出10个10 3. 暂时性死区 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 但是如果代码块内没有声明，还是会去上一层找变量12345let tmp = 123;if (true) &#123; console.log(tmp);// 123&#125; 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 4. 不允许重复声明 let不允许在相同作用域内，重复声明同一个变量。 1234567891011121314151617181920// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 1.2 块级作用域 场景一内层变量可能会覆盖外层变量。 1234567var tmp = new Date();function f() &#123; console.log(tmp);&#125;f() // Tue Feb 19 2019 10:31:10 GMT+0800 (中国标准时间) 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = \"hello world\"; &#125;&#125;f(); // undefined 上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 场景二用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 1234567var s = 'hello';for (let i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); //i is not defined 1.3 constconst声明一个只读的常量。一旦声明，常量的值就不能改变。 1. 不可变(地址不可变) 对于简单数据类型来说const不可以改变 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。 1234567const foo = &#123;&#125;;foo.prop = 123;foo.prop// 123foo = &#123;&#125;; // TypeError: \"foo\" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 同理对于数组类型1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 2. 声明必赋值对于const来说，只声明不赋值，就会报错。12const foo;// SyntaxError: Missing initializer in const declaration 1.4 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 12345678window.a = 1;a // 1var a = 2;window.a // 2let b = 1;window.b // undefined 一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性； 另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性 2. 解构赋值ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 2.1 数组解构以前，为变量赋值，只能直接指定值 123var a = 1;var b = 2;var c = 3; ES6允许写成下面这样。 1var [a, b, c] = [1, 2, 3]; 这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 1234567891011121314151617181920212223242526272829let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [\"foo\", \"bar\", \"baz\"];third // \"baz\"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // \"a\"y // undefinedz // []let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 对于Set结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set([\"a\", \"b\", \"c\"]);x // \"a\" 2.2 默认值解构赋值允许指定默认值。 12[x, y = 'b'] = ['a']; // x='a', y='b'[x, y = 'b'] = ['a', undefined]; // x='a', y='b' 如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。12345var [x = 1] = [undefined];x // 1var [x = 1] = [null];x // null 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 因为x能取到值，所以函数f根本不会执行 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 2.3 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 不将大括号写在行首，避免JavaScript将其解释为代码块(在大括号两侧加（）解决)如果变量名与属性名不一致 1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 如果变量名与属性名一致 123var &#123; foo, bar &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\" 变量不能重新声明 12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration \"foo\"let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration \"baz\" 嵌套赋值 1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 2.4 字符串的解构赋值字符串被转换成了一个类似数组的对象,然后再进行解构同理，任何对象进行解构赋值都是转换成一个类似数组的对象，再进行赋值123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 3 字符串扩展3.1 字符串是否包含 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 includes()可以直接放到if中12345678910var s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // trues.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 3.2 字符串重复repeat方法返回一个新字符串，表示将原字符串重复n次。 12345'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\"` 参数如果是小数，会被取整1'na'.repeat(2.9) // \"nana\" 如果repeat的参数是负数或者Infinity，会报错。1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。 1'na'.repeat(-0.9) // \"\" 参数NaN等同于0。1'na'.repeat(NaN) // \"\" 如果repeat的参数是字符串，则会先转换成数字。12'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\" 3.3 字符串补全ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。12345678'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba''xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，则会用空格补全长度。 12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' 3.3 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量var name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 123456789101112var x = 1;var y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// \"1 + 2 = 3\"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// \"1 + 4 = 5\"var obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// 3 模板字符串之中还能调用函数。 123456function fn() &#123; return \"Hello World\";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 4 数组的扩展4.1 Iterator接口 Iterator接口的目的就是为所有数据结构提供一种统一访问的机制，用for…of实现。 一个数据结构只要有Symbol.iterator属性，就可以认为是“可遍历的” 原型部署了Iterator接口的数据结构有三种，具体包含四种，分别是 数组 类似数组的对象 Set Map 字符串是一个类似数组的对象，也原生具有Iterator接口。 还有几个别的场合。 解构赋值 扩展运算符(…) 123456789101112131415161718192021222324//创建一个构造函数function Obj(value)&#123; this.value=value; this.nnext=null;&#125;// 添加iterator接口Obj.prototype[Symbol.iterator]=function()&#123; var iterator=&#123;next:next&#125;; var self=this; function next()&#123; if(self)&#123; var value=self.value; var done=self.next===null; self=self.next; return &#123; value:value, done:done &#125;; &#125;else&#123; return &#123;done:true&#125;; &#125; &#125; return iterator;&#125; 一个为对象添加Iterator接口 12345678910111213141516171819let obj = &#123; data: [ 'hello', 'world' ], [Symbol.iterator]() &#123; const self = this; let index = 0; return &#123; next() &#123; if (index &lt; self.data.length) &#123; return &#123; value: self.data[index++], done: false &#125;; &#125; else &#123; return &#123; value: undefined, done: true &#125;; &#125; &#125; &#125;; &#125;&#125;; 4.2 转换数组Array.from方法用于将类对象转为真正的数组 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 用扩展运算符也可以1234567// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] （…）和Array.from区别 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 扩展运算符（...）也可以将某些数据结构转为数组。 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。 任何有length属性的对象，都可以通过Array.from方法转为数组 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] Array.from处理数据 Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组DOM节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 字符串长度 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; 4.3 一组值转换为数组Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 Array()和Array.of Array方法没有参数、一个参数、三个参数时，返回结果都不一样。 只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。 参数个数只有一个时，实际上是指定数组的长度。123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 4.4 成员复制数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 12345678910111213141516171819202122232425// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// Array.from(&#123;length: 5, 3: 1&#125;)// [undefined, undefined, undefined, 1, undefined]// 第3个位置是1，当道第0位[1, undefined, undefined, 1, undefined]// call改变this是对象，所以返回的也是对象&#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 4.5 数组查找find() 用于找出第一个符合条件的数组成员参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 找出数组中第一个小于0的成员。12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 find方法的回调函数可以接受三个参数，依次为 当前的值 当前的位置 原数组。 找出第一个大于9的成员123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 findIndex()findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 4.6 填充数组fill方法使用给定值，填充一个数组。 对于空数组，fill方法用于空数组的初始化。 对于数组中已有的元素，会被全部抹去。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 4.6 数组便利ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象，可以用for…of循环进行遍历， keys()是对键名的遍历 values()是对键值的遍历 entries()是对键值对的遍历 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 4.7 数组包含Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。 123[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, NaN].includes(NaN); // true 第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。12345678[3, 2, 1].includes(3, 0); // true[3, 2, 1].includes(3, 1); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 4.8 回顾ES5中数组方法 2个索引方法：indexOf() 和 lastIndexOf()； 5个迭代方法：forEach()、map()、filter()、some()、every()； 2个归并方法：reduce()、reduceRight()； 索引方法 索引方法包含indexOf()和lastIndexOf()两个方法，这两个方法都接收两个参数， 第一个参数是要查找的项， 第二个参数是查找起点位置的索引，该参数可选，如果缺省或是格式不正确，那么默认为0。两个方法都返回查找项在数组中的位置，如果没有找到，那么返回-1indexOf()：该方法从数组的开头开始向后查找。12345var dataArray = [1, 7, 5, 7, 1, 3];console.log(dataArray.indexOf(7)); // 1 从第一项开始查找console.log(dataArray.indexOf(7, 's')); // 1 格式不正确, 从第一项开始查找console.log(dataArray.indexOf(7, 2)); // 3 从第三个项之后开始查找console.log(dataArray.indexOf (2)); // -1 未找到, 返回-1 lastIndexOf()： 该方法从数组的末尾开始向前查找12345var dataArray = [1, 7, 5, 7, 1, 3];console.log(dataArray.lastIndexOf (7)); // 3 从末尾第一项开始查找console.log(dataArray.lastIndexOf (7, 's')); // 3 格式不正确, 从末尾第一项开始查找console.log(dataArray.lastIndexOf (7, 2)); // 1 从末尾第三项往前查找console.log(dataArray.lastIndexOf ('4')); // -1 未找到, 返回-1 迭代方法 这些方法都接收两个参数， 第一个参数是一个函数，他接收三个参数， 数组当前项的值 当前项在数组中的索引 数组对象本身。 第二个参数是执行第一个函数参数的作用域对象，也就是上面说的函数中this所指向的值。 注意，这几种方法都不会改变原数组。 every()该方法对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回true。123456789var dataArray = [1, 7, 5, 7, 1, 3];var result = dataArray.every(function(item,index,arry)&#123; return item&gt;1;&#125;)console.log(result)//falsevar result = dataArray.every(function(item,index,arry)&#123; return item&gt;0;&#125;)console.log(result)//true some()该方法对数组中的每一项运行给定函数，如果该函数对任何一项返回 true，则返回true。some方法会在数组中任一项执行函数返回true之后，不在进行循环。12345var dataArray = [1, 7, 5, 7, 1, 3];var result = dataArray.some(function(item,index,arry)&#123; return item &gt; 5;&#125;)console.log(result)//true filter()该方法对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。利用这个方法可对数组元素进行过滤筛选。 12345var dataArray = [1, 7, 5, 7, 1, 3];var result = dataArray.filter(function(item,index,arry)&#123; return item &gt; 3;&#125;)console.log(result)//[7, 5, 7] map()该方法对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。 我们为数组中的每一项乘以3，返回每一项相乘之后的数组。12345var dataArray = [1, 7, 5, 7, 1, 3];var result = dataArray.map(function(item,index,arry)&#123; return item* 3;&#125;)console.log(result) // [3, 21, 15, 21, 3, 9] forEach()该方法对数组中的每一项运行给定函数。这个方法没有返回值。这个方法其实就是遍历循环，和for循环没有太大差别。 12345678910var dataArray = [1, 7, 5, 7, 1, 3];dataArray.forEach(function(item,index,arry)&#123; console.log(item,index)&#125;)// 1 0// 7 1// 5 2// 7 3// 1 4// 3 5 归并方法归并方法包含reduce()和reduceRight()两个方法，这两个方法都会迭代数组中的所有项，然后生成一个最终返回值。他们都接收两个参数， 第一个参数是每一项调用的函数，函数接受是个参数分别是 初始值 当前值 索引值 当前数组函数需要返回一个值，这个值会在下一次迭代中作为初始值。 第二个参数是迭代初始值，参数可选，如果缺省，初始值为数组第一项，从数组第一个项开始叠加，缺省参数要比正常传值少一次运算。 reduce()该方法从数组的第一项开始，逐个遍历到最后一项 1234567891011121314var dataArray = [1, 7, 5, 7, 1, 3];var sum = dataArray.reduce(function(prev,cur,index,array) &#123; console.log(prev,cur,index); return prev+cur;&#125;)console.log(sum);// 1 7 1// 8 5 2// 13 7 3// 20 1 4// 21 3 5// 24 设置了第二个参数，会多执行一次。123456789101112131415var dataArray = [1, 7, 5, 7, 1, 3];var sum = dataArray.reduce(function(prev,cur,index,array) &#123; console.log(prev,cur,index); return prev+cur;&#125;,2)console.log(sum);//2 1 0//3 7 1//10 5 2//15 7 3//22 1 4//23 3 5//26 reduceRight()就是从右到左，就不详细说了。"},{"title":"Jenkins","date":"2019-01-31T02:07:45.000Z","path":"2019/01/31/Jenkins/","text":"1 安装Jenkins1.1 什么是持续集成在软件工程中，持续集成（CI）是指将所有开发者的工作副本每天多次合并到主干的做法。Grady Booch 在1991年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。 解放了重复性劳动。 自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。 更快地修复问题。 持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。 更快的交付成果。 更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。 减少手工的错误。 在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。 减少了等待时间。 缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。 更高的产品质量。 集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。 1.2 什么是JenkinsJenkins是持续集成的一种解决方案。Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。 1.3 Jenkins前提条件Jenkins因为是java的项目，所以java的基本环境是必不可少的 配置JDK 配置Tomcate 配置Maven 下载Jenkins 下载正式版的最新版本就对了 1.4 启动JenkinsJenkins下载之后就是个jar包，对于这个我们熟悉，我们可以有两种启动方式 放入Tomcat中启动 用命令启动：java -jar jenkins.war 启动端口是80，这时候我们直接访问localhost:80 在启动过程中这里会生成一个uuid最为第一次登陆时的id同时它的存储目录在这里也被显示出来。如果是用java -jar启动项目，则把uuid复制出来即可然后一路下一步即可 2 配置Jenkins2.1 配置插件点击配置管理，进入插件管理如图所示进入后如图所示，分别为 可更新 可选择插件 已安装 高级 我们下载插件就需要点击第二个选项选择我们需要的插件 2.2 用户管理点击用户管理，进入用户管理页面 点击添加用户，可以添加用户信息并且添加用户 2.3 系统设置点击进入系统设置，如图所示 配置这两个地方 Jenkins的web服务地址 发送邮件的邮箱地址 这部分是验证邮箱可不否的测试其中上面配置的邮箱和这个邮箱必须保持一致 2.4 全局工具配置点击进入全局工具配置，这里我们主要配置JDK,Maven，Git JDKName配置的是在Jenkins中你的JDK叫什么名字（别名）JAVA_HOME配置的是JDK的路径 Git同样一个是别名，一个是路径 Maven同样一个是别名，一个是路径 3 Jenkins任务操作回到主页面，点击创建一个新的任务 输入任务名称，创建一个自由风格的任务 3.1 一般配置(General)这里可以设置整个项目的描述和构建后保存的包事件以及数量 丢弃旧的构建就是检测到新的版本之后把旧版本的构建删除 重复构建次数，表示从Git上拉取失败后尝试的次数 3.2 源码管理这里配置我们从哪拉取镜像 输入地址 点击添加用户名密码 添加后选择该用户名密码 3.3 触发器(Build Triggers)这里可以设置什么时候重新检查git，如果git更新了我们就重新构建，如果没更新就不重新构建 3.4 构建这里构建方式有多种，如果我们是Maven项目我们可以选择Maven然后选择Maven1这里是我们前面配置的Maven别名之后写Maven打包命令 clean package 当然在这里我们可以选择shell脚本执行命令 3.5 构建后这里我们先安装一个插件，如图所示 重启之后我们选择构建后如下 tomcat中我们也需要配置 4 服务管理 我们也可以添加发送服务失败需要发送到的邮箱"},{"title":"JS高级","date":"2019-01-20T10:57:31.000Z","path":"2019/01/20/JS高级 /","text":"1 JS是什么1.1 概论 解释执行：轻量级解释性的 语言特点： 动态（JAVA运行时编译成class，编译成CLASS后就不能更改，不过js是动态的可以随时更改） 头等函数（意味着函数是JS中的一等公民，函数会先执行，比如给变量赋值会被提升先执行） 执行环境：在宿主环境下运行（类似于Java在JVM中运行），浏览器只最常见的JS宿主环境，其次就是node环境 浏览器中JS组成： ECMAScrip：语法规范 变量，数据类型，类型转换，操作符 流程控制语句：判断，循环语句 数组，函数，作用于，预解析 对象，属性，方法，简单类型和复杂类型的区别 内置对象：Math，Data,Array，基本包装类型String，Number，Boolean BOM onload页面加载时间，window顶级对象 定时器 location,history DOM 获取页面元素，注册事件 属性操作，样式操作 属性属性，节点层级 动态创建元素 事件：注册事件的方式，事件的三个阶段（捕获，冒泡，执行），事件对象 1.2 浏览器工作原理浏览器的主要组件包括： 1. 用户界面 － 包括地址栏、后退/前进按钮、书签目录等，也就是你所看到的除了用来显示你所请求页面的主窗口之外的其他部分。 2. 浏览器引擎 － 用来查询及操作渲染引擎的接口。 3. 渲染引擎 － 用来显示请求的内容，例如，如果请求内容为html，它负责解析html及css，并将解析后的结果显示出来。 4. 网络 － 用来完成网络调用，例如http请求，它具有平台无关的接口，可以在不同平台上工作。 5. UI后端 － 用来绘制类似组合选择框及对话框等基本组件，具有不特定于某个平台的通用接口，底层使用操作系统的用户接口。 6. JS解释器 － 用来解释执行JS代码。 7. 数据存储 － 属于持久层，浏览器需要在硬盘中保存类似cookie的各种数据，HTML5定义了web database技术，这是一种轻量级完整的客户端存储技术 User Interface 用户界面，我们所看到的浏览器 Browser engine 浏览器引擎，用来查询和操作渲染引擎 *Rendering engine 用来显示请求的内容，负责解析HTML,CSS并把解析的内容显示出来 Networking 网络，负责发送网络请求 *JavaScript Interpreter（解析者） JavaScript解析器，负责执行JS代码 UI Backend UI后端，用来绘制类似组合框的弹出窗口 Data Persistence（持久化） 数据持久化，数据存储 cookie，HTML5中的sessionStorage 具体详解可以看这里(https://www.cnblogs.com/wjlog/p/5744753.html) 2 JS代码执行过程2.1 小案例我们看如下代码1234567var num = 10;function fn() &#123; console.log(num); num = 20;&#125;console.log(num);fn(); 这段代码会怎么输出？先输出10再输出还是10； 1234567var num = 10;function fn() &#123; console.log(num); var num = 20;&#125;console.log(num);fn(); 这段代码会怎么输出？先输出10再输出undefined； 为什么会这样，这就是JS的特性，定义变量提升 上面的代码可以这么写 123456789var num;function fn() &#123; var num; console.log(num); num = 20;&#125;num = 10;console.log(num);fn(); 2.2 JS过程说明JS运行分两个阶段 预解析 全局解析（所有变量和函数声明都会提前：同名的函数和变量函数的优先级高） 函数内部预解析（所有变量，函数和形参都会参与预解析） 预解析的内容包括 函数 形参 普通变量 执行 先预解析全局作用域，然后执行全局作用域中的代码在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码 3 JS面向对象3.1 什么是对象万物皆对象 对象是单个事物的抽象。 比如这个汽车，他就是一个对象 对象是一个容器，封装了属性和方法 比如汽车有颜色，这就是一个属性 比如汽车能开，这就是一个方法 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集 ES中把对象定义为：无序属性的集合，其属性可以包含基本值，对象或者函数 提示：每个对象都是基于一个引用类型创建的（比如汽车，泛指世界上所有汽车），这些类型可以是系统内置的原生类型，也可以是开发人员自己定义的类型。 3.2 什么是面向对象是过程形式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 是一种编程思想，它将真实世界的各种复杂关系抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息，处理数据，发出信息等任务。 因此，面向对象编程具有灵活，代码可复用，高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目。 面向对象与面向过程 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊 面向对象就是找一个对象，指挥得到结果 面向对象执行者转变指挥者 面向对象不是面向过程的替代，而是面向过程的封装面向对象的特点： 封装性 继承性 抽象（多态Animal animal = new Dog()） 3.3 封装对象123456789101112131415161718// 第一代传递每个属性function fn(name,age,subject,score) &#123; // ...执行代码&#125;var stu = &#123; name1:'zs', age:18, subject:'语文', score: 80, say : function() &#123; console.log(\"大家好，我是\"+this.name1) &#125;&#125;// 第二代直接传递对象function fn(stu) &#123; // ...执行代码&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 第一种方式创建对象var stu = &#123; name1:'zs', age:18, subject:'语文', score: 80, say : function() &#123; console.log(\"大家好，我是\"+this.name1) &#125;&#125;// 方法中的this，是调用这个方法的对象stu.say(); // 大家好，我是zs(stu掉的say方法，所以是ZS)var fun = stu.say;window.fun(); // 大家好，我是undefined(这次是window掉的，所以是undifind)// 第二种方式创建对象var stu = new Object();stu.name = \"zs\";stu.age = 18;stu.subject = \"语文\";stu.say = function() &#123; console.log(this.age);&#125;// 第三种方式创建对象function createStudent(name,age,subject,score) &#123; var o = new Object(); o.name = name; o.age = age; o.subject = subject; o.score = score; o.say = function() &#123; console.log(this.name) &#125; return o;&#125;// 第四种方式创建对象function Student(name,age,subject,score) &#123; this.name = name; this.age = age; this.subject = subject; this.score = score; this.say = function() &#123; console.log(this.name); &#125;&#125;// new的作用// 1. 在内存中创建一个空对象// 2. 让构造函数中的this，指向刚刚创建的对象// 3. 执行构造函数（一般情况下，通过this设置对象的成员）// 4. 返回对象var s1 = new Student(\"zs\",18,\"语文\",100);// 普通函数的调用，此时this是windowvar s2 = window.Student(\"ls\",19,\"数学\",100); 3.4 构造函数12345678910111213function Person(name,age) &#123; this.name = name; this.age = age; this.sayName = function() &#123; console.log(this.name) &#125;&#125;var p1 = new Person(\"Jack\",18)p1.sayName() // = Jackvar p2 = new Person(\"Mike\",18)p2.sayName() // = Mike 结构构造函数代码的执行Person和createStudent的不同之处 没有显示创建对象 直接将属性和方法都赋给了this对象 没有return语句 函数名使用的是大写的Person 而要创建Person实例，则必须使用new操作符。以这种方式调用构造函数会经历以下4步骤： 创建一个新对象 将构造函数的作用域赋值给新对象（因此this就指向了这个新对象） 执行构造函数中的代码 返回新对象 3.5 构造函数和实例对象 constructor使用构造函数的好处不仅仅在于代码的间接性，更重要的是我们可以识别对象的具体类型在每一个实例对象中都有一个constructor属性，该属性指向创建该实例的构造函数； 123console.log(p1.constructor === Person); //trueconsole.log(p2.constructor === Person); //trueconsole.log(p1.constructor === p2.constructor); //true instanceof对象的constructor属性最初是用来标识对象的类型的。但是，如果要检测对象的类型，还是使用instanceof操作符更可靠一些。 1234console.log(p1 instanceof Person); //trueconsole.log(p2 instanceof Person); //truevar arr = [];console.log(arr instanceof Array)// true typeoftypeof只能获取基本类型复杂类型通过typeof获取到的始终是object 总结： 构造函数是根据具体的事务抽象出来的抽象模板 实例对象是根据抽象的构造函数模板得到的具体实例对象 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数。 3.6 原型对象1234567891011121314function Person(name,age) &#123; this.name = name; this.age = age; this.type = \"human\"; this.sayName = function() &#123; console.log(this.name) &#125;&#125;var p1 = new Person(\"Jack\",18)var p2 = new Person(\"Mike\",18)// false p1的sayName和p2的sayName在内存中的位置不同console.log(p1.sayName === p2.sayName) 这段代码表面上看没有问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type和sayName都是一模一样的内容。每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成内存浪费。 123456789101112131415function Person(name,age) &#123; this.name = name; this.age = age; this.type = \"human\"; this.sayName = sayName;&#125;function sayName () &#123; console.log(this.name)&#125;var p1 = new Person(\"Jack\",18)var p2 = new Person(\"Mike\",18)// false p1的sayName和p2的sayName在内存中的位置不同console.log(p1.sayName === p2.sayName) 原型对象有一个属性prototype可以通过构造函数的原型对象，给对象增加成员 12345678910111213141516171819202122function Person(name,age) &#123; this.name = name; this.age = age;&#125;// 通过构造函数的原型对象，给对象增加成员Person.prototype.type = \"human\";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;// 所有对象可以共享 构造函数的原型对象中的成员var p1 = new Person(\"Jack\",18) p1.sayName();//Jackvar p2 = new Person(\"Mike\",18)p2.sayName();// Mike// trueconsole.log(p1.sayName === p2.sayName) // 每一个对象都有一个__proto__// 对象的__proto__指向了构造函数的prototypeconsole.log(p1.__proto__ === Person.prototype); // true 这意味着，我们可以把所有对象所需要共享的属性和方法直接定义在prototype对象上 任何函数都具有一个prototype属性，该属性是一个对象 构造函数的prototype对象魔人都有一个constructor属性，只想prototype对象所在函数 3.7 原型链 如果一个对象中没有这个属性或方法，JS会去它的原型中去找，如果还没有则去更上一级去找直到最父级null; 每当代码读取某个对象的某个属性时，都会执行一侧搜索，目标是给定名字的属性 搜索首先从对象实例本身开始 如果在实例中找到了具有给定名字的原型对象,则返回该属性的值。 如果没有找到，则继续搜所指针指向的原型对象，在原型对象中查找具有给定名字的属性 如果在原型对象中找到了这个属性，则返回该属性的值也就是说，我们在调用person1.sayName()的时候,会先后执行两次搜所。 首先，解释器会问：“实例persion有sayName属性吗？”答：“没有”。 然后，他继续搜所，再问：“persion1的原型有sayName属性吗？”答：“有”。 于是，他就读取那个保存在原型对象中的函数。 当我们调用persion2.sayName()时，将会重现相同的搜所过程，得到相同的结果。而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 123456789101112131415161718function Person(name,age) &#123; // 实例成员 this.name = name; this.age = age; this.sayName = sayName;&#125;Person.prototype.type = \"human\";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var p1 = new Person(\"zs\",18,\"男\");console.log(p1.toString());console.dir(p1);// 获取Persion的原型对象var o = p1.__proto__;console.log(o.__proto__); 把上诉代码进行修改，改成只在p1上进行修改属性 123456789101112131415161718function Person(name,age) &#123; // 实例成员 this.name = name; this.age = age;&#125;Person.prototype.type = \"human\";Person.prototype.sayName = function() &#123; console.log(this.name);&#125;var p1 = new Person(\"zs\",18,\"男\");// 不关心原型链，直接给对象增加一个test属性// 设置属性的时候，直接给对象本身增加一个type属性，即使原型对象上有也不去查找p1.type = \"humanp1\";var p2 = new Person(\"ls\",19,\"男\");console.log(p1.type) // humanp1console.log(p2.type) // human 3.7 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法都需要敲一遍Persion.prototype。为了减少不必要的输入，更常见的做法是用一个包含所有属性的方法的对象字面量来重写整个原型对象 123456789101112function Person(name,age) &#123; // 实例成员 this.name = name; this.age = age;&#125;Person.prototype = &#123; type: \"human\", sayName:function() &#123; console.log(this.name); &#125;&#125; 在该实例中，我们将Persion.prototype重置到了一个新的对象。这样做的好处是Persion.prototype为了添加成员更简单了，但是也会带来一个问题，那就是原型对象丢失了constructor成员所以，我们为了保持constructor的正确指向，代码如下： 12345678910111213141516function Person(name,age) &#123; // 实例成员 this.name = name; this.age = age;&#125;// 错误示例：如果要访问原型对象的成员，必须先设置原型对象，再使用构造函数创建对象// var p = new Person(\"ls\",18,\"男\")// p.sayName();// 注意：当重新设置构造函数的prototype，一定要重新设置constructor属性Person.prototype = &#123; constructor: Person, type: \"human\", sayName:function() &#123; console.log(this.name); &#125;&#125; 案例 求数组中所有数的和 12345678910Array.prototype.getSum = function() &#123; var sum = 0; for(var i = 0;i &lt; this.length;i++)&#123; sum += this[i]; &#125; return sum;&#125;var arr = [56,1,3,5]console.log(arr.getSum()); 字符串首字母大写 12345678910111213String.prototype.toUpper = function() &#123; // 1.获取第一个字符 // this[0] 有兼容性 // this.charAt(0) // this.substr(0,1); var first = this.charAt(0); // 2. 把第一个字符转换成大写 first = first.toUpperCase(); // 3. 获取其他字符串 return first + this.substr(1);&#125;console.log(\"name\".toUpper()); 3.8 面向对象案例 随机闪烁方块 方块对象(box.js) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 构造函数BOX// 属性// backgroubndColor// width// height// x// y// 方法// render 渲染// random 随机生成盒子的位置var _postion = \"absolute\";var _map = null;// var _div = null;function Box(options) &#123; // 为了options的属性不报错 options = options || &#123;&#125;; this.backgroundColor = options.backgroundColor || 'red'; this.width = options.width || 20; this.height = options.height || 20; this.x = options.x || 0; this.y = options.y || 0; // 这样保证每个div都是自己的div this._div = null;&#125;// 通过原型对象设置盒子对象的方法// 把盒子对象渲染到地图上Box.prototype.render = function(map) &#123; _map = map; // 动态创建div var div = document.createElement(\"div\"); this._div = div; _map.appendChild(div); // 设置样式 div.style.backgroundColor = this.backgroundColor; div.style.width = this.width + \"px\"; div.style.height = this.height + \"px\"; div.style.left = this.x + \"px\"; div.style.top = this.y + \"px\"; div.style.position = _postion;&#125;Box.prototype.random = function() &#123; if(!_map) return; this.x = Tool.getRandom(0,_map.offsetWidth/this.width - 1)*this.width; this.y = Tool.getRandom(0,_map.offsetHeight/this.height - 1)*this.height; this._div.style.left = this.x + \"px\"; this._div.style.top = this.y + \"px\";&#125;var box = new Box(); 生成随机数的类(tool.js) 1234567var Tool = &#123; getRandom: function(min,max) &#123; min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; &#125;&#125; 主函数123456789101112131415161718192021222324var map = document.querySelector(\".map\");// 生成10个盒子var arr = [];for(var i = 0;i&lt;10;i++)&#123; var r = Tool.getRandom(0,255); var g = Tool.getRandom(0,255); var b = Tool.getRandom(0,255); var box = new Box(&#123; backgroundColor:\"rgb(' \" + r + \"','\" + g + \"','\" + b + \"')\" &#125;); box.render(map); arr.push(box);&#125;random();// 定时生成随机盒子的位置setInterval(random,500)function random() &#123; arr.forEach(function(item) &#123; item.random(); &#125;)&#125; 3.9 继承1. 原型继承 基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法，即让原型对象等于另一个类型的实例 123456789101112131415function Person() &#123; this.name=\"zs\"; this.age=18;&#125;function Student() &#123; this.score = 10;&#125;// 原型继承 直接设置原型（考虑如何继承属性）Student.prototype = new Person();// 这样会改变Student的类型，所以需要重新设置Student的类型Student.prototype.constructor = Student;var s1 = new Student();var s2 = new Student();console.dir(s1.constructor); 原型继承存在问题 无法设置构造函数的参数 属性时通过原型继承的，原型上的成员都是共享的 2. 借用构造函数 基本思想：在子类型构造函数的内部调用超类型构造函数，通过使用apply()和call()方法可以在将来新创建的对象上执行构造函数 12345678910function Person(name,age) &#123; this.name = name; this.age = age;&#125;function Student(name,age,score) &#123; Person.call(this,name,age); this.score = score;&#125;var s1 = new Student(\"zs\",18,20); 3. 组合继承 原型继承+借用构造函数 基本思想：将原型链和借用构造函数技术组合到一起。使用原型链实现对原型属性和方法的继承，用借用构造函数模式实现对实例属性的继承。这样既通过在原型上定义方法实现了函数复用，又能保证每个实例都有自己的属性 1234567891011121314151617function Person(name,age) &#123; this.name = name; this.age = age;&#125;Person.prototype.sayHi = function() &#123; console.log(this);&#125;function Student(name,age,score) &#123; Person.call(this,name,age); this.score = score;&#125;Student.prototype = new Person();Student.prototype.constructor = Student;var s1 = new Student(\"zs\",18,20);console.dir(s1); 4 函数进阶4.1 函数的定义方式1. 函数声明 123function fn() &#123; &#125; 2. 函数表达式 123var fun = function() &#123; &#125; 3. new Function 12var fn = new Function(\"a\",\"b\",\"console.log(a + b)\");fn(5,6); 4.2 声明和表达式的区别 函数声明会提升，表达式(只提升var fn)不会提升 1234567891011// 函数声明fn() // 为空function fn() &#123; &#125;// 函数表达式fun(); // 报错var fun = function() &#123; &#125; 在if中的变量提升 在新版本的浏览器中可以根据条件定义函数 在新版本的浏览器中在条件语句中定义函数不会提升 但在老版本的ie中，条件语句中定义函数也会进行提升12345678910if(true)&#123; function fn() &#123; console.log(\"true\") &#125;&#125;else&#123; function fn() &#123; console.log(\"false\") &#125;&#125;fu(); // true 老版本需要这样写 1234567891011var fn;if(true)&#123; fn = function() &#123; &#125;&#125;else&#123; fn = function() &#123; &#125;&#125; 4.2 this 函数中的this window 方法中的this 调用方法的对象 构造函数中的this 通过构造函数创建的对象 事件处理函数中的this 触发事件的对象 定时器中性的function中的this window function中的this最终是由function调用时候决定的 123456789101112131415161718var o = &#123; name:\"zs\", say:function() &#123; console.log(this.name); &#125;&#125;var o2 = &#123; name : \"ls\", say:o.say&#125;o2.say(); // 输出的是lsvar fn = o2.say;fn(); // 输出的是空，因为这个等价于（window.fn）window的name属性就是空o.say.call(o2); // 输出的是ls，因为这里面的this被改成了o2 1. call 修改this指向，参数用，号分隔开 12345678910function fn(a,b) &#123; console.log(this); console.log(a+b);&#125;var o = &#123; name:\"zs\"&#125;fn.call(o,1,2); 2. apply 12345678910function fn(a,b) &#123; console.log(this); console.log(a+b);&#125;var o = &#123; name:\"zs\"&#125;fn.apply(o,[1,2]); 修改this指向，参数用数组包装起来 案例利用Math.max求数组的最大值Math.max接受的参数是用，号分割的一些数123456789var max = Math.max(5,6,1,9);console.log(max);var arr = [34,1,19,10];var max = Math.max.apply(Math,arr) // 这里不需要改变this所以还是指向本身console.log(max);console.log.apply(console,arr); // 效果等同于 console.log(34,1,19,10) 操作维数组 1234567891011121314151617181920var obj = &#123; 0:8, 1:7, 2:9, length:3&#125;;var o = &#123; name:\"zs\"&#125;;delete o.name; // 删除o中的name属性delete obj[\"0\"]; // 删除obj中0属性Array.prototype.splice.call(obj,0,2); // 利用数组的方法删除obj中0位置起2个Array.prototype.push.call(obj,15); // 利用数组的方法给obj中添加属性var arr = [1,2];console.log(arr.toString()); // 1,2 调用的是数组的toString方法console.log(Object.prototype.toString.call(arr)); // [object Array] 调用的是Object的toString方法 3. bind修改方法中的this1234567var o = &#123; name:\"zs\"&#125;;var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; &#125;.bind(o) 4.3 函数的成员1234567function fn() &#123; console.log(fn.name); //函数名称 console.log(fn.length); //形参个数 console.log(fn.arguments); //获取到实参 console.log(fn.arguments.callee); //就是当前的函数 console.log(fn.caller); //调用fn的函数&#125; arguments经常用于可变参数 自己写一个max最大值1234567891011121314151617function max() &#123; var max = arguments[0]; // 借用数组方法实现(arguments是一个伪数组) // Array.prototype.forEach.call(arguments,function(item) &#123; // console.log(item); // &#125;) for(var i = 1;i&lt;arguments.length;i++)&#123; if(max &lt; arguments[i])&#123; max = arguments[i]; &#125; &#125; return max;&#125;var m = max(1,2,3);console.log(m); 4.4 高级函数所谓的高级函数就是函数作为参数，或者函数作为返回值 1. 函数作为参数 数组的forEach循环 定时器setInterval 绑定事件addEventListener 排序sort 自定义排序规则（默认排序按字母排序）1234567891011var arr = [\"a\",\"s\",\"z\",\"c\"];console.log(arr.sort()); //[\"a\", \"c\", \"s\", \"z\"]var arr2 = [11,111,10,20,50];console.log(arr2.sort()); // [10, 11, 111, 20, 50]arr2.sort(function(n1,n2) &#123; return n1 - n2;&#125;);console.log(arr2); // [10, 11, 20, 50, 111] 2. 函数作为返回值 123456789101112// 100 + N// 1000 + Nfunction getSum(n1) &#123; return function(n2) &#123; return n1 + n2; &#125;&#125;var get1 = getSum(100);var get2 = getSum(1000);console.log(get1(1)); // 101console.log(get2(1)); // 1001 获取基本类型方法自定义类型不可以，因为所有自定义类型的toString()返回的都是[object object]1234567891011function getFun(type) &#123; return function(obj) &#123; return Object.prototype.toString.call(obj) === type; &#125;&#125;var isArray = getFun('[object Array]')var isObject = getFun('[object object]')console.log(isArray([]));console.log(isObject(&#123;&#125;)); 获取随机数，第一次随机获取，之后每次获取的数都和第一次一样12345678910111213function getRandom() &#123; var random = Math.random() * 10 + 1; return function() &#123; return random; &#125;&#125;var fun = getRandom();console.log(fun());console.log(fun());console.log(fun()); 4.5 闭包闭包可以在调试的Scope中看到可以通过打断点观察到正常函数在调用之后内存会释放资源，而闭包不会，因为它不知道还需要在什么地方需要调用 案例1 1234567&lt;ul id=\"ul\"&gt; &lt;li&gt;1111&lt;/li&gt; &lt;li&gt;2222&lt;/li&gt; &lt;li&gt;3333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt; &lt;li&gt;5555&lt;/li&gt;&lt;/ul&gt; 12345678var list = document.querySelectorAll(\"#ul li\");var len = list.length;for (var i = 0;i &lt; len;i++)&#123; var li = list[i]; li.onclick = function() &#123; alert(i); &#125;&#125; 这样无论点击那个弹出的都是最后一个 之前我们会给li设置一个属性来解决这个问题 123456789var list = document.querySelectorAll(\"#ul li\");var len = list.length;for (var i = 0;i &lt; len;i++)&#123; var li = list[i]; li.index = i; li.onclick = function() &#123; alert(this.index); &#125;&#125; 现在我们可以用闭包的方式来解决创建调用一个自调用函数 12345678910var list = document.querySelectorAll(\"#ul li\");var len = list.length;for (var i = 0;i &lt; len;i++)&#123; var li = list[i]; (function(index) &#123; li.onclick = function() &#123; alert(i); &#125; &#125;)(i)&#125; 案例21234567console.log(111)for (var i = 0;i &lt; 3;i++)&#123; setTimeout(function() &#123; console.log(i) &#125;,0)&#125;console.log(222) 这段代码输出顺序为：111》222》3》3》3先执行主线程之后再执行延时函数 123456789console.log(111)for (var i = 0;i &lt; 3;i++)&#123; (function(index) &#123; setTimeout(function() &#123; console.log(index) &#125;,0) &#125;)(i)&#125;console.log(222) 这段代码输出顺序为：111》222》0》1》0 案例3 1234567891011var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc:function() &#123; return function() &#123; return this.name; &#125; &#125;&#125;console.log(object.getNameFunc()()) 输出内容为 The Window因为window的name属性是空，但在开始定义了一个name变量，即是定义给window的name之后object.getNameFunc()返回了一个函数，再之后是window调用了这个返回的函数，故this是window，this.name是The Window。这里并没出现闭包 123456789101112var name = \"The Window\";var object = &#123; name: \"My Object\", getNameFunc:function() &#123; var that = this; return function() &#123; return that.name; &#125; &#125;&#125;console.log(object.getNameFunc()()) 输出内容为 My Object这里出现了闭包，调用的是object的name 案例4 按钮设置字体大小 123456789&lt;body&gt;hello world &lt;div id=\"box\"&gt; &lt;button data-size=\"12\" id=\"btn1\"&gt;字体12&lt;/button&gt; &lt;button data-size=\"14\" id=\"btn2\"&gt;字体14&lt;/button&gt; &lt;button data-size=\"16\" id=\"btn3\"&gt;字体16&lt;/button&gt; &lt;button data-size=\"18\" id=\"btn4\"&gt;字体18&lt;/button&gt; &lt;/div&gt;&lt;/body&gt; 1234567891011121314151617var btn1 = document.getElementById(\"btn1\");var btn2 = document.getElementById(\"btn2\");var btn3 = document.getElementById(\"btn3\");var btn4 = document.getElementById(\"btn4\");// 创建函数function makeSizer(size) &#123; return function() &#123; document.body.style.fontSize = size + \"px\"; &#125;&#125;btn1.onclick = makeSizer(bt1.getAttribute(\"data-size\"));// btn1.onclick = makeSizer(bt1.dataset[\"size\"]); 这是H5用法btn2.onclick = makeSizer(bt2.getAttribute(\"data-size\"));btn3.onclick = makeSizer(bt3.getAttribute(\"data-size\"));btn4.onclick = makeSizer(bt4.getAttribute(\"data-size\"));"},{"title":"WebApi2","date":"2019-01-14T12:45:14.000Z","path":"2019/01/14/WebApi2/","text":"3 BOM3.1 概念BOM是指浏览器对象模型浏览器的对象模型提供了独立于内容的，可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象 比如：刷新浏览器，后退，前进，在浏览器中输入URL等 window是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window 我们定义的变量都是基于windows的 123456var abc=\"123\";function fn() &#123; console.log(\"fn\")&#125;console.log(window.abc)window.fn(); 注意：window下一个特殊的属性window.name无法被改变window对象本身具有name和top两个属性，其中top属性是只读 3.2 对话框 alert() 弹出确定 prompt() 弹出是否 confirm() 弹出输入框 1234567891011121314151617181920212223242526272829303132//====================== JS最常用三种弹出对话框 ======================== //弹出对话框并输出一段提示信息 function ale() &#123; //弹出一个对话框 alert(\"提示信息！\"); &#125; //弹出一个询问框，有确定和取消按钮 function firm() &#123; //利用对话框返回的值 （true 或者 false） if (confirm(\"你确定提交吗？\")) &#123; alert(\"点击了确定\"); &#125; else &#123; alert(\"点击了取消\"); &#125; &#125; //弹出一个输入框，输入一段文字，可以提交 function prom() &#123; var name = prompt(\"请输入您的名字\", \"\"); //将输入的内容赋给变量 name ， //这里需要注意的是，prompt有两个参数，前面是提示的话，后面是当对话框出来后，在对话框里的默认值 if (name)//如果返回的有内容 &#123; alert(\"欢迎您：\" + name) &#125; &#125; 3.3 页面加载和关闭 页面加载完成后执行 onload 前面说过html是从上往下执行，如果把js写在hrad中，是获取不到页面中的元素的不过加上页面加载后执行的方法就不一样了，可以吧js放到任意位置 页面加载完毕指的是：DOM元素加载完毕，并且外部文件加载完毕12345// onload 页面加载完毕执行onload = function() &#123; var box = document.getElementById(\"box\"); console.log(\"box\")&#125; 页面关闭时执行 onunload 123onunload = function() &#123; console.log(\"再见\")&#125; 3.4 定时器 setTimeout()和clearTimeout()在指定的行描述到到之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒之后执行var timerId = setTimeout(function() &#123; console.log(\"Hello\")&#125;,1000)// 取消定时器的执行clearTimeout(timerId); setInterval()和clearInterval()定时调用函数，可以按照给定的事件周期调用函数 1234567// 创建一个定时器，1000毫秒之后执行var timerId = Interval(function() &#123; console.log(\"Hello\")&#125;,1000)// 取消定时器的执行clearInterval(timerId); 案例：十秒后可以点击按钮 123456789101112131415var btn = document.getElementById(\"btn\");var count = 10;var timerId = setInterval(function() &#123; count -- ; if(count &gt; 0)&#123; // 如果不到10秒，修改按钮上的数字 btn.value = \"同意(请继续阅读\"+count+\"秒)\"; &#125;else&#123; // 时间到了 btn.value = \"同意\"; btn.disabled = false; // 停止定时器 clearInterval(timerId); &#125;&#125;,1000) 5秒后跳转12345678910var timerId = setTimeout(function() &#123; // 5秒以后跳转 location.href = \"www.baidu.com\"&#125;,5000);console.log(timerId);var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; clearTimeout(timerId);&#125; 定时器是典型的异步编程：在主线程还没有结束是不会调用其他线程的方法 3.5 内存中数据存储 栈内存中的变量一般都是已知大小或者有范围上限的，算作一种简单存储 堆内存存储的对象类型数据对于大小这方面，一般都是未知的 这也是为什么null作为一个object类型的变量却存储在栈内存中的原因。 一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。 js中有四个基本类型的数据 字符串 数字 布尔 null/undifind 他们的存储如图所示 其他类型，如对象数组存储如下图 const定义的基本类型不能改变，但是定义的对象是可以通过修改对象属性等方法来改变的。 3.6 移动div .offsetLeft 左边距离 1234567891011121314151617181920// 1. 注册事件var btn = document.getElementById(\"btn\");var box = document.getElementById(\"box\");btn.onclick = function() &#123; // 2. 让BOX能往右移动 var timerId = setInterval(function() &#123; // 当前的left var current = box.offsetLeft; current +=8; // 3. 停到指定位置500 if(current &gt;=500)&#123; clearInterval(timerId); box.style.left = \"500px\"; return; &#125; box.style.left = current+\"px\"; &#125;,30)&#125; 3.7 location对象location对象是window对象下的一个属性，使用的时候可以省略window对象 location可以获取或者设置浏览器地址的URL 12345678910111213141516171819console.log(location) Location &#123;replace: ƒ, assign: ƒ, href: \"https://www.baidu.com/\", ancestorOrigins: DOMStringList, origin: \"https://www.baidu.com\", …&#125; ancestorOrigins: DOMStringList &#123;length: 0&#125; assign: ƒ () hash: \"\" host: \"www.baidu.com\" hostname: \"www.baidu.com\" href: \"https://www.baidu.com/\" origin: \"https://www.baidu.com\" pathname: \"/\" port: \"\" protocol: \"https:\" reload: ƒ reload() replace: ƒ () search: \"\" toString: ƒ toString() valueOf: ƒ valueOf() Symbol(Symbol.toPrimitive): undefined __proto__: Location location的几个方法 reload 重新加载 assign 跳转 replace 替换12345678910111213var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; // 有一个参数 // false 可能从缓存获取 F5 // true 强制从服务器获取页面ctrl+r（ctrl+F5） // location.reload(true); // 跳转 会记录历史 location.assign(\"http://www.baidu.com\") // 替换地址栏中的地址 不会记录历史 location.replace(\"http://www.baidu.com\")&#125; 3.8 history对象 back() // 后退 forward() // 前进 go() // 去哪页 go(-1): 返回上一页，原页面表单中的内容会丢失； history.go(-1):后退+刷新； history.go(1) ：前进 back(): 返回上一页，原页表表单中的内容会保留； history.back():后退 ； history.back(0) 刷新； history.back(1)：前进 后退1234var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; history.back();&#125; 前进1234var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; history.forward();&#125; 3.9 navigator对象Navigator 对象包含有关浏览器的信息。 userAgent 浏览器信息12navigator.userAgent\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\" 在浏览器发送请求的时候会发送给服务器 如果调成手机模式会给服务器发送手机信息，服务器再判断是手机来源从而提供手机页面（在NGINX中有说明） 3.9 offsetWidth和offsetLeft 12345&lt;body&gt; &lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112var box2 = document.getElementById(\"box2\");// 内容 + border + paddingconsole.log(box2.offsetWidth);console.log(box2.offsetHeight);// 获取的相对于offserParent的距离console.log(box2.offsetLeft);console.log(box2.offsetTop);// offsetParent 最近的脱离文档流的父元素，如果没有脱离文档流的父元素，就是bodyconsole.log(box2.offsetParent);console.log(box2.parentNode); 3.10 offset/scroll/client window相关宽高属性 window.outerHeight (窗口的外层的高度) 获取整个浏览器窗口的高度（单位：像素），包括侧边栏（如果存在）、窗口镶边（window chrome）和窗口调正边框。包含调试窗及浏览器边框 window.outerWidth (窗口的外层的宽度) 表示整个浏览器窗口的宽度，包括侧边栏（如果存在）、窗口镶边（window chrome）和调正窗口大小的边框。包含调试窗及浏览器边框 window.screen.width 声明了显示当前浏览器的屏幕的宽度，以像素计 window.screen.height 声明了显示当前浏览器的屏幕的高度，以像素计 offset oEvent.clientX是指鼠标到可视区左边框的距离。oEvent.clientY是指鼠标到可视区上边框的距离。 offsetWidth是指div的宽度（包括div的边框）offsetHeight是指div的高度（包括div的边框）offsetLeft是指div到整个页面左边框的距离（不包括div的边框）offsetTop是指div到整个页面上边框的距离（不包括div的边框） scrollTop是指可视区顶部边框与整个页面上部边框的看不到的区域。scrollLeft是指可视区左边边框与整个页面左边边框的看不到的区域。scrollWidth是指左边看不到的区域加可视区加右边看不到的区域即整个页面的宽度（包括边框）scrollHeight是指上边看不到的区域加可视区加右边看不到的区域即整个页面的高度（包括边框） clientWidth是指可视区的宽度。clientHeight是指可视区的高度。clientLeft获取左边框的宽度。clientTop获取上边框的宽度。 3.11 案例公共方法123456789101112131415// 获取鼠标在页面上的坐标function getPage(e)&#123; return&#123; pageX:e.clientX + getScroll().scrollLeft, pageY:e.clientY + getScroll().scrollTop &#125;&#125;// 获取页面滚出去的距离（处理兼容性）function getScroll() &#123; return&#123; scrollTop:document.documentElement.scrollTop || document.body.scrollTop, scrollLeft:document.documentElement.scrollLeft || document.body.scrollLeft, &#125;&#125; 拖拽弹出框 user-select:none CSS样式文本不能被选择 12345678&lt;div class=\"nav\"&gt; &lt;a href=\"javascript:;\" id=\"register\"&gt;注册信息&lt;/a&gt;&lt;/div&gt;&lt;div class=\"d-box\" id=\"d_box\"&gt; &lt;div class=\"hd\" id=\"drop\"&gt;注册信息（可拖拽） &lt;span id=\"box_close\"&gt;关闭&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425var d_box = document.getElementById(\"d_box\");var drop = document.getElementById(\"drop\");// 1. 鼠标在box中的头部按下的时候，计算鼠标在盒子中的坐标// 1.1 给头部注册鼠标按下的drop.onmousedown = function(e) &#123; e = e || event; // 1.2 计算鼠标在盒子中的坐标 = 鼠标在页面中的坐标 - 盒子在页面中的坐标 var x = getPage(e).pageX - d_box.offsetLeft; var y = getPage(e).pageY - d_box.offsetTop; // 鼠标在整个页面移动过程中，计算盒子在页面中的坐标 document.onmousemove = function(e) &#123; // 计算盒子在页面中的坐标 = 鼠标在页面上的坐标 - 鼠标在盒子中的坐标 var boxX = getPage(e).pageX - x; var boxY = getPage(e).pageY - y; d_box.style.left = boxX + \"px\"; d_box.style.top = boxY + 'px'; &#125;&#125;// 当鼠标弹起时，移除move事件document.onmouseup = function() &#123; document.onmousemove = null;&#125; 点击弹出拖拽登录框 window.innerWidth 页面的宽 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 1. 点击弹出登录框var link = document.getElementById(\"link\");var login = document.getElementById(\"login\")link.onclick = function() &#123; var login = document.getElementById(\"login\"); var bg = document.getElementById(\"bg\");&#125;// 2 拖拽// 2.1 鼠标按下var title = document.getElementById(\"title\");title.onmousedown = function(e) &#123; e = e || event; // 计算鼠标在盒子中的坐标 var x = e.pageX - login.offsetLeft; var y = e.pageY - login.offsetTop;&#125;// 2.2 鼠标移动document.onmousemove = function(e) &#123; e = e || event; // 计算盒子在页面上的坐标 var loginX = e.pageX - x; var loginY = e.pageY - y; // 控制盒子的移动范围 if(loginX &lt; 0 )&#123; loginX = 0; &#125; if(loginY &lt; 21)&#123; loginY = 21; &#125; // 如何获取页面和盒子的大小 // 盒子的大小 // login.offsetWidth // 页面的大小？ window.innerWidth if(loginX &gt; window.innerWidth - login.offsetWidth - 21)&#123; loginX = window.innerWidth - login.offsetWidth -21; &#125; if(loginY &gt; window.innerHeight - login.offsetHeigh)&#123; loginY = window.innerHeight - login.offsetHeight; &#125; login.style.left = loginX + 256 + \"px\"; login.style.top = loginY - 140 + \"px\";&#125;// 鼠标弹起，移除鼠标移动事件document.onmouseup = function() &#123; document.onmousemove = null;&#125; 放大镜 onmouseover和onmouseout 会有事件冒泡onmouseenter和onmouseleave 不会触发冒泡 123456789&lt;div class=\"box\" id=\"box\"&gt; &lt;div class=\"small\"&gt; &lt;img src=\"images/small.jpg\" width=\"350\" alt=\"\"/&gt; &lt;div class=\"mask\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"big\"&gt; &lt;img src=\"images/big.jpg\" width=\"800\" alt=\"\"/&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 0 获取所需要操作的元素var box = document.getElementById(\"box\");// 小盒子var smallBox = box.children[0];// 大盒子var bigBox = box.children[1];// 小照片var smallImg = smallBox.children[0];// 遮罩层var mask = smallBox.children[1];// 大图片var bigImg = bigBox.children[0];// 1 鼠标移动到小盒子上 显示遮盖的层 显示大图smallBox.onmouseover = function() &#123; mask.style.display = \"block\"; bigBox.style.display = \"block\";&#125;smallBox.onmouseout = function() &#123; mask.style.display = \"none\"; bigBox.style.display = \"none\";&#125;// 2 鼠标在小盒子中移动的时候，遮盖层跟着鼠标移动smallBox.onmousemove = function() &#123; e= e||event; // 获取鼠标在小盒子中的坐标 var x = getPage(e).pageX - box.offsetLeft; var y = getPage(e).pageY - box.offsetTop; // 让鼠标到mask中点 x -= mask.offsetWidth/2; y -+ mask.offsetHeight/2; // 控制x和y范围 x = x &lt; 0 ? 0 : x; y = y &lt; 0 ? 0 : y; var maxX = smallBox.offsetWidth - mask.offsetWidth; var maxY = smallBox.offsetHeight - mask.offsetHeight; x = x &gt; maxX ? maxX : x; y = y &gt; maxY ? maxY : y; mask.style.left = x + \"px\"; mask.style.top = y + \"px\"; // 3 显示对应的大图部分 // 计算大图的偏移量 // mask移动的距离/大图移动的距离 = mask最大能够移动的距离/大图片最大能移动的距离 // 大图片移动的距离 = mask移动的距离 * 大图片最大能够移动的距离 / mask最大能够移动的距离 // 大图片能够移动的最大距离 var bigMaxX = bigImg.offsetWidth - bigBox.offsetWidth; var bigMaxY = bigImg.offsetWidth - bigBox.offsetHeight; var bigImgX = x * bigMaxX/maxX; var bigImgY = y * bigMaxY/maxY; bigImg.style.left = -bigImgX + \"px\"; bigImg.style.top = -bigImgY + \"px\";&#125; 模拟滚动条 12345678&lt;div class=\"box\" id=\"box\"&gt; &lt;div class=\"content\" id=\"content\"&gt; 这里写文本信息 &lt;/div&gt; &lt;div class=\"scroll\" id=\"scroll\"&gt; &lt;div class=\"bar\" id=\"bar\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 0 获取元素var box = document.getElementById(\"box\");var content = document.getElementById(\"content\");var scroll = document.getElementById(\"scroll\");var bar = document.getElementById(\"bar\");// 1 根据内容大小计算滚动条// box的高度/content的高度 = bar的高度/scroll的高度// 整个内容的大小var barHeight = 0;if(content.scrollHeight &gt; box.offsetHeight)&#123; barHeight = box.offsetHeight / content.scrollHeight * scroll.offsetHeight;&#125;bar.style.height = barHeight + \"px\";// 2. 拖动滚动条// 2.1 鼠标在bar上按下的时候，计算鼠标在bar中的位置bar.onmousedown = function(e) &#123; e = e || event; // 鼠标在bar中的位置 var barY = getPage(e).pageY - bar.offsetTop - box.offsetTop; // 2.2 鼠标在页面中移动的时候，计算bar在父容器中的坐标 document.onmousemove = function(e) &#123; e= e || event; // bar在父容器中的位置 var y = getPage(e).pageY - barY - box.offsetTop; // 限制y不能越界 y = y &lt; 0 ? 0 : y; // bar最大能移动的距离 var barMaxY = scroll.offsetHeight - barHeight; y = y &gt; barMaxY ? barMaxY : y; bar.style.top = y + \"px\"; // 3. 当滚动条滚动的时候，移动内容 // bar移动的距离 / 内容移动的距离 = bar最大移动的距离 / 内容最大移动的距离 // 内容移动的距离 = bar移动的距离 * 内容最大移动的距离 / bar最大移动的距离 // 内容最大移动的距离 var contentMaxY = content.scrollHeight - box.offsetHeight; var contentY = contentMaxY / barMaxY; content.style.top = - contentY + \"px\"; &#125;&#125;// 当鼠标弹起的时候，移除移动的事件document.onmouseup = function() &#123; document.onmousemove = null;&#125; 3.12 动画12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var btn = document.getElementById(\"btn\");// 只生成一个div执行动画的定时器var timerId = null;btn.onclick = function() &#123; var box = document.getElementById(\"box\"); var box1 = document.getElementById(\"box1\"); animate(box,function() &#123; animate(box1); &#125;); // animate(box1);&#125;// 封装函数 只生成一个div执行动画的定时器(把定时器放到element中)function animate(element,callback) &#123; // 判断之前是否开启了定时器 if(element.timerId)&#123; clearInterval(element.timerId); &#125; // 让每一个执行动画的元素，记录自己的定时器 element.timerId = setInterval(function() &#123; // 目标位置 var target = 1000; // 当前坐标 var current = element.offsetLeft; // 进步 var step = 10; // 当当前位置&gt;目标位置step应该是负数 if(current &gt; target)&#123; step = - Math.abs(step); &#125; // 编码要避免硬编码 // if(current &gt;= 500) // 如果当前位置和目标位置的差小鱼step，就认为到达目标位置 if(Math.abs(current - target) &lt;= Math.abs(step))&#123; element.style.left = target + \"px\"; clearInterval(element.timerId); return; &#125; // 回调函数 if(callback)&#123; callback() &#125; current += step; element.style.left = current + \"px\"; &#125;,20);&#125;"},{"title":"mui","date":"2019-01-13T10:44:32.000Z","path":"2019/01/13/mui/","text":"0 简介0.1 dcloud企业国内HTML5产业的领军企业，W3C会员，DCloud面向HTML5行业分别推出了开发工具HBuilder、手机强化引擎5+ Runtime、跨平台前端框架mui、应用发行产品流应用，通过系列产品对HTML5的强化支持，使得HTML5能达到原生的功能和体验，同时在发行上更优于原生应用。mui是一套ui层框架，同时结合H5+技术进行混合开发的目的。同时dcloud也目前主打的uni-app，是一个使用 Vue.js 开发跨平台应用的前端框架，开发者编写一套代码，可编译到iOS、Android、H5、小程序等多个平台。不过目前这个网上资源还很少，也有许多坑，这个需要掌握一下几个技能 vue webpack 小程序掌握这几个之后上手会比较容易。有兴趣同学可以看一下官网。dcloudg官网这里还是说回来我们的mui0.2 下载HbuilderHbuilder是一个免费的开发工具，在官网上可以下载到 0.3 新建项目我们安装好后新建一个项目，选择如下 0.4 项目目录生成的项目结构如图所示： 可以看到，这个项目结构目录还是比较简单的，没有形成前端项目模块法开发，这里引用js还是&lt;script&gt;,并非模块化开发。我们的入口页面是index.html；manifest.json是打包配置文件。 0.5 真机调试我们有了初始代码，如何在手机APP调试呢？我们可以首先下载一个手机模拟器，我这里下载的是夜神模拟器。安装过程不必剁手了，之后DOC命令进入夜神模拟器bin目录下，输入命令： nox_adb connect 127.0.0.1:62001 adb devices 之后再Hbuilder目录下输入命令 adb connect 127.0.0.1:62001 这样在《运行》/ 《真机运行》下可以看到安卓模拟器，点击运行即可调试代码。 目前有个坑，每次保存完代码需要把模拟器中的APP关掉再打开 0.6 云打包 这里说的云打包就是把代码提交到云端然后在云端打包返回给我们一个APP安装包。点击《发行》/《APP云打包》，这里可以设置证书等打包的选项"},{"title":"产品设计2","date":"2019-01-07T12:36:13.000Z","path":"2019/01/07/产品设计2/","text":"4 交互设计4.1 交互概论回顾产品结构：基于前期的需求分析及市场竞品分析等为依据，将各个需求点以及某种逻辑系统化的组织起来所形成的立体结构。基于该结构，可以顺利的引导用户行为或将各类信息进行顺畅的流转 操作系统从最初的DOC系统&gt;win98&gt;winXP&gt;win7&gt;win8&gt;win10,从最初专业到普及就是交互设计的不断改进。 UI 用户界面 UE 用户体验 IXD 交互设计 什么是交互： 两个或多个互动的个体之间交流的内容和结构，使之互相配合，共同达成某种目的。交互设计就是让用户在使用产品或服务的过程保证可用性，提高易用性。 交互设计是一种使得产品易用，有效的把人使用产品的过程变得愉悦的技术。它致力于把握目标用户和他们的期望，分析“人”本身的心里和行为特点，设计或改善用户在同产品交互时彼此的有效行为，和各种有效的交互方式，并对他们进行增强和扩充。 4.2 交互设计中的基本原则 用户心理现在有一把锁，从不同角度来看 用户： 眼中：钥匙眼+把手 心里：锁眼好找好用，把手舒服，向下开门 技工： 眼中：详细结构+精密连接 心里：研究它的材质，连接方式 符合用户的心里： 就是把本来很复杂的事情设计成符合用户日常生活中常用的浏览方式或操作方式；也可以理解为人性化设计 比如银行转账，在转账时会有历史记录，确保让用户在第一次转账正确后放心转账 西克法则 定律内容：一个人面临的选择（n）越多，所需要作出决定的时间（T）就越长 7+-2法则：人们短期记忆每次能处理5—9件事情，作为把导航菜单的元素限制在7个以内的依据，因此根据产品需要，尽可能减少用户的选择项目数。 接近法则线框内的元素特征 军事，社会，国际是新闻的类型 股票，基金，外汇是财经领域的一部分 并排放置的频道，都是相近类型 微信网页版，MAC版，WIN版只是同一产品的不同类型 聊天输入时，可能用语音，图片，表情，红包等功能 放置在一起因为他们都是聊天可输入的内容 防错原则 注销的二次确认是防止用户点击错误 复制验证码是防止用户验证码输入错误 防错原则认为：大部分的意外都是由设计的疏忽，而不是人为操作的疏忽。通过改变设计可以把过失降到最低 操作可预期 看到线框内的元素我们会有所预期： 我会支付一笔钱 我会进入一个商铺首页 比如我们点击倒三角形，我们的预期是下拉出更多内容 贴近认知 在国内前两个图表辨识度极高，第三个图表在国内辨识度不高。所以对于国内网站，尽量不要使用第三个图标 比如看视频，当点击播放时，画面一下子横置，这样就超出了用户基本认知和预期，降低了使用流畅度 7 状态可感知当用户读完新闻之后，要把新闻列表中读过的新闻灰掉，让用户知道自己处于什么状态了再比如进度条，当前位置，数据加载等 一致性图中方框部分头像方圆不统一，再有列表头像是可以点击，但是订阅列表页不可点击。 总结 好的交互让使用产品的过程更愉悦 好的交互有基本的原则可以轻易遵循 4.2 交互设计核心和步骤交互设计的核心任务 表达 使用界面语言向用户传递信息，进而实现人机交互 交互设计三步骤 概括待表达的信息，清理需求点 信息排序，需求点按照一定规则进行分类 界面语言翻译，画交互。 案例做一个新闻资讯客户端的官网 概括信息，列举需求 内容：形态包括文章，视频，突击 频道：推荐，财经，娱乐。。。 功能入口：登录，下载app，查看详情 运营位：编辑推荐，广告 界面形式突出视频及图片 排序，需求分类 频道：推荐，财经，娱乐… 内容：形态包括文章，视频，突击 功能入口：登录，下载app，查看详情 运营位：编辑推荐，广告 突出图 界面表达画出原型图，如图所示： 案例某直播工具产品定位：只给有直播权限的用户用于直播基本功能：登录，选择节目发起直播（节目在后台已配置好）补充信息：由于每个节目一个单独的直播流，所以若未终止直播，这个节目还可以进去续播（既意外断开或误操作等情况均可续播）需求：有场景用户需要临时发起直播，为这个功能设计交互流程 概括信息，列举需求 用户可以选择节目发起直播 用户可以临时发起直播 选择节目发起直播需要查看节目列表 临时发起直播需要配置基本信息 意外退出后登陆还可以续播 排序 用户可以选择节目发起直播？用户还可以发起临时直播 选择节目发起直播需要产看节目列表？ 临时发起直播需要配置基本信息？ 意外退出后登录还可以续播？ 重新梳理用户流程，完成设计 用户登录后，主要操作发起直播，次要操作修改信息；查询记录 发起直播会遇到两种选择 根据不同选择走不同流程 虽然设计之后流程增加的步骤，但是产品体验性更好 总结 交互设计的过程需要对用户需求进行充分的了解 信息的展示与流程的设置必须遵循基本的原则 4.2 交互 在大公司会有专业UI我们需要做的： 写交互需求，包含需求背景的描述，需求目标的描述，需求点的列举，或低保真原型图 与交互设计师面对面沟通 及时督促交互稿完成 确认交互稿 在小公司需要做的： 需求分析 需求点分类 界面输出 根据需求大小选择不同输出方式 与leader沟通 产品经理的交互图： 重点是表述你需要啥功能及其优先级 美观需求次之 简单快捷的方式输出（手工，PS，画板均可） 各个端交互差异 区别 PC端 移动端 页面结构的差异 PC端在页面横向信息量比较大;PC端纵向页面层次信息比较深;PC端可以在新标签打开 移动端遵循少即是多原则，剔除不必要的元素，页面层次不要太深 操作方式不同 鼠标键盘，输入更容易，操作更便捷； 手指输入需要减少输入，降低输入难度；有更多便捷的输入方式（语音）；不要轻易打断用户任务（不好返回首页） 应用场景不同 固定场景，适合重度使用产品 碎片化事件，产品体验要更轻；更关注网络状态及流量使用 总结 交互知识是产品经理的必备技能 不追求技巧，把握方向 5 原型与需求文档5.1 原型 什么是原型原型是交互设计师与PD,PM,网站开发工程师沟通的最好工具。而该块的设计在原则上必须是交互设计师的产物，交互设计师以用户为中心的理念会贯穿整个产品。利用交互设计师专业的眼光与经验直接导致该产品的可用性。 原型的本质 原型的本质是工具 工具的本质是用于完成工作提高效率 原型的分类 高保真VS低保真 低保真：利用线框图，把信息的组织架构通过图形的模式展示。 高保真：利用高功能性，高互动性完整的把用户的操作流程表现出来 纵向原型设计VS横向原型设计 纵向：能通过点击交互到更深的层次 横向：以切面的形式展现页面跳转 部分特殊需求，如对体验效果特别看重，或功能及其复杂需要拟定较好的高保真demo一遍技术实现后的对比 原型的工具 Axure 墨刀 sketch Mockplus 原型的方法 分析需求 了解功能分布 明确页面层级 绘制基本原型 操作校验原型 5.2 原型案例 直播 案例背景：主播在直播过程中，有以下几种情况会推出直播 不方便，需要关闭画面（如补妆） 主动退出，直播结束 意外退出（网络中断） 结束后的功能 生成回顾，完成直播地址的使用 继续留在原地址直播 用户需求 在需要时不结束直播，仅暂停直播画面 意外状态下，能尽快重新连接直播地址 生成直播回顾 功能 画面中止 直播流终止 回顾视频生成 页面层级 第一层级：直播过程的界面 第二层级：直播结束的界面 第三层级：重新连接直播的界面 下面是两个原型，比较两个原型不难发现 是否退出尽量只有是和否 返回列表之前放的位置太过隐蔽 分享应该是下一层级做的事情，如果在这一层级不明确是分享正在直播的地址，还是分享我结束直播后的视频 提示可以让更多用户生成回顾总结 原型是一个提高产品设计工作效率的工具 不同的需求使用不同要求的原型 5.3 需求文档PRD 重点描述一个新产品或现有产品改进的需求 核心：侧重的是对产品功能和性能等特性（即“产品需求”）的说明 作用： 指导开发 测试依据 后续存档 目标： 准确的描述需求，使得产品最终形态与预期温和 能够有效协助产品干系人（视觉，交互，页面，开发，测试）完成与预期吻合的产品 需求文档的结构 5.3 需求文档步骤 想需求 列特性 写初稿 补细节 想需求 不着急下笔，先想清楚需求 每份需求文档都是一个文字版的解决方案 想的内容： 项目核心需求是什么？ 解决用户的什么问题？ 主要功能逻辑有什么？ 回顾产品设计阶段的输出物 产品结构图 流程图 特性列表 列特性 理解需求后，列出解决方案中应包含的全部特性 特性点几个方面 功能特性 界面特性 性能要求 数据上报 写初稿根据上面的需求文档的结构图来写需求文档 需求背景及目标 需求背景作用 方便参与者了解需求 方便后续存档查阅 需求目标作用 写需求前再次审核需求 需求完成后校验需求 列特性列表 根据需求拆分特性点 拆分标准 按照内部逻辑（按照不同的功能模块，不同的页面进行拆分） 重要的部分单列特性 特性列表作用 明确需求模块 方便参与者理解需求并开发需求 主要逻辑 逻辑图灵活使用 复杂特性，流程图梳理逻辑 简单特性可以用文字描述 常用工具 Visio Edraw 逻辑图的作用 帮助梳理需求逻辑 减少细节遗漏 特性功能点 描述特性功能 流程细节描述 正常逻辑，异常逻辑 文案内容，性能需求（如发起操作后3S内有反馈） 交互图 特性功能描述的作用 开发测试最关键的依据 性能需求产品性能，实际上指的是产品的功能和质量两个方面在进行功能的需求撰写时，也需要关注产品本身的质量，如打开速度，崩溃率，并发能力，负载能力等 错误：这个应用跑得太慢，你能让他快起来吗？ 正确：系统内90%的业务操作必须在5秒内得到响应，系统必须支持100个并发用户 数据需求产品需求在完成时，都应该为最终的检验做好数据采集的工作标准为： 能验证本次任务目标的核心数据指标。 本次迭代中新增的主要功能的核心指标。 案例：需求的核心目标为提高用户留存率 统计存留率，对比上线前后数值 案例：本次更新的内容为金币商城，包含金币发放，兑换，商城物品展示，信息填写等功能 统计每日金币发放总量，用户量；兑换消耗金币量，用户量，兑换次数，不同物品兑换次数，按日统计 补细节 重读需求文档，补充未尽的细节 用挑剔的眼光看文档 检查需求描述，是否有歧义 检查用户场景是否全部覆盖到（主要看异常逻辑是否被覆盖） 假设自己是开发，能否用文档写出代码 5.4 好的需求文档好的需求文档： 能正确满足产品需求，逻辑清晰 所有需求及场景都应给出具体的解决方案描述 需求描述无歧义，易读 每个特性都有优先级 需求可验证 不给出无法验证的描述；需求可追踪 案例 用户登录（完备性） 示例： 非会员用户，点击登陆后提示，不可使用 会员用户，登陆后正常给出操作界面 存在问题： 非会员提示语是什么？ 会员登录是否会失败？ 失败场景有哪些？对应操作是什么？ 会员登录后，是否有其他应给出的提示？ 拖拽上传（无歧义） 示例： 用户拖拽上传 存在问题： 只能拖拽上传单个文件？ 用户拖拽到哪里？ 改正后： 用户拖拽文件or文件夹移动到QQ网盘主界面文件展示区（不包含功能操作区）空白处时，则自动将该文件or文件夹添加到上传列表中。 提示用户登录超时（可验证） 示例： 用户长时间登录不成功时，提示登录失败 存在问题： 长时间是多久 改正后： 用户在N秒内登录不成功时，提示登录失败。N请开发建议时长。 总结 需求文档时产品方案的进一步完善 需求文档及原型成为产品设计中最核心的一个过程 5.5 案例分析 需求背景及目标 背景： 参考会说话的tom猫，做一个会说话的X小狗 目标 流畅用户体验 实现基本互动玩法 第一版 存在问题 仅描述了过程，但不是真正的流程 相关角色无法根据需求准确实现 改进思路 想：需求给谁看？需求目标是什么？ 列：主要特性有哪些？用户主要操作及反馈是啥？ 写：启动逻辑图 补：根据逻辑图补充细节描述 修改后： 总结： 需求往往很简单 准确的表述需求并不简单 思考关键用户流程，设计合理信息流转路径 文档的细节是否完善，直接影响产品设计工作的后续进程 什么时候需要些需求文档 外包型项目：由于产品开发团队使用团队分离，为了更好地确保交付后没有疑义所有内容最好用文档形式保存 复杂的产品：逻辑功能复杂业务参与方式较多均建议使用文档形式展示需求 什么时候不需要需求文档 一句话需求（但也需要存档） 简单逻辑需求且公司有敏捷项目管理系统 6 产品研发过程管理6.1 项目管理及研发流程项目管理是管理学的一个分支学科，对项目管理的定义是：指在项目活动中运用专门的知识，技能，工具和方法，是项目能够在有限资源限定条件下，实现或超过设定的需求和期望的过程。 开发模式 瀑布开发 概念：最典型的预见性的方法，严格遵循预先计划的需求分析，设计，编码，集成，测试，维护的步骤顺序进行 常见：外包项目 迭代开发（每个版本都有预期） 概念：是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率 常见：互联网项目（微信需要迭代） 螺旋开发 概念：瀑布模块和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。“螺旋模型”刚开始规模很小，当项目被定义得更好，更稳定时，逐渐开展。 常见：火箭的研制 敏捷开发 概念：是一种从1990年开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力 常见：互联网开发（先抢占市场） 常见开发模式对比 瀑布，迭代，螺旋开发都是一种软件开发的生命周期模型 敏捷开发是多种软件开发项目管理方法的集合 敏捷开发是一种防范，迭代开发是一种开发模型 敏捷开发 互联网项目多以敏捷开发为主。 敏捷开发的核心理念就是以简单有效的方式快速达成目标，并在这个过程中及时的响应外界的变化，做出迅速的调整。 适合小团队，技术产品磨合较好的团队 可以去文档，但要有存根 6.2 产品开发全流程管理项目主流程图 需求准备 需求分析 个人完成前期的分析初步的结论 需求讨论 小团队协助需求解决方案的PK及优化建议，是个人完成方案的优化及确认 交互讨论 交互协助或产品个人输出形成初步原型 需求评审 多角色参与需求的最终确认 需求评审会需求评审会是由产品经理介绍相应的产品功能背景以及初步的设计方案（交互稿），由大家针对现有的方案进行PK，直至讨论出统一的结果的过程。开会目标 明确项目目标 让大家都能初步了解方案的核心 通过会议讨论让大家对方案达到基本认可 会议要点 求同存异：不要驶入把观点植入到其他人的脑中（只要大家主要方向一致，不要在意细节） 放过细节：不纠结在细节中，学会妥协会后跟进（前端或者后端实现的问题不要再会上深入讨论） 人人参与：保证与会着都明确目标及方案 把握时间：控制会议时长提高效率（最好控制在1小时内，2小时会议可以拆分两次） 评审会内容 参与方：设计，后端，前端，运营 介绍背景：评审方案细节 目标：要做到什么程度 规划时间 怎么做：技术分工要讨论 为什么：讨论得最终方案 评审会黄金72小时 提前3天确定哪个版本，哪些人，在哪开会 提前2天发交互原型，需求文档 提前1天收集对评审问题并初步解答 会议控制 总分总的方式进行解说 时刻铭记目标 从特性列表到原型再到交互 细节解纷时及时跳出回归问题本质 部分不重要细节会后再定 结束前将重点问题再次确认 会议总结 及时输出会议纪要 待跟进讨论问题明确到责任人 督促各岗位人员给出时间评估 最终将优化后的文档及原型同步给大家8.测试用例评审会 测试用例：示例 测试用例评审会意义：细化需求点，异常逻辑 没有测试用例怎么办： 需求文档尽可能完善 开发阶段 督促进度：确保发布时间，灵活使用站立晨会或日报 解决问题，确保产品与预期一致：讨论的结论及时同步测试 体验与测试 谁，什么时候体验：产品，功能实现了 谁，什么时候测试：测试，技术提测了 体验目标： 保障功能与预期一致 测试目标： 保障可用性 发布准备 产品层面 测试结果验收 客服手册 运营层面 发布渠道准备 用户通知 推广运营策略制定 产品验收 验收的目的 确保产品的基本功能与需求一致 确保产品能顺利发布 谁来验收？ 不同的公司流程会有不同的验收人 常见责任人，对应的产品经理 严格要求质量的项目，有专门的验收会 验收标准 可用性：是否与需求要求一致，用户可顺利完成操作 易用性：交互设计手否能否提高用户的使用率 验收方法 对比需求文档或测试用例进行操作 实际工作中，产品经理验收 产品经理不是bug发现者 测试与设计共同协助完成验收 客服手册 使用者：一切有可能需直接解答用户使用疑问的角色，如运营，客服 主要内容：产品基本情况，本次更新功能介绍，使用操作指南，可能的问题及统一答复 常用渠道 苹果应用商店 安卓：应用宝，360，百度，华为，小米 。。。 产品经理的渠道相关工作 渠道包管理，渠道包验证 渠道介绍文案，图片 关注渠道下载量，关注渠道评论，渠道引流效果评估 用户通知 那些需要发布用户通知 影响基础服务的需要发布 影响用户操作的需要发布 如何发用户通知（需要提前发） 弹窗 小黄条通知 运营推广 判定本次发布内容的重要程度 战略性发布：大范围推广，目标新老用户 功能性优化：老用户重点推广 小优化：简单告知 需要产品经理做什么 准备运营需要的设计图 提前申请广告位 与运营同事沟通外部渠道 内部渠道确认，用户群，合作产品入口，用户通知系统 运营预期管理 发布留守 在产品发布时，产品经理，技术，客服等相关岗位均需至少留守一小时 确保服务稳定 观察用户使用情况，及时作出反应 协助解答可能引起的客服诉讼 一般情况发布时间会选择下班前1-2小时 回滚 什么情况需要回滚 新功能不能正常使用 新功能的发布引起其他关键功能不能使用 Bug修复时间不可预期 用户投诉极其强烈 避免回滚 预期管理,预测到可能的影响面，是否可以承受 测试完整，功能测试及性能测试尽可能完善 技术实现方案尽可能不要耦合 汇报 项目需要，任何事都要有始有终 领导需要安全感 团队需要鼓励 检验目标，是否达成基本预期 存在感 组织影响力 汇报内容 过程总结：是否如期完成，是否顺利，时间评估是否准确等 结果总结：是否达成预期 资源使用情况总结：技术，设计，运营资源 数据总结： 用户量，使用量，收入，成本 效果总结：用户反馈，市场反馈 上线邮件 告知：什么？多长时间？做了什么？ 感谢：相关领导，技术，设计，测试等同事 总结：基本情况小结 跟进：告知后续跟进计划 数据汇报 汇报时间：3天，7天，第一个月 汇报方式：邮件 汇报内容：基本数据表现，与预期是否一致，数据波动原因，可以继续提高数据的运营措施。 筛选反馈 已知BUG问题：用心回复 已知需求问题：评估优先级，是否需要提高 未知BUG问题：立刻联系用户或重现，改进 未知需求问题：需求分析 反馈跟进 普通用户个别问题，若不重要暂时不规划，若与原规划一致，则自然解决 普通用户普遍问题，需认真评估优先级，资源限制导致无法完成可向上及时求助 特殊用户个人问题，区分需求或bug；需求，区分其真实诉求；bug，建议尽快修改 特殊用户普遍问题，需求，尽可能完成，bug，立刻修改。 特殊用户是要么影响你的资源，要么影响你的口碑，只要不是完无理的要求，我们需用积极的态度去服务特殊用户 7 风险及沟通管理7.1 风险管理风险管理是指如何在项目或者企业一个肯定有风险的环境里把风险可能造成的不良影响减至最低的管理过程 风险不能被预防，但我们也要朝着绝对避免发生而努力意义：完成既定目标 风险识别 风险评估 风险评价 风险管理 案例: 场景：某公司，产品经理在老板授意下开始启动X项目，简单沟通未经评审就开始技术投入。技术团队共计投入2年经验后台人员一个，3个月经验毕业生前段一个。预计7日完成项目。暂无完整测试人力投入，待项目完成后视其他项目进行而定测试。 风险识别： 方案论证不够 目标不明确 老板需求随时变更 前端技术能力风险 版本发布质量问题 风险评估： 方案论证不够 由于未评审，该风险较大 目标不明确 由于未评审，该风险较大 老板需求随时变更 根据老板性格判断 前端技术能力风险 看方案，看个人能力，有可能有风险 版本发布质量问题 看方案复杂程度，有可能有风险 风险管理： 方案论证不够 深刻理解需求并组织评审会 目标不明确 目标以邮件方式分别与老板及团队确认 老板需求随时变更 方案拟定后与老板再沟通，邮件确认基本目标 前端技术能力风险 及时报备技术领导监控过程 版本发布质量问题 调配测试到位以保证版本发布质量 7.2 风险管理方法 预期管理 合理的背景分析 理性的市场预估 风险提前预判 获得领导确认 案例：领导预期过高怎么办 判断领导预期的真实性 多问，尝试换角度去问 资源分析 让领导意识到资源不够 过程风险管理 合理工作评估量 项目节点 需求优先级 减少不重要需求 案例：要发生需求变更怎么沟通？ 明确原因？技术的，市场的,老板的，产品的 技术：积极减少不必要的需求 市场：反馈上级，获得支持后积极调整 老板：明确必要性，适度调整 产品：自我检讨，保障项目顺利进行 风险发生后管理 根据情况适当调整发布时间 及时与关键岗位沟通（老板，运营，运维） 及时复盘总结 案例 背景：自研开发周期长，外部产品已有现成功能约定指定时间完成，结果对方需求理解有误。不能如期完成。 调整：重新明确需求，与领导沟通，与对方沟通。 教训： 合作项目，做什么一定要明确，文档化。 外包项目前期沟通要仔细。 7.3 沟通技巧 沟通的目的 说明事物 表达情感 建立关系 进行企图 沟通工具 文件（需要存档的内容） 审批内容 评审内容 评审结论 需求定稿 聊天工具（不紧急阶段性内容） 聊天讨论 资料传输 咨询 破冰 电话（紧急沟通内容） 急需决策 紧急故障 就等不回 距离远说不清 面谈（复杂内容） 文字表达难 重要事件 距离很近 拉近关系 各个阶段沟通重点 需求阶段 明确需求目标 明确时间点，里程碑 明确产品方向 开发阶段 明确每日进展 明确开发难度 减少需求变更 多体验保证需求预期 发布阶段 运营支持沟通 数据反馈沟通 用户沟通 不同角色沟通 领导 问题： 领导一般会说把那个功能进度加快， 做一个XX产品，照着XX那样就行。 XXX老板反映说我们产品他用了几分钟就崩溃了你查一下 解决： 多问+你的理解+确认 凡是有交代，件件有着落，事事有回音 定期主动汇报，邮件，面谈，信息技术 问题 技术A:性格好，技术一般，从不挑剔需求，勤勤恳恳 技术B：火爆男，技术牛，怼你没商量 技术C：墨迹哥，任何细节都和你确认，不确认不开发 技术D：自认产品感一流，自信满满做需求。 解决 对技术A： 对技术B：对我们帮助最大，多多虚心交流请求 对技术C：把需求文档写仔细，减少他耽误我们时间 对技术D： 测试 问题 测试人员普遍性质，思维严密，谨慎，一般不多言 解决 邀请测试人员参加需求评审会 及时向测试人员同步需求 设计师 问题 这个配色多好看啊，你审美有问题吧，我改不了 我不觉得这个按钮小呀，那么大，而且我们老大都通过了 解决： 尊重 引导，控制 运营 问题（和运营的合作关系是双向的） 他给你提需求，但是经常被说需求不靠谱 给他提需求，但是可能做的结果不够好 解决： 共同的目标 方案把关,保持沟通 成果共享 合作需求方 问题： 他们可能是任何部门的同事 也可能是外部公司的需求方执行者 会占用你的资源或是需要你对结果负责 解决： 明确需求及目标 沟通结果要记录 预期管理 下级沟通 问题 可能是毕业生一无所知 可能是老油条深谙职场心机 更可能是在专业和管理都不如你的一个普通员工 解决 信息尽可能对称 帮助总结，监督进度 对事不对人 表扬在人前，批评在人后 建立有效的沟通机制 定期沟通机制 会议：例会，评审会，头脑风暴会，资源协调会 日报/周报/月报 邮件：上线汇报，数据反馈，会议纪要，活动分析等 非正式沟通 小范围聚餐 午餐时间聊天 团队磨合上要注意 尽可能统一判断的标准（如一切以用户价值为依据） 不要试图说服，而是找到中和点 充分理解没每个角色的内心真实想法 7.3 产品经理和项目经理 主要工作 工作背景 主要负责 目标 角色 产品经理 想 复合人才 规划 结果 产品的爸爸 项目经理 做 技术背景 实现 过程 产品的保姆 产品经理与项目经理如何合作 产品对实现细节负责 项目对实现过程负责 提前沟通提前规划 明确目标合理妥协"},{"title":"WebApi","date":"2019-01-07T05:45:04.000Z","path":"2019/01/07/WebApi/","text":"0.介绍0.1介绍浏览器提供的一套操作浏览器功能和页面元素的API（BOM和DOM）MDN-Web API 0.2组成结构 ECMAScript-JavaScript的核心定义了javaScrip的语法规范javaScrip的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM浏览器对象模型一套操作浏览器功能的API通过BOM可以操作浏览器窗口，比如：弹出窗，控制浏览器跳转，获取分辨率等 DOM文档对象模型一套操作页面元素的APIDOM可以把HTML看作是文档树，通过DOM提供的API可以对树上的节点进行操作 DOM1.1 DOM概念文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。DOM是一种基于树的API文档，他在处理过程中整个文档都加载到内存中。DOM文档树模型如下 文档：一个网页可以成为文档 节点：网页中的所有内容都是节点（标签，属性，文本，注释等） 元素：网页中的标签 属性：标签的属性 DOM经常进行的操作 获取元素 对元素进行操作（设置其属性或调用其防范） 动态创建元素 事件（给元素绑定事件） 1.2 document获取标签HTML是从上向下加载，如果把js写在head中,在HTML还没有加载完全就去获取dom元素会找不到 console.dir(box) 输出对象 12345var box = document.getElementById('box');// 输出的是元素对应的标签内容console.log(box)// 打印对象console.dir(box) 获取对象类型两个方法 typeoftypeof不能获取对象的具体类型，获取对象类型始终返回object construction对象.construction可以获取到具体对象 根据id获取元素 123var div = document.getElementById('main');console.log(div)// 获取到的数据类型HTMLDivElement，对象都是有类型的 根据标签名称获取元素返回的是节点集合 12345var divs = document.getElementsByTagName('div');for(var i = 0;i &lt; divs.length;i++)&#123; var div = divs[i]; console.log(div)&#125; 根据name获取元素返回的是节点集合 12345var divs = document.getElementsByName('sex');for(var i = 0;i &lt; divs.length;i++)&#123; var div = divs[i]; console.log(div)&#125; 根据class获取元素返回的是节点集合这个是IE9以后才支持的（class是关键字，所以采用classname） 12345var divs = document.getElementsByClassName('sex');for(var i = 0;i &lt; divs.length;i++)&#123; var div = divs[i]; console.log(div)&#125; HTML5中获取元素在HTML5中新增的元素获取方法querySelector 查找一个元素，如果多个只返回第一个querySelector1234567891011121314// class=\"lover\"var div = document.querySelector('.lover')// 获取p元素var node = document.querySelector(\"p\");// 通过id属性取得元素var oBox = document.querySelector('#box');//通过属性选择器取得元素var oTest = body.querySelector('[title=\"test\"]');// 获取class=”lover” 的第一个p元素var node = document.querySelector(\"p.lover\");// 获取第一个带target属性的a元素var node = document.querySelector(\"a[target]\");// 获取第一个输入框var node = document.querySelector(\"input[type=text]\"); 查找多个元素querySelectorAll12345678//取得所有div元素var div = document.querySelectorAll(\"div\")//取得所有class为\"in\"的元素var oIn = document.querySelectorAll('.in');//取得title属性为test的元素var oTest = body.querySelectorAll('[title=\"test\"]');//取得body元素var body = document.querySelectorAll(\"body\")[0] 总而言之，这个方法相对于上面方法就是取多个 1.3 绑定事件事件的三要素： 事件源（谁能触发事件） 事件名称（怎么能触发，点击还是经过等） 事件处理函数 123456789// 获取超链接var link = documentById(&apos;link&apos;);// 注册事件link.onclick = function()&#123; alert(&apos;hello&apos;) // 取消后续内容的执行 return false; &#125;&#125; 案例 1234567891011121314151617181920// 1.获取元素var btn = document.getElementById('btn');var box = document.getElementById('box');// isShow记录box的显示和隐藏 true显示false隐藏var isShow = true;// 2.给按钮注册事件btn.onclick = function()&#123; // 当前box是显示的状态 if(isShow)&#123; // 3 控制div的显示隐藏（这里需要写一个class样式为隐藏） box.className = 'hidden' // 修改按钮上的文字 btn.value = '显示'; isShow = false; &#125;else&#123; box.className = 'show' btn.value = '隐藏'; isShow = true; &#125;&#125; 1.4 this 函数中的thiswindow对象 123function fn()&#123; console.log(this);&#125; 方法中的this调用该方法的对象 1234567var obj = &#123; name:'zs', say:function()&#123; console.log(this); &#125;&#125;obj.say(); 构造函数中的this当前对象 事件处理函数中的this触发事件的对象，事件源 案例 12345678910111213141516171819202122// 1.获取所有a标签对应的元素var imagegallert = documentById('imagegallery');var links = imagegallert.getElementsByTagName('a');// 2.给所有的a元素注册点击事件var i=0,len = links.length;for(; i&lt;len; i++)&#123; // 获取当前元素 var link = link [i]; link.onclick = function()&#123; // 3.切换图片和文字 var image = document.getElementById(\"image\"); var des = document.getElementById(\"des\"); // 设置图片这里触发事件的时候（被点击时）i已经是4了，所以需要用this // image.src = link.href; image.src = this.href; // 设置文字这里触发事件的时候（被点击时）i已经是4了，所以需要用this // des.innerText = link.title; des.innerText = this.title; // 取消默认行行为 return false; &#125; &#125; 1.5 innerHTML和innerText 获取标签之间的内容 innerHTML获取内容的时候，会把标签也获取到 innerText获取内容的时候会把标签过滤掉 设置标签之间的内容 innerHTML设置内容的时候，会把特殊字符进行标签化处理 innerText不会进行标签化处理 案例 123box.innerHTML = \"linjia&lt;b&gt;d&lt;/b&gt;&lt;p&gt;这是一个段落&lt;/p&gt;\"box.innerHTML = \"linjia&amp;lt;b&amp;gt;d&amp;lt;/b&amp;gt;&amp;lt;p&amp;gt;这是一个段落&amp;lt;/p&amp;gt;\"box.innerText = \"linjia&lt;b&gt;d&lt;/b&gt;&lt;p&gt;这是一个段落&lt;/p&gt;\" &lt; &lt; &lt; &gt; &amp;nbsp 空格 &copy; @ innerHTML 不是标准的DOM属性innerText 最早IE中增加的属性，老版本的firefox不支持此属性，老版本的firefox用的是textContent 案例写一个函数，处理innerText和textContent的兼容性问题123456789101112131415161718// 获取元素之间的内容function getInnerText(element) &#123; // 判断element是否支持innerText if(typeof element.innerHTML === \"string\")&#123; return element.innerHTML; &#125;else&#123; return element.textContent; &#125;&#125;// 设置元素之间的内容function setInnerText(element,content) &#123; // 判断element是否支持innerText if(typeof element.innerHTML === \"string\")&#123; element.innerHTML = content; &#125;else&#123; element.textContent = content; &#125;&#125; 1.6 表单元素属性 设置文本框中的内容 1234567891011121314151617181920212223242526272829303132// 1. 设置文本框中的内容var inputs = document.getElementsByTagName(\"input\");var i = 0,len = inputs.length;for(;i &lt;len;i++)&#123; // 获取集合中的元素 var input = inputs[i]; // 判断当前的input是否是文本框 if(input.type === \"text\")&#123; input.value = i + 1; &#125;&#125;// 2. 点击按钮获取文本框中的内容，并用|分割形成一个新的字符串var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; // 找到所有的文本框，获取文本框的值 var str = ''; // 定义数组，避免拼接字符串耗费性能 var arr = []; for (i = 0;i&lt;len;i++)&#123; var input = inputs[i]; // 判断是否是文本框 if(input.type !== \"text\")&#123; continue; &#125; // str += input.value + \"|\"; arr.push(input.value); &#125; // str = str.substr(0,str.length - 1); str = arr.join(\"|\"); console.log(str);&#125; 切换图片 1234567891011121314// 记录索引 默认是0var index = 0 ;// 1 给按钮注册事件var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; var img = document.getElementById(\"img\"); // 2 切换到下一张 index ++; img.src = arr[index]; // 3 如果是最后一张切换到第一张 if(index === arr.length - 1)&#123; index = -1; &#125;&#125; 检测用户名密码检验用户名是3-6位，密码是6-8位，如果不满足条件要求高亮显示 12345678910111213141516171819202122232425// 1 给登录按钮注册点击事件var btnLogin = document.getElementById(\"btnLogin\");btnLogin.onclick = function() &#123; // 检测用户名是否是3-6位，不满足要求高亮显示文本框 // 文本框对应元素 var texName = document.getElementById(\"name\"); if(texName.value.length &lt; 3 || texName.value.length &gt; 6)&#123; // 文本框高亮显示（这里需要先定义css） texName.className = 'bg'; // 阻止表单提交 return false; &#125;else&#123; texName.className = ''; &#125; // 3 密码是否是6-8位 不满足高亮显示 var texPwd = document.getElementById(\"pwd\"); if(texPwd.value.length &lt; 6 || texPwd.value.length &gt; 8)&#123; // 文本框高亮显示（这里需要先定义css） texPwd.className = 'bg'; // 阻止表单提交 return false; &#125;else&#123; texPwd.className = ''; &#125;&#125; 输入框默认值当文本框获得焦点的时候onfocus,如果文本框中的内容是《请输入搜索关键字》则清空文本框，设置黑色字体 onfocus 获得焦点事件 onblur 失去焦点事件 1234567891011121314151617181920212223// 提取公共方法function my$(id) &#123; return document.getElementById(id);&#125;var tXtSearch = my$(\"tetSearch\");// 当文本框获得焦点的时候tXtSearch.onfocus = function() &#123; // 判断当前文本框中的文字 if(this.value === \"请输入搜索关键字\")&#123; this.value = ''; this.className = ''; &#125;&#125;// 当失去焦点时候，如果文本框中的内容为空则设置文本框内容为《请输入搜索关键字》tXtSearch.onblur = function() &#123; // 判断当前文本框中的文字 if(this.value.length === 0)&#123; this.value = '请输入搜索关键字'; this.className = 'gray'; &#125;&#125; checkbox全选，反选 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. 点击全员按钮（父的checkbox）的时候，让子的checkbox的选中状态跟其保持一致var j_cbAll = document.getElementById(\"j_cbAll\");// 1.2 让所有的子checkbox的选中状态和父checkbox保持一致 var checkboxs = document.querySelectorAll(\"#j_tb input[type=checkbox]\"); var i = 0,len = checkboxs.length;j_cbAll.onclick = function() &#123; for (;i &lt; len;i++)&#123; // 获取每一个checkbox var checkbox = checkboxs[i]; // 让每一个checkbox的选中状态和父checkbox保持一致 checkbox.checked = this.checked; &#125; &#125;// 2. 给所有的子的checkbox注册点击事件，点击子的checkbox，如果有一个没被选中，则父checkbox也不被选中// 2.1 给所有的子checkbox注册点击事件for(i=0;i &lt; len;i++)&#123; // 获取每一个checkbox var checkbox = checkboxs[i]; // 注册点击事件 checkbox.onclick = function() &#123; // 2.2 如果有一个子的checkbox没有被选中，父的checkbox也不被选中 //假设所有子checkbox都被选中了 var isAllChecked = true; for(i = 0;i &lt; len;i++)&#123; // 获取每一个子的checkbox checkbox = checkboxs[i]; // 判断选中状态 if(!checkbox.checked)&#123; // 如果checkbox没有被选中，设置isAllChecked false isAllChecked = false; break; &#125; &#125; // 设置父checkbox的选中状态 j_cbAll.checked = isAllChecked; &#125;&#125;// 3. 反选// 3.1 给反选按钮注册点击事件document.getElementById(\"btn\").onclick = function() &#123; // 3.2遍历所有子的checkbox，对其进行反选 for(i = 0;i &lt; len;i++)&#123; // 获取每一个子的checkbox checkbox = checkboxs[i]; checkbox.checked = !checkbox.checked; &#125;&#125; 写到这里会有问题，当反选时无法控制父checkbox所以我们把父checkbox的方法单独拿出来，修改代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 1. 点击全员按钮（父的checkbox）的时候，让子的checkbox的选中状态跟其保持一致var j_cbAll = document.getElementById(\"j_cbAll\");// 1.2 让所有的子checkbox的选中状态和父checkbox保持一致 var checkboxs = document.querySelectorAll(\"#j_tb input[type=checkbox]\"); var i = 0,len = checkboxs.length;j_cbAll.onclick = function() &#123; for (;i &lt; len;i++)&#123; // 获取每一个checkbox var checkbox = checkboxs[i]; // 让每一个checkbox的选中状态和父checkbox保持一致 checkbox.checked = this.checked; &#125; &#125;// 2. 给所有的子的checkbox注册点击事件，点击子的checkbox，如果有一个没被选中，则父checkbox也不被选中// 2.1 给所有的子checkbox注册点击事件for(i=0;i &lt; len;i++)&#123; // 获取每一个checkbox var checkbox = checkboxs[i]; // 注册点击事件 checkbox.onclick = function() &#123; // 调用公共方法控制父checkbox singleChecked(); &#125;&#125;// 3. 反选// 3.1 给反选按钮注册点击事件document.getElementById(\"btn\").onclick = function() &#123; // 3.2遍历所有子的checkbox，对其进行反选 for(i = 0;i &lt; len;i++)&#123; // 获取每一个子的checkbox checkbox = checkboxs[i]; checkbox.checked = !checkbox.checked; &#125; // 调用公共方法控制父checkbox singleChecked();&#125;// 单独提炼出控制父节点方法function singleChecked() &#123; // 2.2 如果有一个子的checkbox没有被选中，父的checkbox也不被选中 //假设所有子checkbox都被选中了 var isAllChecked = true; for(i = 0;i &lt; len;i++)&#123; // 获取每一个子的checkbox checkbox = checkboxs[i]; // 判断选中状态 if(!checkbox.checked)&#123; // 如果checkbox没有被选中，设置isAllChecked false isAllChecked = false; break; &#125; &#125; // 设置父checkbox的选中状态 j_cbAll.checked = isAllChecked;&#125; 1.7 自定义属性 getAttribute() 获取标签内属性 setAttribute() 设置标签内属性 removeAttribute() 删除标签内属性 与element.属性的区别：上诉三个方法用于获取任意的行内元素 案例 1&lt;div id=\"box\" stuId=\"1\"&gt;张三&lt;/div&gt; 1234567891011121314151617181920212223var box = document.getElementById(\"box\");// 这个是无法获取stuId的值（undefined）【在IE中可以，但是在chrome中不可以】//console.log(box.stuId);// var o =&#123;&#125;；// console.log(o.a);// 当访问对象不存在的属性，返回undefined// 获取标签对应的自定义属性console.log(box.getAttribute(\"stuId\"));// 也可以获取标签本身具有的属性console.log(box.getAttribute(\"id\"));// 设置标签对应的自定义属性box.setAttribute(\"test\",\"hello\");// 也可以设置标签本身具有的属性box.setAttribute(\"class\",\"bg\");// 删除属性box.removeAttribute(\"test\");box.removeAttribute(\"class\");// 不可以设置标签的自定义属性（在浏览器标签中看不到），但是box对象本身具有了abc属性box.abc = \"hello\";console.log(box.abc); 1.8 操作样式 设置style仅仅是操作style的样式并不能改变class写好的样式 设置样式类（需要提前写class） 设置style 设置style.cssText 12345678910111213var box = document.getElementById(\"box\");// 1 设置类样式box.className = \"box\";// 2 设置style// console.dir(box);可以看到里面有style属性，并且style属性中是一个json，其中每个属性都是string类型box.style.width = \"200px\";box.style.height = \"200px\";box.style.backgroundColor = \"yellow\";// cssText 获取标签的style属性中的字符串// console.log(box.style.cssText)box.style.cssText = \"width:200px;height:200px\"; 案例:开关灯 document.body.style 1234567891011121314151617// 1. 给按钮注册事件var btn = document.getElementById(\"btn\");// 记录开关灯var isOpen = true;btn.onclick = function() &#123; if(isOpen)&#123; // 如果当前是开灯状态，关灯 // 2 修改body的背景颜色 document.body.style.backgroundColor = \"black\"; this.value = \"开灯\"; isOpen = false; &#125;else&#123; document.body.style.backgroundColor = \"\"; this.value = \"关灯\"; isOpen = true; &#125;&#125; 案例:鼠标经过显示二维码图片 鼠标经过的事件 onmouseover 鼠标离开事件 onmouseout 1234567891011121314// 获取nodeSmall注册事件 鼠标经过的事件 onmouseover 鼠标离开事件 onmouseoutvar node_small = document.getElementById(\"node_small\");// 鼠标经过显示二维码node_small.onmousemove = function() &#123; // 把class为hide替换成show document.getElementById(\"er\").className = document.getElementById(\"er\").className.replace('hide','show')&#125;// 鼠标离开隐藏二维码node_small.onmouseout = function() &#123; // 把class为show替换成hide document.getElementById(\"er\").className = document.getElementById(\"er\").className.replace('show','hide')&#125; 案例:移动方块 12345678910111213document.getElementById(\"btn\").onclick = function() &#123; var box = document.getElementById(\"box\"); box.style.width = \"200px\"; box.style.height = \"200px\"; // 改成绝对定位 box.style.position = \"absolute\"; box.style.left = \"200px\"; box.style.top = \"200px\"; box.style.backgroundColor = \"yellow\";&#125; 案例:输入框输入时高亮 .onfocus获得焦点 .onblur 失去焦点 1234567891011121314151617// 给所有的文本框注册事件 获取焦点的事件// 当文本框获得焦点之后 高亮显示 失去焦点 恢复var texts = document.querySelectorAll(\"input[type=text]\");var i = 0,len text.length;for(;i &lt; len;i++)&#123; var text = texts[i]; text.onfocus = function() &#123; // 高亮显示 this.style.backgroundColor = 'lightgray'; &#125; // 失去焦点 text.onblur=function() &#123; this.style.backgroundColor = ''; &#125;&#125; 案例:各行变色，鼠标放上变高亮 12345678910111213141516171819202122232425262728// 隔行变色 奇数red 偶数 green// 获取所有的livar list =document.querySelectorAll(\"#mv li\");var i = 0,len = lists.length;// 存储改变之前的背景var bg;for(;i &lt; len;i++)&#123; // 判断i是奇数还是偶数 if(i%2 === 0)&#123; // i是从0开始的，奇数行颜色 list[i].style.backgroundColor = 'red'; &#125;else&#123; list[i].style.backgroundColor = 'green'; &#125; // 鼠标放上显示高亮 list[i].onmouseover = function() &#123; // 鼠标放到li上高亮显示 bg = this.style.backgroundColor; this.style.backgroundColor = 'yellow'; &#125; // 鼠标离开不高亮 list[i].onmouseout = function() &#123; // 鼠标离开li还原原来的颜色 this.style.backgroundColor = bg; &#125;&#125; 案例:切换TAB 12345678910111213141516171819202122232425262728293031323334// 1. 鼠标放到tab栏上高亮显示，其他tab取消高亮显示// 1.1 获取hd中所有的span（标题栏中）。注册鼠标经过时间var spans = document.querySelectorAll(\"#hd span\")var i = 0,len = spans.length;for(;i &lt; len;i++)&#123; var span = spans[i]; // 注册事件 span.onmouseover = function() &#123; // 取消所有span的高亮显示 for(i = 0;i &lt; len; i++)&#123; spans[i].className = ''; &#125; // 1.2 高亮显示这个 this.className = 'current'; // 2 当tab栏高亮显示的时候。找到对应的详细内容显示，其他详细内容隐藏 // 2.1 给span记录索引 // 2.2 挡鼠标经过span的时候，获取span的索引 var index = parseInt(this.getAttribute(\"index\")); // 2.3 根据索引找详细内容的div显示其他的隐藏 var divs = document.querySelectorAll(\"#bd div\"); // 让所有的详细内容的div隐藏 var divLen = divs.length; for(i = 0;i&lt;divLen;i++)&#123; var div = divs[i]; div.className = \"\"; &#125; // 当前模块对应的div显示 divs[index].className = \"current\"; &#125;&#125; 1.9 节点操作想要构建如图所示的结构 元素节点 nodeName 标签的名称 nodeType 节点的类型 1 元素节点 nodeValue 当是元素节点的时候nodeValue始终是null 123456789101112131415// 元素节点var box = document.getElementById(\"box\");console.dir(box);// 元素节点// nodeName 标签的名称// nodeType 节点的类型 1 元素节点// nodeValue 当是元素节点的时候nodeValue始终是null//////////////////////////////////var attr = box.getAttributeNode(\"id\");console.dir(attr);// 属性节点// 获取属性节点// nodeName 标签的名称// nodeType 节点的类型 2 属性节点// nodeValue 属性的值 模拟DOM文档的结构 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 模拟DOM文档的结构// 属性 id className nodeName nodeType nodeValue// 构建构造函数function Node(options) &#123; // 当不传参的时候 options是undefined // 这样options.id会报错 // 给默认值 options = options || &#123;&#125;; this.id = options.id || \"\"; this.className = options.className || \"\"; this.nodeName = options.nodeName || \"\"; this.nodeType = options.nodeType || 1; this.nodeValue = options.nodeValue || null; // 设置一个属性记录子元素 this.children = [];&#125;// 1. html元素var html = new Node(&#123; nodeName:\"HTML\"&#125;);// 2. head元素var head = new Node(&#123; nodeName:\"HEAD\"&#125;);html.children.push(head);// 3. body元素var body = new Node(&#123; nodeName:\"BODY\"&#125;);html.children.push(body);// 4. div元素var div = new Node(&#123; id: \"box\", nodeName:\"DIV\"&#125;);body.children.push(div);// 5. p元素var p = new Node(&#123; id:\"p\", nodeName:\"P\"&#125;);body.children.push(p);console.dir(html); 获取子节点 childNodes 所有子节点 children 子元素 parentNode 父元素 12345678910111213var box = document.getElementById(\"box\");// 获取box中所有的子节点for(var i = 0;i &lt; box.childNodes.length;i++)&#123; // 便利所有的子节点，找到里面的元素nodeType === 1的是子元素 if(box.childNodes[i].nodeType === 1)&#123; console.log(box.childNodes[i]); &#125;&#125;// 获取子元素console.log(box.children);// 获取父元素console.log(box.parentNode); 获取第一个/最后一个节点 .firstChild 第一个子节点 .firstElementChild 第一个子元素 .lastChild 最后一个子节点 .lastElementChild 最后一个子元素 12345678910var ul = document.getElementById(\"ul\");// 获取第一个子节点console.dir(ul.firstChild);// 获取第一个子元素console.dir(ul.firstElementChild);// 获取最后一个子节点console.dir(ul.lastChild);// 获取最后一个子元素console.dir(ul.lastElementChild); 由于firstElementChild存在兼容性问题，我们可以自己封装一个方法来解决兼容性 12345678910111213function getFirstElementChild(parent) &#123; // 如果当前浏览器支持firstElementChild if(parent.firstElementChild)&#123; return parent.firstElementChild; &#125; // 否则用下面的办法 var node,nodes = parent.childNodes,i = 0; while (node = nodes[i++])&#123; if(node.nodeType === 1)&#123; return node; &#125; &#125;&#125; 获取兄弟节点 .nextSibling 下一个兄弟节点 .nextElementSibling 下一个兄弟元素 .previousSibling 上一个兄弟节点 .previousElementSibling 上一个兄弟元素 123456789// 获取下一个兄弟节点console.log(li.nextSibling)// 获取下一个兄弟元素console.log(li.nextElementSibling)// 获取上一个兄弟节点console.log(li.previousSibling)// 获取上一个兄弟元素(存在兼容性问题)console.log(li.previousElementSibling) 2.0 a标签href href=”javascript:void(0)” 这里有两部分首先是javascript表示我下面要说的都是用js来解析还有其他如下 javascript: 用js来解析 &lt;a href=&quot;javascript:void(0)&quot;&gt;首页&lt;/a&gt; http：下面是连接，连接跳转 &lt;a href=&quot;http://www.baidu.com&quot;&gt;首页&lt;/a&gt; mailto： 下面是邮箱 &lt;a href=&quot;mailto://xxx@xx.com&quot;&gt;首页&lt;/a&gt; tel： 下面是手机号码拨打电话（在手机上使用） &lt;a href=&quot;tel://00000&gt;首页&lt;/a&gt; void 关键字 void会执行（）里面的语句表达式，总是返回undefined就是什么都不做 12var r = void(1+2);console.log(r); 案例：高亮显示列表，并屏蔽a标签的点击事件 1234567891011121314151617// 获取menu中所有的avar menu = document.getElementById(\"menu\");// 获取第一个ul的方法有以下集中// menu.children[0]// menu.getElementsByTagName(\"ul\")[0];// menu.firstElementChild// 获取ulvar ul = menu.firstElementChild;var list = ul.children;// 遍历livar i = 0 ;len = list.length;for(;i &lt; len;i++)&#123; // 获取li中的a var link = list[i].firstElementChild; // 注册事件 linkClick后面不带小括号(表示吧方法传递过来，待括号表示把返回值传递过来) link.onclick = linkClick;&#125; 1234567891011// 事件处理函数function linkClick() &#123; // 取消所有li的高亮显示 for(i = 0;i&lt;len;i++)&#123; list[i].className = \"\"; &#125; // 当前a标签对应的li高亮显示 this.parentNode.className = \"current\"; return false;&#125; 2.1 document.write()把整个页面都重写，只剩下write中的内容 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 123456// 点击按钮var btn = document.getElementById(\"btn\");btn.onclick = function() &#123; // 如果在事件中使用document.write会把整个页面覆盖 document.write(\"新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;\")&#125; innerText具有兼容性问题，这里我们下一个函数，处理兼容性问题 12345678910111213141516171819// 获取元素之间的内容function getInnerText(element) &#123; // 判断element是否支持innerText if(typeof element.innerText === \"string\")&#123; return element.innerText; &#125;else&#123; return element.textContent; &#125;&#125;// 设置元素之间的内容function setInnerText(element,content) &#123; // 判断element是否支持innerText if(typeof element.innerText === \"string\")&#123; element.innerText = content; &#125;else&#123; element.textContent = content; &#125;&#125; 对比性能 第一种方法（循环innerHTML） console.time(&#39;flag&#39;)console.timeEnd(&#39;flag&#39;)查询开始到结束的时间 123456789101112131415console.time('flag')var box = document.getElementById(\"box\");var data = ['zs','ls','ww'];box.innerHTML = '&lt;ul&gt;'// 遍历数据生成lidata.forEach(function(item,index) &#123; // forEach遍历数组，参数是一个函数 // 这个函数有两个参数，第一个参数是数组中的元素，第二个参数是索引 box.innerHTML +='&lt;li&gt;'+item+'&lt;/li&gt;'; &#125;)box.innerHTML +='&lt;/ul&gt;'// 输出执行time和timeEnd之间代码所消耗的时间console.timeEnd('flag') 第二种方法(利用数组innerHTML) 12345678910111213console.time('flag')var box = document.getElementById(\"box\");var data = ['zs','ls','ww'];var arr = [];arr.push('&lt;ul&gt;')// 遍历数据生成lidata.forEach(function(item,index) &#123; arr.push('&lt;li&gt;'+item+'&lt;/li&gt;');&#125;)arr.push('&lt;/ul&gt;')box.innerHTML = arr.join(\"\");console.timeEnd('flag') 第三种方法(利用document.createElement) .removeChild() 移除元素 var r = confirm(“是否确定删除？”); .appendChild() 添加子节点 document.createElement 创建节点 下面我们实现一个表格Table123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 数据行中的数据var bodyData = [ &#123;name:'zs',subject:'语文',score：100&#125;, &#123;name:'ls',subject:'数学',score：80&#125;, &#123;name:'sdb',subject:'英语',score：0&#125;, &#123;name:'gw',subject:'体育',score：19&#125;, &#123;name:'bzr',subject:'数学',score：50&#125;,]// 表头数据var headData = [\"姓名\"，\"科目\",\"成绩\",\"操作\"]；// 1.表头var table = document.createElement(\"table\");document.getElementById(\"box\").appendChild(table);// 设置table样式table.border = \"1px\";table.width = \"500px\";table.cellSpacing = 0;var tead = document.createElement(\"tead\");table.appendChild(tead);var tr = document.createElement(\"tr\");tead.appendChild(tr);// 设置tr样式tr.style.height = \"50px\";tr.style.backgroundColor = \"lightgray\"// 生成表头中的列headData.forEach(function(item) &#123; var th = document.createElement('th'); tr.appendChild(th); th.innerText = item;&#125;)// 2. 数据行var tbody = document.createElement(\"tbody\");table.appendChild(tbody);// 设置数据行的内容居中tbody.style.textAlign = \"center\";// 遍历数据bodyData.forEach(function(item) &#123; // 创建行 // 便利对象 for(var key in item)&#123; var td = document.createElement(\"td\"); tr.appendChild(td); td.innerText = item[key]; &#125; // 操作的列 td = document.createElement(\"td\"); tr.appendChild(td); // 创建删除超链接 var link = document.createElement(\"a\"); link.href = \"javascript:void(0)\"; td.appendChild(link); link.innerText = \"删除\"; // 给link注册删除事件 link.onclick = linkClick;&#125;)// 事件处理函数function linkClick() &#123; // 提示 var r = confirm(\"是否确定删除？\"); if(r)&#123; // 删除 // 获取点击按钮所在的行 var tr = this.parentNode.parentNode; tbody.removeChild(tr); &#125;&#125; 测试3种方式 12345678910var d1 = +new Date();var arr = [];var str = \"\";for(var i = 0;i &lt; 1000; i ++)&#123; document.body.innerHTML += '&lt;div style=\"width:100px;height:2px:border:1px solid blue;\"&gt;&lt;/div&gt;';&#125;var d2 = +new Date();console.log(d2 - d1); 1234567891011var d1 = +new Date();var arr = [];var str = \"\";for(var i = 0;i &lt; 1000; i ++)&#123; arr.push('&lt;div style=\"width:100px;height:2px:border:1px solid blue;\"&gt;&lt;/div&gt;');&#125;document.body.innerHTML = array.join(\"\");var d2 = +new Date();console.log(d2 - d1); 123456789101112131415var d1 = +new Date();var arr = [];var str = \"\";for(var i = 0;i &lt; 1000; i ++)&#123; var div = document.createElement(\"div\"); div.style.width=\"100px\"; div.style.height = \"2px\"; div.style.border = \"1px solid red\" document.body.appendChild(div);&#125;document.body.innerHTML = array.join(\"\");var d2 = +new Date();console.log(d2 - d1); 2.2 操作节点 insertBefore(div1,div2) 在div2前插入div1removeChild(div) 删除div节点replaceChild(div1,div2) 把div2替换成div1 在ul中第三个位置之前插入li123456var ul = document.getElementById(\"ul\");var li = document.createElement(\"li\");li.innerText = \"测试\";ul.insertBefore(li,ul.children[2]) 替换元素1234var ul = document.getElementById(\"ul\");var div = document.createElement(\"div\");div.innerText = \"div\";ul.replaceChild(div,ul.children[0]); 删除ul中所有li 如果使用innerHtml=&quot;&quot;,不会删除元素身上的事件对应的函数，容易造成内存泄漏 12345var ul = document.getElementById(\"ul\");for(var i = 0.len = ul.children.length;i&lt;len;i++)&#123; var li = ul.children[i]; ul.removeChild(li);&#125; 案例：权限选择 &lt;select id=&quot;select&quot; multiple=&quot;multiple&quot;&gt; 这里还有第一点需要说明,循环document.get出list的时候，如果删除了其中一个。document.get的length会改变，里面的元素会重新创建索引，这时候在删除第二个（刚才删除第一个）实际上删除的是刚才的第三个 如果appendChild是其他地方的元素，在appendChild的同时原来的元素就没有了 1234567891011121314151617181920212223242526272829// 存放所有权限的列表var all = document.getElementById(\"all\");// 存放选中的权限列表var select = document.getElementById(\"select\");// 1.全选document.getElementById(\"bt1\").onclick = function() &#123; var i = 0,len = all.children.length; for(;i &lt; len ; i++)&#123; var li = all.children[0]; select.appendChild(li); &#125;&#125;// 2. 全不选// 3. 选择选中的选项document.getElementById(\"bt3\").onclick = function() &#123; for(i = 0;i&lt;len;i++)&#123; var li = all.children[i]; // 判断li是否选中 if(li.selected)&#123; select.appendChild(li) i --; &#125; &#125;&#125;// 4.移除选中的选项 2.3 注册事件注册事件的三种方式 onclick如果有一个元素两次onclick，第二次会覆盖第一次。 123456var box = document.getElementById(\"box\");box.onclick = function() &#123; console.log(\"点击后执行\")&#125;// 取消点击box.onclick = null; addEventListenner(W3C标准) box.addEventListener(“click”,eventCode,false) 第一个参数 事件名称（不带on） 第二个参数 事件处理函数 第三个参数 事件冒泡（false）/事件捕获（true） 123456789var box = document.getElementById(\"box\");box.addEventListener(\"click\",eventCode,false);// 取消点击box.removeEventListener(\"click\",eventCode,false);function eventCode() &#123; console.log(\"点击后执行\") console.log(this); // 这里的this是触发事件的对象&#125; attachEvent(IE9以前) 1234567var box = document.getElementById(\"box\");box.attachEvent(\"onclick\".enentCode);// 取消点击box.detachEvent(\"onclick\".enentCode);function eventCode() &#123; console.log(\"点击后执行\")&#125; 注册和移除事件处理兼容性问题 1234567891011121314151617181920// 注册事件function addEventListener(element,eventName,callback)&#123; if(element.addEventListener)&#123; element.addEventListener(eventName,callback,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(\"on\" + eventName,callback); &#125;else&#123; element[\"on\" + eventName] = callback; &#125;&#125;// 移除事件function removeEventListener(element,eventName,callback) &#123; if(element.removeEventListener)&#123; element.removeEventListener(eventName,callback,false); &#125;else if(element.attachEvent)&#123; element.detachEvent(\"on\" + eventName,callback); &#125;else&#123; element[\"on\" + eventName] = null; &#125;&#125; 2.4 事件流（冒泡/ 捕获）DOM标准采用捕获+冒泡。两种事件流都会触发DOM的所有对象，从document对象开始，也在document对象结束。事件的三个阶段/事件流 事件捕获阶段 目标阶段 冒泡阶段 冒泡型事件流：事件的传播是从最特定的事件目标到最不特定的事件目标。即从DOM树的叶子到根。【推荐】 捕获型事件流：事件的传播是从最不特定的事件目标到最特定的事件目标。即从DOM树的根到叶子 阻止事件冒泡 e.stopPropagation(); 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;Click me!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在冒泡型事件流中click事件传播顺序为&lt;div&gt;—》&lt;body&gt;—》&lt;html&gt;—》document在捕获型事件流中click事件传播顺序为document—》&lt;html&gt;—》&lt;body&gt;—》&lt;div&gt; 2.5 事件委托把本来应该li做的事情，转交给父元素来做（事件冒泡） 1234567var ul = document.getElementById(\"ul\");ul.onclick = function(e) &#123; // 当事件发生的时候，系统会把事件发生时候的一些数据传递给事件处理函数 // e事件对象（事件参数） // e.target 真正触发事件的对象 li e.target.style.backgroundColor = \"red\";&#125; 2.6 事件对象属性和方法 event.type 获取事件类型 clientX/clientY 所有浏览器都支持，窗口位置 pageX/pageY IE8以前不支持，页面未知 event.target||event.srcElement用于获取触发事件的元素 获取是什么事件触发的方法 1234567891011121314151617181920212223var box = document.getElementById(\"box\");box.onclick = fn;box.onmousemove = fn;box.onmouseout = fn;function fn(e) &#123; // e有兼容性问题，IE9以前不支持 // ie老版本获取事件对象的方式window.event // 处理兼容性问题 e = e || window.event; switch (e.type)&#123; case \"click\": console.log(\"点击事件\"); break; case \"mouseover\": console.log(\"鼠标经过\"); break; case \"mouseout\": console.log(\"鼠标离开\"); break; &#125; &#125; 案例：根据鼠标位置改变图片位置 这里有个坑，document.onmousemove和document.body.onmousemove的区别body有效范围是bodyn内部元素的范围，这里就是图片那么大的范围 clientX和clientY互殴的是鼠标在可视区域中的位置pagX和pagY获取的是在页面中的位置123456789101112var img = document.getElementById(\"img\");document.onmousemove = function(e) &#123; e = e || window.event; img.style.position = \"absolute\"; // img.style.left = e.clientX + \"px\"; // img.style.top = e.clientY + \"px\"; // 获取鼠标在页面中的位置 img.style.left = e.pageX + \"px\"; img.style.top = e.pageY + \"px\";&#125; 如果上下左右有滚动条时1234567891011121314151617181920212223var img = document.getElementById(\"img\");document.onmousemove = function(e) &#123; e = e || window.event; img.style.position = \"absolute\"; img.style.left = getPage(e).pageX + \"px\"; img.style.top = getPage(e).pageY + \"px\";&#125;// 获取鼠标在页面上的坐标function getPage(e)&#123; return&#123; pageX:e.clientX + getScroll().scrollLeft, pageY:e.clientY + getScroll().scrollTop &#125;&#125;// 获取页面滚出去的距离（处理兼容性）function getScroll() &#123; return&#123; scrollTop:document.documentElement.scrollTop || document.body.scrollTop, scrollLeft:document.documentElement.scrollLeft || document.body.scrollLeft, &#125;&#125; 2.7 阻止事件传播方式 标准方式：event.stopPropagation(); IE低版本：event.cancelBubble = true; 标准中已废弃 1234567var link = document.getElementById(\"link\");link.onclick = function(e) &#123; alert(\"点击了\"); // 阻止默认行为 // return false； e.preventDefault();&#125; event.stopPropagation()用法介绍 该方法将停止事件的传播，阻止它被分派到其他 Document 节点。在事件传播的任何阶段都可以调用它。 event.preventDefault()用法介绍 将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。 2.7 常用的鼠标键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按下触发（这个阻止方法执行，否则down来不及） onkeydown 键盘按键抬起触发 123456789var txt = document.getElementById(\"txt\");txt.onkeydown = function(e) &#123; // 键盘码 console.log(e.keyCode); if(e.keyCode === 65)&#123; return false; &#125;&#125; 想让用户按下空格input光标换到下一个input use strict 第一种思路把keyCode改成91234567891011121314151617181920'use strict'a = 5;// 严格模式下必须先声明变量再使用function f() &#123; console.log(this);// 严格模式下this是undefined&#125;var texts = document.querySelectorAll(\"input[type = text]\";)var i=0,len = texts.length;for(;i&lt;len;i++)&#123; var txt = texts[i]; txt.onkeydown = txtKeydown;&#125;function txtKeydown() &#123; // 13回车 9 tab if(e.keyCode === 13)&#123; e.keyCode = 9; &#125;&#125; 如果加了严格模式会报错，因为keyCode是只读属性 当在文本框中按下回车，让下一个文本框获取焦点 nextElement.focus(); 1234567891011121314151617'use strict'var texts = document.querySelectorAll(\"input[type = text]\";)var i=0,len = texts.length;for(;i&lt;len;i++)&#123; var txt = texts[i]; txt.onkeydown = txtKeydown;&#125;function txtKeydown() &#123; // 当在文本框中按下回车，让下一个文本框获取焦点 var nextElement = this.nextElementSibling; if(nextElement)&#123; nextElement.focus(); &#125;&#125;"},{"title":"NodeJs3","date":"2018-12-24T02:00:03.000Z","path":"2018/12/24/NodeJs3/","text":"8 链接数据库8.1 回顾ES6ES6对数组新增了很多方法可以用Array.prototype在浏览器中查看所有属性 find find接收一个方法作为参数，方法内部返回一个条件 find会便利所有的元素，执行你给定的带有条件返回值的函数 符合该条件的元素会作为find方法返回值 如果遍历结束还没有符合该条件的元素，则返回undefined 1234567891011121314151617181920var users = [ &#123;id:1,name:'张三1'&#125;, &#123;id:2,name:'张三2'&#125;, &#123;id:3,name:'张三3'&#125;, &#123;id:4,name:'张三4'&#125;]Array.prototype.myFind = function(conditionFunc) &#123; for (var i = 0;i&lt; this.length;i++)&#123; if(conditionFunc(this[i],i))&#123; return this[i] &#125; &#125;&#125;var ret - users.myFind(function(item,index) &#123; return item.id === 4&#125;)console.log(ret) 8.2 关系和非关系型数据库 所有的关系型数据库都需要通过sql语言来操作 所有的关系型数据库在操作之前都需要设计表结构 数据表支持约束 唯一的 主键 默认值 非空 非关系型数据库非常灵活 有的关系型数据库就是key-value键值对 MongoDB是长得最像关系型数据库的非关系型数据库 数据库-》数据库 数据表-》集合（数组） 表记录-》（文档对象） 8.3 Mongod数据库基本操作Mongod的安装和其他操作可以看另一篇文章 启动和关闭数据库启动： mongod默认使用，执行mongod命令所处盘符目录下的/data/db作为自己的数据存储所以在第一次执行该命令之前先自己手动建立一个data/db mongod 如果想要修改默认的数据存储牡蛎可以 mongod –dppath=数据存储目录路径 停止： 在开启服务的控制台，直接Ctrl+c即可停止或者直接关闭开启服务控制台也可以 连接和退出数据库 连接：默认连接本机的MongoDB服务 mongo 退出：在连接状态下输入exit退出连接 exit 8.4 mongoosemongoose是Node连接mongo的包，查看官网 起步安装 npm i mongoose 下面是官网的示例hello world:1234567const mongoose = require('mongoose');mongoose.connect('mongodb://localhost/test');const Cat = mongoose.model('Cat', &#123; name: String &#125;);const kitty = new Cat(&#123; name: 'Zildjian' &#125;);kitty.save().then(() =&gt; console.log('meow')); 下面我们自己写一个demo 连接数据库 设计文档结构（表结构） 将文档结构发布为模型 开始操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546const mongoose = require('mongoose');// 1.连接数据库// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来mongoose.connect('mongodb://localhost/itcast');// 2. 设计集合结构（表结构）// 字段名称就是表结构中的属性名称// 约束的目的就是为了保证数据的完整性，不要有脏数据var userSchema = new Schema(&#123; username:&#123; type:String, // 数据类型 required:ture //必须有 &#125;, password:&#123; type:String, required:true &#125;, email:&#123; type: String &#125;&#125;)// 3. 将文档结构发布为模型// mongoose.model方法就是用来将一个框架发布为model// 第一个参数：传入一个大写单词单数字符串来表示你的数据库名称// mongoose会自动将大写名词的单字符串生成小写复数的集合名称// 例如这里的User最终会变成users集合名称// 第二个参数：架构Schema// 返回值：模型构造函数var User = mongoose.model('User',userSchema)// 4. 当我们有了模型构造函数之后，就可以使用这个构造函数对users集合中的数据进行操作var admin = new User(&#123; username:'admin', password:'123456', email:'admin@163.com'&#125;)admin.save(function(err,ret) &#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功') console.log(ret) &#125;&#125;) 增加数据 1234567891011121314var admin = new User(&#123; username:'admin', password:'123456', email:'admin@163.com'&#125;)admin.save(function(err,ret) &#123; if(err)&#123; console.log('保存失败') &#125;else&#123; console.log('保存成功') console.log(ret) &#125;&#125;) 查询 查询所有 1234567User.find(function(err,ret) &#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log(ret) &#125;&#125;) 按条件查询所有 12345678910User.find(&#123; username:'admin', password:'123456',&#125;,function(err,ret) &#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log(ret) &#125;&#125;) 按条件查询一个 1234567891011User.findOne(&#123; username:'admin', password:'123456',&#125;,function(err,ret) &#123; if(err)&#123; console.log('查询失败') &#125;else&#123; console.log(ret) &#125;&#125;)` 4 删除根据条件删除所有：1234567891011User.remove(&#123; username:'admin', password:'123456',&#125;,function(err,ret) &#123; if(err)&#123; console.log('删除失败') &#125;else&#123; console.log('删除成功') console.log(ret) &#125;&#125;) 根据条件删除一个：1Model.findOneAndRemove(conditions,[options],[callback]) 根据id删除一个：1Model.findByIdAndRemove(id,[options],[callback]) 4 更新数据根据条件更新所有1Model.update(conditions,doc,[options],[callback]) 根据条件更新一个1Model.findOneAndUpdate([conditions],[update],[options],[callback]) 根据id更新一个12345678910User.findByIdAndUpdate('23213123123123',&#123; password:'1234',&#125;,function(err,ret) &#123; if(err)&#123; console.log('更新失败') &#125;else&#123; console.log('更新成功') console.log(ret) &#125;&#125;) 8.5 更新项目为数据库存储1234567891011121314151617181920212223var mongoose = require('mongoose')mongoose.connect('mongodb://localhost/itcast')var Schema = mongoose.Schemavar studentSchema = new Schema(&#123; name:&#123; type:String, required:true &#125;, gender:&#123; type:Number, enum:[0,1], default:0 &#125;, age:&#123; type:Number, required:true &#125;, hobbies:&#123; type:String &#125;&#125;)module.exports = mongoose.model('Student',studentSchema); 渲染学生列表页面修改12345678910router.get('/students',function(req,res) &#123; Student.find(function(err,students) &#123; if(err)&#123; return res.status(500).send('Server error') &#125; res.render('index.html',&#123; students:students &#125;) &#125;)&#125;) 处理添加学生12345678router.post('/students/new',function(req,res) &#123; new Student(req,body).save(function(err) &#123; if(err)&#123; return res.status(500).send('Server error') &#125; res.redirect('/students') &#125;)&#125;) 8.6 连接Mysql应用的包名称为mysql npm install mysql1234567891011121314151617181920var mysql = require('mysql')// 1.创建连接var connection = mysql.createConnection(&#123; host:'localhost', // 地址 user:'me', // 账户 password:'***', // 密码 database:'xxx' // 数据库名&#125;)// 2. 连接数据库connection.connet();// 3. 执行数据操作(增删改查所有语句都在这里执行)connection.query('SQL语句',function(error,results,fields) &#123; if(error) throw error; console.log(results[0].solution) &#125;)// 4. 关闭连接connection.end(); 9 回调函数9.1 回调地狱123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var fs = require('fs')fs.readFile('./data/a.txt','utf8',function(err,data) &#123; if(err)&#123; // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data);&#125;)fs.readFile('./data/b.txt','utf8',function(err,data) &#123; if(err)&#123; throw err &#125; console.log(data);&#125;)fs.readFile('./data/c.txt','utf8',function(err,data) &#123; if(err)&#123; throw err &#125; console.log(data);&#125;)``` 如果想一个一个执行只能嵌套，影响美观```jsvar fs = require('fs')fs.readFile('./data/a.txt','utf8',function(err,data) &#123; if(err)&#123; // 抛出异常 // 1. 阻止程序的执行 // 2. 把错误消息打印到控制台 throw err &#125; console.log(data); fs.readFile('./data/b.txt','utf8',function(err,data) &#123; if(err)&#123; throw err &#125; console.log(data); fs.readFile('./data/c.txt','utf8',function(err,data) &#123; if(err)&#123; throw err &#125; console.log(data); &#125;) &#125;)&#125;) 9.2 Promise12345678910111213141516var fs = require('fs')console.log(1)// 创建Promise容器// 1. 给别人一个承诺// Promise容器一旦创建，就开始执行里面的代码new Promise(function() &#123; console.log(2) fs.readFile('./data/a.txt','utf8',function(err,data) &#123; if(err)&#123; throw err &#125; console.log(3) console.log(data); &#125;)&#125;)console.log(4)"},{"title":"webpack3.X","date":"2018-12-21T05:45:21.000Z","path":"2018/12/21/webpack3-X/","text":"0 webpack概论0.1 为什么需要WebPack现在的前端网页功能丰富，特别是SPA（single page web application 单页应用）技术流行后，JavaScript的复杂度增加和需要一大堆依赖包，还需要解决SCSS，Less……新增样式的扩展写法的编译工作。所以现代化的前端已经完全依赖于WebPack的辅助了。 现在最流行的三个前端框架，可以说和webpack已经紧密相连，框架官方都推出了和自身框架依赖的webpack构建工具。 React.js+WebPack Vue.js+WebPack AngluarJS+WebPack从此可以看出，无论你前端走那条线，你都要有很强的Webpack知识，才能祝你成为这个框架领域的大牛。 0.2 什么是WebPack WebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Sass，TypeScript等），并将其转换和打包为合适的格式供浏览器使用。在3.0出现后，Webpack还肩负起了优化项目的责任。 Webpack主要包括以下三个重点 打包：可以把多个Javascript文件打包成一个文件，减少服务器压力和下载带宽。 转换：把拓展语言转换成为普通的JavaScript，让浏览器顺利运行。 优化：前端变的越来越复杂后，性能也会遇到问题，而WebPack也开始肩负起了优化和提升性能的责任。 0.3 安装WebPackWebPack的安装必须安装node，可以通过 node -v来查看node安装情况和版本，如果没有安装，要先安装node才可以继续进行。 如果已经安装过node可以进行webpack的安装 先对机器进行全局的安装 npm install -g webpack 对项目目录进行安装 全局安装完成后，我们还要进行一个项目目录的安装。在用npm安装前，我们先要进行一下初始化，初始化的主要目的是生成package.json文件。 npm n init 输入下面命令进行项目目录的安装：npm install –save webpack 这里的参数–save是要保存到package.json中，dev是在开发时使用这个包，而生产环境中不使用。 开发环境：在开发时需要的环境，这里指在开发时需要依赖的包。 生产环境：程序开发完成，开始运行后的环境，这里指要使项目运行，所需要的依赖包。 查看webpack版本 webpack -v 0.4 第一个Demo新建一个文件夹，之后在文件夹中按照刚才所说,(1.初始化项目,2.安装webpack)。进入目录再建立两个文件夹，分别是src文件夹和dist文件夹： src文件夹：用来存放我们编写的javascript代码，可以简单的理解为用JavaScript编写的模块。 dist文件夹：用来存放供浏览器读取的文件，这个是webpack打包成的文件。 编写程序文件： 文件夹建立好后，我们在dist文件下手动建立一个index.html文件，并写入下面的代码。 /dist/index.html12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jspang webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"title\"&gt;&lt;/div&gt; &lt;script src=\"./bundle.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里引入了一个JavaScript的bundle.js文件。这个文件现在还没有，这是用webpack执行打包命令后生产的文件。我们的index.html写好后，接下来在src文件夹下建立entery.js的文件，用于编写我们的JavaScript代码，也是我们的入口文件。 src/entery.js1document.getElementById('title').innerHTML='Hello Webpack'; Webpack打包 webpack 入口文件 打包后存放的路径 执行的结果如下图：命令执行成功后，会在dist目录下出现bundle.js文件，这时我们就可以在浏览器中预览结果了，网页中显示出了Hello Webpack的信息。 1 详解配置文件1.1 入口出口webpack.config.js就是Webpack的配置文件，这个文件需要自己在项目根目录下手动建立。建立好后我们对其进行配置，先看下面的代码（webpack.config.js的基本结构），这是一个没有内容的标准webpack配置模版。 webpack.config.js 12345678910111213const path = require('path');module.exports=&#123; //入口文件的配置项 entry:&#123;&#125;, //出口文件的配置项 output:&#123;&#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; entry：配置入口文件的地址，可以是单一入口，也可以是多入口。 output：配置出口文件的地址，在webpack2.X版本后，支持多出口配置。 module：配置模块，主要是解析CSS和图片转换压缩等功能。 plugins：配置插件，根据你的需要配置不同功能的插件。 devServer：配置开发服务功能，后期我们会详细讲解。 entry选项（入口配置） 这个选项就是配置我们要压缩的文件一般是JavaScript文件（当然也可以是CSS…..）。按照刚才的代码这里要填写的是src目录下的entery.js文件。 wepback.config.js中的entry选项 12345//入口文件的配置项entry:&#123; //里面的entery是可以随便写的 entry:'./src/entry.js'&#125;, output选项（出口配置） 出口配置是用来告诉webpack最后打包文件的地址和文件名称的。按照刚才代码应该打包到dist目录下。 1234567//出口文件的配置项output:&#123; //打包的路径文职 path:path.resolve(__dirname,'dist'), //打包的文件名称 filename:'bundle.js'&#125;, filename:是打包后的文件名称，这里我们起名为bundle.js。 现在webpack.config.js的代码：1234567891011121314151617181920const path = `require`('path');module.exports=&#123; //入口文件的配置项 entry:&#123; entry:'./src/entry.js' &#125;, //出口文件的配置项 output:&#123; //输出的路径，用了Node语法 path:path.resolve(__dirname,'dist'), //输出的文件名称 filename:'bundle.js' &#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 多入口、多出口配置 12345678910111213141516171819202122const path = `require`('path');module.exports=&#123; //入口文件的配置项 entry:&#123; entry:'./src/entry.js', //这里我们又引入了一个入口文件 entry2:'./src/entry2.js' &#125;, //出口文件的配置项 output:&#123; //输出的路径，用了Node语法 path:path.resolve(__dirname,'dist'), //输出的文件名称 filename:'[name].js' &#125;, //模块：例如解读CSS,图片如何转换，压缩 module:&#123;&#125;, //插件，用于生产模版和各项功能 plugins:[], //配置webpack开发服务功能 devServer:&#123;&#125;&#125; 在入口文件配置中，增加了一个entry2.js的入口文件（这个文件你需要自己手动建立），这时候要打包的就有了两个入口文件。在代码14行我们把原来的bundle.js修改成了[name].js。[name]的意思是根据入口文件的名称，打包成相同的名称，有几个入口文件，就可以打包出几个文件 1.2 服务和热更新设置webpack-dev-server 要执行webpack-dev-server是要先用 npm install webpack-dev-server –save-dev 来进行下载的。下载好后，需要配置一下devServer。最简单的devServer配置项只有四个。先看一下代码 12345678910devServer:&#123; //设置基本目录结构 contentBase:path.resolve(__dirname,'dist'), //服务器的IP地址，可以使用IP也可以使用localhost host:'localhost', //服务端压缩是否开启 compress:true, //配置服务端口号 port:1717 &#125; contentBase:配置服务器基本运行路径，用于找到程序打包地址。 host：服务运行地址，建议使用本机IP，这里为了讲解方便，所以用localhost。 compress：服务器端压缩选型，一般设置为开启（暂时不了解）。 port：服务运行端口，建议不使用80，很容易被占用，这里使用了1717. 终端中输入webpack-dev-server启动项目 当然我们也可以在package.json中配置一下项目启动123\"scripts\": &#123; \"server\":\"webpack-dev-server\" &#125;, 在npm run server 启动后，它是有一种监控机制的（也叫watch）。它可以监控到我们修改源码，并立即在浏览器里给我们更新。 注意：这里只是我们的webpack3.6版本支持,在3.5版本时要支持热更新还需要一些其他的操作。 webpack并不鼓励全局安装webpack。这时候需要配置package.json里的scripts选项，我们以前的课程已经学习了配置 webpack-dev-server命令，在这个命令下面我们再加一个build命令进行打包项目使用。 1234\"scripts\": &#123; \"server\": \"webpack-dev-server --open\", \"build\":\"webpack\" &#125;, 配置完成后，可以在控制台输入npm run build 进行打包。 1.3 CSS文件打包Webpack在生产环境中有一个重要的作用就是减少http的请求数，就是把多个文件打包到一个js里，这样请求数就可以减少好多。在打包之前，需要先对当然我们也可以在package.json中配置一下项目启动webpack.config.js里的Loaders配置项进行了解。LoadersLoaders是Webpack最重要的功能之一，他也是Webpack如此盛行的原因。通过使用不同的Loader，Webpack可以通过脚本和工具，从而对不同的文件格式进行特定处理。比如： 可以把SASS文件的写法转换成CSS，而不在使用其他转换工具。 可以把ES6或者ES7的代码，转换成大多浏览器兼容的JS代码。 可以把React中的JSX转换成JavaScript代码。 注意：所有的Loaders都需要在npm中单独进行安装，并在webpack.config.js里进行配置。 以下配置是对ES6配置12345678910module:&#123; rules: [ &#123; test:/\\.js$/, loader:'babel-loader', exclude:/dist/, query: &#123; presets: ['es2015']&#125; &#125;, ] &#125; test：用于匹配处理文件的扩展名的表达式，这个选项是必须进行配置的； use：loader名称，就是你要使用模块的名称，这个选项也必须进行配置，否则报错； include/exclude:手动添加必须处理的文件（文件夹）/屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选）。 loader的三种写法： 第一种写法：直接用use。12345678module:&#123; rules:[ &#123; test:/\\.css$/, use:['style-loader','css-loader'] &#125; ] &#125;, 第二种写法：把use换成loader。 12345678module:&#123; rules:[ &#123; test:/\\.css$/, loader:['style-loader','css-loader'] &#125; ] &#125;, 第三种写法：用use+loader的写法： 1234567891011121314module:&#123; rules:[ &#123; test:/\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\" &#125; ] &#125; ] &#125;, 打包CSS文件： 在/src目录下建立index.css文件 ./src/css/index.css1234body&#123; background-color: red; color: white;&#125; CSS文件建立好后，需要引入到入口文件中，才可以打包到，这里我们引入到entry.js中。/src/entery.js中在首行加入代码：1import i css from './css/index.css'; CSS和引入做好后，我们就需要使用loader来解析CSS文件了，这里我们需要两个解析用的loader，分别是style-loader和css-loader。 style-loader: 它是用来处理css文件中的url()等路径问题 npm install style-loader –save-dev css-loader 它是用来将css插入到页面的style标签。 npm n install –save-dev css-loader loaders配置： 两个loader都下载安装好后，我们就可以配置我们loaders了。修改webpack.config.js中module属性中的配置代码如下： webpack.config.js12345678module:&#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125; ] &#125;, 1.4 配置JS压缩JS代码，在上线之前，都是需要进行压缩的，在没有webpack和gulp这些工具前，你可能需要找一个压缩软件或者在线进行压缩，在Webpack中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个uglifyjs-webpack-plugin(JS压缩插件，简称uglify)。 注意：虽然uglifyjs是插件，但是webpack版本里默认已经集成，不需要再次安装。 引入 我们需要在webpack.config.js中引入uglifyjs-webpack-glugin插件 1const uglify = `require`('uglifyjs-webpack-plugin'); 引入后在plugins配置里new一个 uglify对象就可以了，代码如下。 123plugins:[ new uglify() ], 这时候在终端中使用webpack进行打包，你会发现JS代码已经被压缩了。 我们来看一下目前的整体配置 1234567891011121314151617181920212223242526272829const path=`require`('path');const uglify = `require`('uglifyjs-webpack-plugin');module.exports=&#123; entry:&#123; entry:'./src/entry.js', entry2:'./src/entry2.js' &#125;, output:&#123; path:path.resolve(__dirname,'dist'), filename:'[name].js' &#125;, module:&#123; rules:[ &#123; test:/\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ] &#125;, plugins:[ new uglify() ], devServer:&#123; contentBase:path.resolve(__dirname,'dist'), host:'192.168.0.104', compress:true, port:1717 &#125;&#125; 1.5 HTML文件的发布devServer和JS压缩的冲突 开发环境中是基本不会对js进行压缩的，在开发预览时我们需要明确的报错行数和错误信息，所以完全没有必要压缩JavasScript代码。而生产环境中才会压缩JS代码，用于加快程序的工作效率。devServer用于开发环境，而压缩JS用于生产环境，在开发环境中作生产环境的事情所以Webpack设置了冲突报错。在实际开发中，webpack配置文件是分开的，开发环境一个文件，生产环境一个文件。 打包HTML文件 使用npm进行安装包。 npm install –save-dev html-webpack-plugin 配置webpack.config.js文件,引入我们的html-webpack-plugin插件。 const htmlPlugin= require(‘html-webpack-plugin’); 在webpack.config.js里的plugins里进行插件配置，配置代码如下1234567new htmlPlugin(&#123; minify:&#123; removeAttributeQuotes:true &#125;, hash:true, template:'./src/index.html' &#125;) minify：是对html文件进行压缩，removeAttrubuteQuotes是去掉属性的双引号。 hash：为了开发中js有缓存效果，所以加入hash，这样可以有效避免缓存JS。 template：是要打包的html模版路径和文件名称。 在终端中使用webpack，进行打包。你会看到index.html文件已经被打包到我们的dist目录下了，并且自动为我们引入了路口的JS文件。 1.6 CSS中的图片处理具体操作 在src目录下新建一个images文件夹，把图片放入images文件夹。 在index.html文件中增加一个放置div的标签（需要注意的是这里修改的是src下的index.html文件，不是dist下的，这点新手很容易弄混，要格外注意），代码如下。 1&lt;div id=\"tupian\"&gt;&lt;/div&gt; 编写css文件，把你用的图片作为背景显示。12345#tupian&#123; background-image: url(../images/manhua.png); width:466px; height:453px;&#125; 编写完成后，我们可以试着用webpack去打包一下。你会发现终端中是报错的 安装file-loader和url-loader npm install –save-dev file-loader url-loader file-loader：解决引用路径的问题，拿background样式用url引入背景图来说，我们都知道，webpack最终会将各个模块打包成一个文件，因此我们样式中的url路径是相对入口html页面的，而不是相对于原始css文件所在的路径的。这就会导致图片引入失败。这个问题是用file-loader解决的，file-loader可以解析项目中的url引入（不仅限于css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。 url-loader：如果图片较多，会发很多http请求，会降低页面性能。这个问题可以通过url-loader解决。url-loader会将引入的图片编码，生成dataURl。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的文件会被转为DataURl，大于limit的还会使用file-loader进行copy。 配置url-loader,webpack.config.js文件 1234567891011121314151617//模块：例如解读CSS,图片如何转换，压缩 module:&#123; rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;,&#123; test:/\\.(png|jpg|gif)/ , use:[&#123; loader:'url-loader', options:&#123; limit:500000 &#125; &#125;] &#125; ] &#125;, test:/.(png|jpg|gif)/是匹配图片文件后缀名称。 use：是指定使用的loader和loader的配置参数。 limit：是把小于500000B的文件打成Base64的格式，写入JS。 file-loader和url-loader关系 url-loader封装了file-loader。url-loader不依赖于file-loader，即使用url-loader时，只需要安装url-loader即可，不需要安装file-loader，因为url-loader内置了file-loader。通过上面的介绍，我们可以看到，url-loader工作分两种情况： 1.文件大小小于limit参数，url-loader将会把文件转为DataURL（Base64格式）； 2.文件大小大于limit，url-loader会调用file-loader进行处理，参数也会直接传给file-loader。 也就是说，其实我们只安装一个url-loader就可以了。但是为了以后的操作方便，我们这里就顺便安装上file-loader。 1.7 CSS分离CSS分离:extract-text-webpack-pluginwebpack官方其实并不建议这样作，他们认为CSS就应该打包到JavasScript当中以减少http的请求数。 安装 npm install –save-dev extract-text-webpack-plugin 引入 const extractTextPlugin = require(“extract-text-webpack-plugin”); 设置Plugins new extractTextPlugin(“/css/index.css”) 这里的/css/index.css是分离后的路径位置。这部配置完成后，包装代码：还要修改原来我们的style-loader和css-loader。 12345678910111213141516171819module:&#123; rules: [ &#123; test: /\\.css$/, use: extractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125;,&#123; test:/\\.(png|jpg|gif)/ , use:[&#123; loader:'url-loader', options:&#123; limit:500000 &#125; &#125;] &#125; ] &#125;, 图片路径问题 利用extract-text-webpack-plugin插件很轻松的就把CSS文件分离了出来，但是CSS路径并不正确。最好的解决方案是使用publicPath解决 publicPath：是在webpack.config.js文件的output选项中，主要作用就是处理静态文件路径的。 在处理前，我们在webpack.config.js 上方声明一个对象，叫website。 123var website =&#123; publicPath:\"http://192.168.1.108:1717/\"&#125; 注意，这里的IP和端口，是你本机的ip或者是你devServer配置的IP和端口。 然后在output选项中引用这个对象的publicPath属性。 12345678//出口文件的配置项 output:&#123; //输出的路径，用了Node语法 path:path.resolve(__dirname,'dist'), //输出的文件名称 filename:'[name].js', publicPath:website.publicPath &#125;, 配置完成后，你再使用webpack命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。 1.7 处理HTML中的图片在webpack中是不喜欢你使用标签来引入图片的，但是我们作前端的人特别热衷于这种写法，国人也为此开发了一个：html-withimg-loader。他可以很好的处理我们在html 中引入图片的问题。因为是国人开发的，文档都是中文，所以学习起来还是比较简单的。 如何把图片放到指定的文件夹下 打包后的图片并没有放到images文件夹下，要放到images文件夹下，其实只需要配置我们的url-loader选项就可以了。 1234567891011121314151617181920module:&#123; rules: [ &#123; test: /\\.css$/, use: extractTextPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125;,&#123; test:/\\.(png|jpg|gif)/ , use:[&#123; loader:'url-loader', options:&#123; limit:5000, outputPath:'images/', &#125; &#125;] &#125; ] &#125;, 这回你再执行打包就可以把图片打包到images文件夹里了。 html-withimg-loader 安装： npm install html-withimg-loader –save 配置loader:webpack.config.js 1234&#123; test: /\\.(htm|html)$/i, use:[ 'html-withimg-loader'] &#125; 1.8 Less和Sass的打包和分离 Less Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。也就是说Less给我们枯燥单一的样式文件加入了编程机制，这让我们这些前端程序员很受用，所以在工作中大部分程序员都使用了Leess开发。 打包Less文件 安装:要使用Less，我们要首先安装Less的服务，当然也是用npm来进行安装。 npm install –save-dev less 还需要安装Less-loader用来打包使用。 npm n install –save-dev less-loader 写loader配置： 安装好后，需要在webpack.config.js里编写loader配置，当然要想正确解析成CSS，还是需要style-loader和css-loader的帮助 webpack.config.js 12345678910&#123; test: /\\.less$/, use: [&#123; loader: \"style-loader\" // creates style nodes from JS strings &#125;, &#123; loader: \"css-loader\" // translates CSS into CommonJS , &#123; loader: \"less-loader\" // compiles Less to CSS &#125;]&#125; 编写一个less文件 现在webpack的配置好了，我们还需要编写一个less文件，这里明文为black.less.里边只做一件是就是把一个层的背景设置成黑色。 black.less123456@base :#000;#gogo&#123; width:300px; height:300px; background-color:@base;&#125; 引入到我们entery.js文件中 import less from ‘./css/black.less’; 这样我们就可以把less文件进行打包了。我们可以使用webpack命令打包试一试。 把Lees文件分离。 extract-text-webpack-plugin这个插件，想把Less文件分离出来的方法跟这个几乎一样 123456789101112&#123; test: /\\.less$/, use: extractTextPlugin.extract(&#123; use: [&#123; loader: \"css-loader\" &#125;, &#123; loader: \"less-loader\" &#125;], // use style-loader in development fallback: \"style-loader\" &#125;) &#125; 配置好后，你会发现less被分离到了index.css文件里。 Sass SASS的配置，其实你会了Less得配置，SASS的配置可以很轻松的学会 安装SASS打包的loader node-sass：因为sass-loader依赖于node-sass，所以需要先安装node-sass npm n install –save-dev node-sass sass-loader: npm install –save-dev sass-loader 在用npm安装时，这个loader很容易安装失败，最好使用cnpm来进行安装。如果你安装一直报错，最好是把node_modules文件夹删除后，再重新安装。编写loader配置12345678910&#123; test: /\\.scss$/, use: [&#123; loader: \"style-loader\" // creates style nodes from JS strings &#125;, &#123; loader: \"css-loader\" // translates CSS into CommonJS &#125;, &#123; loader: \"sass-loader\" // compiles Sass to CSS &#125;]&#125; Sass文件的编写 1234567$nav-color: #FFF;#nav &#123; $width: 100%; width: $width; height:30px; background-color: $nav-color;&#125; 把SASS文件分离。 123456789101112&#123; test: /\\.scss$/, use: extractTextPlugin.extract(&#123; use: [&#123; loader: \"css-loader\" &#125;, &#123; loader: \"sass-loader\" &#125;], // use style-loader in development fallback: \"style-loader\" &#125;) &#125; 1.9 CSS3优化 自动处理CSS3属性前缀 CSS3已经成了前端的必会技能，但是你一定为那些属性需要加前缀，那些属性不需要加前缀而头疼。can i use网站，可以查询这些，但是每次都查实在是编码效率太低了。 什么是属性前缀 12-webkit-transform: rotate(45deg); transform: rotate(45deg); 为了浏览器的兼容性，有时候我们必须加入-webkit,-ms,-o,-moz这些前缀。目的就是让我们写的页面在每个浏览器中都可以顺利运行。 PostCSSPostCSS是一个CSS的处理平台，它可以帮助你的CSS实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下PostCSS。 安装 需要安装两个包postcss-loader 和autoprefixer（自动添加前缀的插件） npm install –save-dev postcss-loader autoprefixer postcss.config.js postCSS推荐在项目根目录（和webpack.config.js同级），建立一个postcss.config.js文件。 postcss.config.js 12345module.exports = &#123; plugins: [ require('autoprefixer') ]&#125; 这就是对postCSS一个简单的配置，引入了autoprefixer插件。让postCSS拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。 编写loader 对postcss.config.js配置完成后，我们还需要编写我们的loader配置。 123456789101112131415&#123; test: /\\.css$/, use: [ &#123; loader: \"style-loader\" &#125;, &#123; loader: \"css-loader\", options: &#123; modules: true &#125; &#125;, &#123; loader: \"postcss-loader\" &#125; ]&#125; 提取CSS配置提取CSS的loader配置.12345678910&#123; test: /\\.css$/, use: extractTextPlugin.extract(&#123; fallback: 'style-loader', use: [ &#123; loader: 'css-loader', options: &#123; importLoaders: 1 &#125; &#125;, 'postcss-loader' ] &#125;)&#125; 消除未使用的CSS像Bootstrap这样的框架往往会带有很多CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS也会越来越多，有时候需求更改，带来了DOM结构的更改，这时候我们可能无暇关注CSS样式，造成很多CSS的冗余。 PurifyCSS 使用PurifyCSS可以大大减少CSS冗余，比如我们经常使用的BootStrap(140KB)就可以减少到只有35KB大小。这在实际开发当中是非常有用的。 安装PurifyCSS-webpack 从名字你就可以看出这是一个插件，而不是loader。所以这个需要安装还需要引入。 PurifyCSS-webpack要以来于purify-css这个包，所以这两个都需要安装。 npmn i -D purifycss-webpack purify-css 这里的-D代表的是–save-dev ,只是一个简写。 引入glob 因为我们需要同步检查html模板，所以我们需要引入node的glob对象使用。在webpack.config.js文件头部引入glob。 引入purifycss-webpack同样在webpack.config.js文件头部引入purifycss-webpack1const PurifyCSSPlugin = `require`(\"purifycss-webpack\"); 配置plugins 引入完成后我们需要在webpack.config.js里配置plugins。 123456789101112131415plugins:[ //new uglify() new htmlPlugin(&#123; minify:&#123; removeAttrubuteQuotes:true &#125;, hash:true, template:'./src/index.html' &#125;), new extractTextPlugin(\"css/index.css\"), new PurifyCSSPlugin(&#123; // Give paths to parse for rules. These should be absolute! paths: glob.sync(path.join(__dirname, 'src/*.html')), &#125;)] 这里配置了一个paths，主要是需找html模板，purifycss根据这个配置会遍历你的文件，查找哪些css被使用了。 注意：使用这个插件必须配合extract-text-webpack-plugin这个插件 配置好上边的代码，我们可以故意在css文件里写一些用不到的属性，然后用webpack打包，你会发现没用的CSS已经自动给你删除掉了。在工作中记得一定要配置这个plugins，因为这决定你代码的质量，非常有用。 1.10 给webpack增加babel支持Babel是什么？ Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过便宜帮你达到以下目的： 使用下一代的javaScript代码(ES6,ES7….)，即使这些标准目前并未被当前的浏览器完全支持。 使用基于JavaScript进行了扩展的语言，比如React的JSX。 Babel的安装与配置 Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的babel-preset-es2015包和解析JSX的babel-preset-react包）。 我们先一次性安装这些依赖包 cnpm c install –save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中配置Babel的方法如下： 123456789101112&#123; test:/\\.(jsx|js)$/, use:&#123; loader:'babel-loader', options:&#123; presets:[ \"es2015\",\"react\" ] &#125; &#125;, exclude:/node_modules/&#125; 现在你已经可以用webapck转换ES6的语法兼容各个浏览器了，我们可以修改一下entry.js的代码如下 12345import css from './css/index.css';&#123; let jspangString = 'Hello Webpack' document.getElementById('title').innerHTML=jspangString; &#125; 上面的代码使用了ES6的let声明方法。如果你不使用Babel来进行转换，你会发现打包出来的js代码没有作兼容处理，使用了Babel转换的代码是进行处理过的。 .babelrc配置 虽然Babel可以直接在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，如果卸载webapck.config.js中会非常的雍长不可阅读，所以我们经常把配置卸载.babelrc文件里。 在项目根目录新建.babelrc文件，并把配置写到文件里。 .babelrc 123&#123; \"presets\":[\"react\",\"es2015\"]&#125; .webpack.config.js里的loader配置 1234567&#123; test:/\\.(jsx|js)$/, use:&#123; loader:'babel-loader', &#125;, exclude:/node_modules/&#125; ENV： 现在网络上已经不流行babel-preset-es2015，现在官方推荐使用的是babel-preset-env 首先需要下载 npm n install –save-dev babel-preset-env 然后修改.babelrc里的配置文件。其实只要把之前的es2015换成env就可以了。 123&#123; \"presets\":[\"react\",\"env\"]&#125; 2. Webpack应用2.1 打包后如何调试在使用webpack时只要通过简单的devtool配置，webapck就会自动给我们生产source maps 文件，map文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。 在配置devtool时，webpack给我们提供了四种选项。 source-map:在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的source map,但是它会减慢打包速度；（source map只适用于开发阶段） cheap-module-source-map:在一个单独的文件中产生一个不带列映射的map，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号）,会对调试造成不便。 eval-source-map:使用eval打包源文件模块，在同一个文件中生产干净的完整版的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。 cheap-module-eval-source-map:这是在打包文件时最快的生产source map的方法，生产的 Source map 会和打包后的JavaScript文件同行显示，没有影射列，和eval-source-map选项具有相似的缺点。 四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。 简单的配置： 12345678module.exports = &#123; devtool: 'eval-source-map', entry: __dirname + \"/app/main.js\", output: &#123; path: __dirname + \"/public\", filename: \"bundle.js\" &#125;&#125; 2.2 开发和生产并行设置依赖不同 一个项目中是有开发环境和生产环境的，这两个环境的依赖也是不同的。 开发依赖：只在开发中用来帮助你进行开发，简化代码或者生成兼容设置的以来包。你可以打开package.json来查看，devDependencies的下面的这些包为开发使用的包。这些包在生产环境中并没有用处。 生产依赖：就是比如我们的js使用了jquery，jquery的程序要在浏览器端起作用，也就是说我们最终的程序也需要这个包，这就是生产依赖。这些包在dependencies中。 假如我们要在项目中使用jquery库，这时候我们一般有三种安装方法 第一种： npm install jquery 安装完成后，你会发现在package.json中并不存在这个包的依赖。如果你项目拷贝给别人继续开发，或者别人和你git合作，再次下载项目npm install时就会缺少这个jquery包。项目就会无法正常运行，所以这也是我们最不赞成的安装方法。 第二种： npm n install jquery –save 安装完成后，它存在于package.json的dependencies中，也就是说它是生产环境需要依赖的包（上线时需要的依赖包）。 第三种： npm install jquery –save-dev 安装完成后，它存在于package.json的devDependencies中，也就是说它是开发环境中需要的，上线并不需要这个包的依赖。 安装全部项目依赖包： npm install 安装生产环境依赖包： npm install –production 配置生产和开发并行 我们在以前的配置中设置了一个变量website，用于静态资源正确找到路径。那如果生产环境和开发环境不一样，而且我们需要来回切换，这时候我们需要更好的设置方法。 123var website=&#123; publicPath:\"http://192.168.0.104:1717/\"&#125; 修改package.json命令 其实就是添加一个dev设置，并通过环境变量来进行区分，下面是package.json里的值。 12345\"scripts\": &#123; \"server\": \"webpack-dev-server --open\", \"dev\":\"set type=dev&amp;webapck\", \"build\": \"set type=build&amp;webpack\" &#125;, 修改webpack.config.js文件 可以利用node的语法来读取type的值，然后根据type的值用if–else判断。 123456789if(process.env.type== \"build\")&#123; var website=&#123; publicPath:\"http://192.168.0.104:1717/\" &#125;&#125;else&#123; var website=&#123; publicPath:\"http://****/\" &#125;&#125; Mac下的package.json设置 MAC电脑下需要把set换成export，并且要多加一个&amp;符，具体代码如下 12345\"scripts\": &#123; \"server\": \"webpack-dev-server --open\", \"dev\":\"export type=dev&amp;&amp;webpack\", \"build\": \"export type=build&amp;&amp;webpack\" &#125;, 2.3 webpack模块化配置JS中的模块化实现 1234function jspang()&#123; alert('jspang.com:'+'webpack');&#125;module.exports=jspang; 上面的代码是一个最简单的es6模块化写法，我们声明了一个jspang方法，并且把这个方法用module.exports进行暴露出去。然后我们在入口文件中用import进行引入，并进行使用。 12import jspang from './jspang.js';jspang(); 我们了解如何作Javascript的模块化后，其实webpack的模块化和上边的过程很类似。 webpack模块 首先在根目录，新建一个webpack_config文件夹，然后新建entry_webpack.js文件，代码如下： entry_webpack.js12345678//声明entry变量const entry =&#123;&#125;; //声明路径属性entry.path=&#123; entry:'./src/entry.js' &#125;//进行模块化module.exports =entry; 配置的模块化代码编写好以后，需要在webpack.config.js中引入，注意这里的引入只能使用require的方法。 1const entry = require(\"./webpack_config/entry_webpack.js\") 然后在入口文件部分，修改成如下代码1entry:entry.path, 这时候你可以再次使用npm run dev 进行测试，你会发现模块化成功了。 2.4 打包第三方类库引入JQuery 安装JQuery npm install –save jquery 安装时需要注意的时Jquery最终要在生产环境中使用，所以我们这里要使用–save进行安装。 修改entry.js文件 安装好后，还需要引入到我们的entry.js中，这里直接使用import进行引入就可以。 import $ from ‘jquery’; 这里引入是不需要我们写相对路径的，因为jquery的包是在node_modules里的，只要写一个包名jquery，系统会自动为我们查找的。 引入好后我们就可以在entry.js里使用jquery，我们可以加入下面的代码，然后进行测试。 1$('#title').html('Hello JSpang'); 用plugin引入 如果你觉的上面的方法和webpack没什么关系，只是普通的引入，webpack只是负责了一下打包，这样并没有全局感。那再学习一种在webapck.config.js中配置的方法，这种不需要你在入口文件中引入，而是webpack给你作了全局引入。这个插件就是ProvidePlugin。 ProvidePlugin是一个webpack自带的插件，Provide的意思就是装备、提供。因为ProvidePlugin是webpack自带的插件，所以要先再webpack.config.js中引入webpack。 1constc webpack = require('webpack'); 在webpack.config.js里引入必须使用require，否则会报错的 引入成功后配置我们的plugins模块，代码如下。 12345plugins:[ new webpack.ProvidePlugin(&#123; $:\"jquery\" &#125;)], 配置好后，就可以在你的入口文件中使用了，而不用再次引入了。这是一种全局的引入，在实际工作中也可以很好的规范项目所使用的第三方库。 vue 最好这么引入 2.5 watch的正确使用方法watch的配置 12345678watchOptions:&#123; //检测修改的时间，以毫秒为单位 poll:1000, //防止重复保存而发生重复编译错误。这里设置的500是半秒内重复保存，不进行打包操作 aggregateTimeout:500, //不监听的目录 ignored:/node_modules/, &#125; 配置好后，我们就可以痛快的使用watch了，在大型项目中，这大大加快了我们的开发效率，不用反复的手动打包了。"},{"title":"产品设计","date":"2018-12-16T11:58:14.000Z","path":"2018/12/16/产品设计/","text":"0 产品设计基本概念0.1 什么是产品设计 产品： 产品指的是能够供给市场，被人们使用和消费，并能满足人们某种需求的任何东西 产品设计： 互联网产品设计值得是基于战略需要和用户需求，形成方案直至实现方案完成为止的一系列工作和准备和管理 基本原则 需求原则：始终围绕需求来设计产品 信息原则：根据我们获取到的信息（相关政策，对手的某些信息等）合理转换到我们的产品找那个 有效原则：同样的需求我们可能有三四种方案去解决，那么哪一种方案是最好的最有效的 逻辑原则：我们的设计方案需要符合一定基础逻辑，不能反人类 效率原则：公司资源是有限的，如何利用有限的资源实现我们产品，满足需求 如图所示 0.2 产品设计的基本方法 人性法 什么是人性：人之所以成为人的那一部分 人性的弱点：可以被利用的那部分 人性法： 利用人性的弱点设计产品 举例 朋友圈免费领取就是利用贪婪的新：设计要点：突出免费，限量，高价值 外卖产品拯救懒癌患者：突出快捷，选择多，优惠券 社交产品满足se欲：突出颜值导向，匿名，地理位置，xing幻想 总结 挖掘人性最根本的需求源，懒，贪，色，傲 发散的思维寻找解决方案，直击人性弱点 选择合适的方案快速试错，检验是否成功利用弱点 映射法： 找到互联网的模式和线下的模式对比 举例： 网络秀场和传统歌舞厅：都是颜值向导，有有钱人给主播打赏 12306和火车售票厅：都支持买票，退票，查询 今日头条和报纸：都有头版头条，广告，主题面板 总结： 对比现实场景，有什么事类似的需求 类比线上环境，需求可以如何满足 选择合适方案，提高需求满足效率及效果 参考法： 微创新，关键点： 从小处着眼贴近用户需求心理 快速出击，不断试错 模仿不一定是抄袭 举例： QQ游戏大厅和联众 ：微创新——利用QQ作为游戏入库，导入了大量用户 唯品会和Vente-Privee：微创新——移植国外模式到中国，满足国人虚荣心，进而变成尾货市场总结： 模仿，确定需求 列举，需求清单 创新，更优的解决需求 0.3 产品设计的基本流程我们来看一下产品流程我们看一下各个阶段产品经理充当的角色 需求阶段 充当角色 思想家 作家 画家 完成需求从细胞到交互，原型，文档的过程 开发阶段 充当角色 外交家 监工 监督需求的实现，排除万难保障需求完成的时间 发布阶段 充当角色 数据分析师 客服 完成需求检验及客户意见搜集，上线数据分析等工作，继而整理需求进入下一轮的产品设计 0.4 产品设计的五个模式 产品设计： 关注需求 合理制定方案 明确迭代规划 合理展示架构 以用户为核心设计 1 产品方案1.1 前情提要 产品设计互联网产品设计值得是基于战略需要和用户需求，形成直至实现方案完成为止的一系列工作的准备和管理。 市场分析 行业背景分析 宏观分析 竞争态势 行业技术预测 市场现状分析 市场规模 市场阶段 微观个体分析 SWOT分析 用户研究 竞品分析 竞争格局分析（总述） 竞品定位分析 竞品功能分析（具体分析） 竞品策略分析 结论建议（总结） 需求分析 需求是希望满足某种欲望或者需要，而非特定的解决方式 需求到方案 我们往往听到的都是一种解决方案，但它大多不是真实的需求。对此我们需要挖掘出真实需求，提出满足需求的最佳解决方案 例如：新闻APP老板需要做一个调整字体大小的功能，这就是一个方案。是老板为了满足老年人能看手机新闻的需求。我们根据我们目前的产品状况，可能我们的产品刚起步，面对的客户细分群体是20-40岁人群。这样对他们来说这个需求可以先不被满足，我们可以把这个功能放到以后迭代中去。 很多时候，需求不被实现的原因 究其原因是方案本身除了问题 偏离了用户需求 无法满足企业需求 考虑不系统导致实现过程愈发艰难 1.2 产品方案定义产品方案可以理解为产品战略，就是学习运用产品组合策略和产品开发策略规划产品线，谋求理想的利润空间，根据产品生命周期的不同阶段定制适应性战略。方案和需求的对比： 需求 感性的（我饿了） 一个点（就是饿了） 有限的（只是一个我饿了的需求） 心灵的（就是心理想想） 用户的（我） 方案 理性的（现在要动脑怎么去想怎么从饿到不饿） 一个面（从订餐餐厅，到配送到我手中一个面） 多样的（我既可以出去吃，也可以点外卖） 金钱的（用金钱就能解决） 企业 互联网产品方案： 是一套基于用户需求，并根据行业及市场的北京，在有限的时间内，可按迭代完成的，有利于本企业建立竞争优势及获得更多用户并产生更多效益的一套产品策略及运营迭代方案组合。 1.3 产品方案1.产品方案的要求： 先进行背景分析 之后定一下产品基调 和产品框架 需要结构清晰 最好预估一下产品预期 产品方案的设计方法产品方案是重思路，策略，逻辑，而轻具体实现细节 基于分析结论 市场 竞品 用户 需求 形成解决方案 定位 目标 逻辑 功能 产品方案的基本内容 为什么 市场竞品分析 用户需求分析 主要论据 分析结论:论据需支撑后续方案结论 做什么 产品定位 愿景 产品目标 核心逻辑 方案结论：阐述核心产品逻辑 怎么做 功能描述 关键页面 运营策略 时间规划 简述功能界面及运营策略阐述耗时规划 做到了 发展规划及预期展望 画一幅美好的未来蓝图 其中标记为红色的是重点，必须包含的内容，下面我们进行一一阐述 3.1 主要论据 论据与最终提出的产品方案有直接的联系，尽可能以数据形式展示 案例：哪些论据可以支持方案结论 产品方案：优化视频内容的展示逻辑，包含增加智能推荐比重及自动播放功能 a%的用户已经升级为4g网络 xxx的用户有超过1g/月的可用流量 视频可增加用户的有效使用时长 竞品xxx的视频内容占超过50% 近5年视频内容产量的行业增长速度达到每年c% 正确答案是：1 2 3 5 3.2 产品定位 产品时怎么样来满足目标消费者或目标消费市场需求 3.3 愿景 企业长期发展的方向目标理想愿望及企业自我设定的社会责任和义务 3.4 产品目标 本次产品的退出能到到具体的怎样的效果，如分别满足了用户及企业的什么需求 3.5 核心逻辑的表达 产品的核心模块，核心竞争力，差异化的部分 案例：现在想做一个XX音乐VIP的产品，我们怎样进行核心逻辑的表达？ 先设计产品的定位和目标 产品定位：一款为音乐粉丝提供更好服务的产品 产品目标： 提供音乐特权，让粉丝用户更好的体会在线数字音乐 提供粉丝特权，让粉丝用户更好的创造明星，追星，捧星 目标用户的金字塔： 狂热粉丝，普通粉丝，跟风粉丝（狂热粉丝为顶端） 逻辑分析 xx音乐VIP是以xx音乐及xx社区为基础的一款增值服务产品 在xx音乐平台提供增值特权，通过xx用户的粉丝效应，拉动xx音乐平台的活跃度 逻辑分析xx用户与草根明星的互动以社区产品为承载，对用户进行召集。 逻辑分析 3.6 时间规划 不同的方案有不同的应用场景： 预研类方案的规划主要是达成大目标的整体时间规划 具体产品方案的时间规划主要是开发用时的基本评估 3.7 画蓝图 说白了就是吹出一个美好的未来 为什么需要产品方案 深刻理解需求的背景 明确解决需求的路径 为项目做准备 产品方案对个人工作的帮助 信息汇总与提炼 逻辑梳理及建立 目标的明确及确认 产品如何指导项目规划 产品方案的分析基础是项目规划的依据 产品方案的发展展望是项目的目标 产品方案中产品框架是项目迭代时间估算的基本 产品方案的使用 对于个人 深刻理解需求，提炼最合适的解决路径对于项目 项目预研，项目申报，立项，甚至BP 总结 产品策略及运营的方案组合 源于需求，区别于需求 走向需求文档，可能到不了需求文档 有事没事，脑子里想想的方案 2 项目规划2.1 项目规划的意义 明确清晰地目标 有利于资源协调及执行 更有利于全团队的一起努力 2.2 项目规划的做法 立项 怎么立项 发邮件，当面汇报，等待审批均可 为什么要立项 仪式感 是不是小公司就不需要立项？ 不是，而是可以换一种形式的立项 分期 怎么分期 时间条件，技术条件，目标导向 为什么要分期 因为资源有限，竞争激烈 分期规划就不能调整了吗？ 可以调整 调整 怎么调整 看反馈，看竞品，吧更能建立核心产品竞争力的特性点提前做 看数据，把用户更喜欢的特性点做到更好的体验 2.3 规划工具Roadmap 特点： 是一个路线图，蓝图 需求预期管理：优先级，完成时间 比脑图特性列表要更重视未来的时间周期 比甘特图要弱化具体任务 不拘泥于模板形式，意义大于呈现下面两个都是Roadmap 如何制定Roadmap 明确Roadmap的排期基本目标 在有限的资源之下，优先选择更重要的事情先做，逐步达到产品目标 需求的合理并行及串行 需求之间的关联及递进关系 MVP产品理念 先保障最基本的功能实现，甚至是将需求才分完成，避免过度设计的冗余，先实现基本功能 常见错误：大而全 互联网瞬息万变，不能面面俱到 资源有限 设计部可能完美，需要用户反馈 先用最高效的方式满足用户的核心需求 Roadmap的定期回顾 每个时间周期下的规划，都需要定期的复盘 复盘可以更好的明确需求目标 及时调整需求点的优先级，以适应更好的市场竞争 2.4 使用项目规划 项目规划分类 时间管理，把控节奏 预期管理，管理好领导预期 复盘分析，上线后需回头校验 如何确定项目周期1.根据项目性质 内部项目外包项目：外包项目按需求方确定周期 整体输出型项目，迭代型项目：整体项目根据战略规划确定 客户端项目，网页项目：客户端一般2-4周，网页一般1-2周2.根据项目阶段 0-1：一般时间可能达到2个月以上 优化阶段： 1-2周左右 稳定阶段：3-4周左右3.项目重要性 极为重要：尽可能压缩周期不可延期 较为重要： 可按正常周期尽量不要延期 一般重要：可按正常周期或为其他项目让路 不重要：可延期 如何确定单个周内具体任务1.需求优先级 重要紧急任务必须做 致命BUG类型修复必须做 重要任务在有冗余时间的情况下做2.其他因素 运营需求，卡着时间点：运营提供目标后确定 合作部门需求，对方领导很看重： 根据既往合作情况确定 老板需求，没有理由：根据老板性格确定 每个任务如何规划时长1.需求规划 文档输出时间可以压缩 交互与设计时间预留充分 预留需求修改时间2.开发阶段 后端，前端时间需要确定 联调时间不可少 开发自行估计开发量3.测试阶段 测试时间一般为开发时间的0.5-1倍之间 预留bug修复时间 2.5 产品方案撰写 产品方案基本思路如图所示： 案例：孩子总被人贩子拐跑这个事，想给孩子装一个追踪器 需求 孩子不丢 分析用户 父母 分析背景 国外有Amber alert网站 国内有儿童失踪信息紧急发布平台 分析行业 儿童智能手表 儿童智能手机 便携式定位器 产品定位 职能定位产品 产品形态 可贴在衣服上的只能定位产品 与家长通讯设备连接 预期 一期产品：可续航动力，无sim卡，便于携带 二期产品：更轻便，能在身体表面，对身体无害 撰写技巧 信息加工再展示（支撑数据要得体） 数据要说明问题 说明需求真实性 说明需求重要性 说明方案合理性 关键文字不可省略 合理利用图形结构化观点 产品目标要清晰 这次要做什么 为什么要这么做 需求是否得到了充分的分析 需求方案是否得到了全面的论证 展示期望蓝图 自信 3 构建产品结构3.1 解读产品结构我们看一下整个项目的生命周期 定义结构层是五个层面中的第三次，他也是是当地将我们的关注点从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体因素在内容建设方面，主要是通过信息架构来构建用户体验。信息架构研究的使人们如何认知信息的过程，对于产品而言，信息架构关注的就是显现给用户的信息是否合理并具有意义。 我们谈的产品结构基于前期的需求分析及市场竞品分析等依据，将各个需求点以某种逻辑系统化的组织起来所形成的的立体结构基于该结构，可以顺利的引导用户行为或将各类信息进行顺畅的流转。 小结 我们需要做的有关产品结构的构建，就是把原本可能无序的各个需求点以某种结构的方式展示出来 3.2 常见的产品结构类型产品结构类型大致分为以下5种，如图所示： 层级结构优势： 符合人类天生爱分类的习惯 有较高行为操作效率 大多数产品均用这种结构案例分析：手机QQ 战略层思考 战略： 即时通讯软件 年轻人社交工具 生活方式用户及场景 年轻人，90后 非家长沟通 工作，生活，学习沟通 范围层思考 需求： 聊天 传文件 发图片 视频 群聊天任务流程 登录注册 加好友 发起聊天 结构层思考 线性结构优势： 利于表达一个故事 一步步指引符合人的单向思维 易于引导完成一个指定任务 网页时代多用于产品介绍页案例分析：短信 战略层思考 战略： 手机操作系统必备 沟通工具用户及场景 手机用户 发不紧急的消息 发存档的信息 电话不通时发信息 范围层思考 需求： 发消息 回复消息 选择对象任务流程 发消息-选择联系人 回复消息 选择联系人-发消息 结构层思考 矩阵结构优势： 可以同时满足不同用户 能够承载更多信息 展示效率更高案例分析：JD产品介绍页 战略层思考 战略： 促进销售成单 提高人均消费额用户及场景 贪便宜的 懒得 不方便实体购物的 范围层思考 需求： 展示当前商品 提供购买入口 提供促销展示 提供更多商品任务流程 查看商品 点击购买 查看其他商品 查看评论 结构层思考 自然结构优势： 鼓励人们探索 提高产品趣味性 游戏，咨询等类型产品使用（抖音）案例分析：探探 战略层思考 战略： 陌生人社交 赚钱用户及场景 寂寞者 单身者 无聊时看异性 范围层思考 需求： 查看用户 进行对应操作 个人信息补充任务流程 登录注册 查看 操作 结构层思考 在真实项目中，我们并非仅仅用一种结构，往往都是几种结构结合用 3.3 产品结构构建方式 产品结构=物理结构+逻辑结构 我们需要做的产品结构是这两者的完美结合产品结构设计的基本方法： 自上而下 自下而上 两者结合 自上而下（先梳理父节点，再依次发散） 自下而上（梳理最小的功能特性，再总结共性形成节点） 两者平衡当产品较为复杂，功能点比较多时，可以考虑两种方法混用，找到一个中间层，连贯上下 产品结构技巧: 如何提炼功能模块： 经验法：根据过往经验，推导出常用功能 涉及账户，自己过往经验进行设计 对比法：参考其他产品，列出常用功能 对比映客做直播需要发起直播，看直播，美颜功能 创造法：根据个人需求创造新功能 如keep会员会员等级体系功能 技巧一：分类 内容 分类就是要把相同或类似的东西归到一起 一层一层的分类，就可以形成同一层级的节点 分类结果以导航，TAB，页面内容，区域位置集中展示位结果 分类标准及使用 按时间，地点 按主题，按任务 混合标准 信息涉及多维度时怎么办，如何在结构分类中展示？（根据需求的优先级，重要程度；根据用户使用的场景，频率） 技巧二：以功能模块为产品结构 直接总结产品的功能模块 以功能模块为节点来形成结构 举例映客： 发起直播，我的，首页 以业务逻辑为产品结构 按业务操作流程分类 示例后台产品 基础–技术常用的操作 审稿–编辑常用的操作 审核–产品运营常用的操作 直播管理–直播运营常用的操作 快速入口 把常用的功能在首页展示 把用户可能需要的功能在相关页面展示 举例：微信的+ 举例：搭配购买 3.4 产品结构输出物 产品结构图 流程图 特性列表 产品结构图 用于展示产品各个功能模块的立体结构方式 包含物理结构 包含逻辑结构的展示 用户流程图 用户流程图用于描述以用户的视角面对一个产品或功能时可进行的操作以及对应的反馈 绘制技巧：把自己当作用户，在遇到的每一个可执行的操作时穷尽一切可能的情况，继而给出反应的反馈。 业务流程图 业务流程图是一种描述系统内各单位，人员之间的业务关系，作业顺序和管理信息流向的图表，利用它可以帮助分析人员找出业务流程中的不合理流向，它是物理模型 页面流程图 用于展示各个页面都在怎样的前置条件下展示出来 绘制技巧：穷举各项可能的操作，不同操作下展示不同的页面 总结 一般来说，产品经理经常用的是用户流程图 不同的公司类型有不同的要求，与线下结合更多的产品可能更需要业务流程图 页面流程图不经常用，可以再交互原型中展现页面之间的跳转联系"},{"title":"NodeJs2","date":"2018-12-16T01:10:47.000Z","path":"2018/12/16/NodeJs2/","text":"5 NodeJS的模块系统5.1 require导出 执行被夹在模块中的代码 得到被加载中模块的exports导出接口对象 require特点 require优先从缓存中加载 require路径 ./ 当前目录 ../ 上一级目录 /xxx根目录下某个文件（几乎不用） d:/a/foo.js 绝对路径（几乎不用） 首位/在这里表示当前文件模块所属磁盘根路径 .js可以省略 加载核心模块的本质也是本地文件 核心模块文件已经被编译到二进制文件中了，我们只需要按照名字加载就可以了 下面的例子，main.js引用了a和b，a又引用了bmain.js1234require ('./a')// 优先从缓存中加载// 有偶遇在a中已经加载过了，这里不会重复加载require('./b') a.js1console.log('a 被加载了') b.js1console.log('b 被加载了') 结果是只输出一次b 被加载了,说明再次调用b时并未真正调用，而是调用的内存 5.2 exports导出 Node中是模块作用于，默认文件中所有的成员只在当前文件模块中有效 对于希望可以被其他模块访问的成员，我们就需要吧这些公开的成员都挂载到exports接口对象中就可以了 导出多个成员 12345678exports.a = 123exports.b = 'hello'exports.c = function() &#123; console.log('ccc')&#125;exports.d = &#123; foo:'bar'&#125; 导出单个成员 1module.exports = 'hello' 一下情况会覆盖1234567module.exports = 'hello'// 这个后者会覆盖前者moudle.exports = function(x,y) &#123; return x + y &#125; 5.3 exports和moudle.exports我们可以这么理解 在Node中，每个模块内部都有一个自己的module 该moudle对象中，有一个成员叫exports 并且在node中我们定义一个exports = moudle.exports，让这两个变量指向同一个内存块 如果你需要对外导出成员，只需要把导出的成员赋到exports中 默认在代码最后有一句：return moudle.exports 这样谁require我，我就给谁moudle.exports 我们现在有两个js，a.js和b.js12var fooExport = require('./b')console.log(fooExport) 123456var foo = 'bar'function add(x,y)&#123; return x + y &#125;exports = add //不会被导出module.exports = foo// 这个才会被导出 5.4 模块加载规则这里的模块加载主要是第三方模块 凡是第三方模块都需要npm下载下来，只使用require（’包名’）的方式来进行加载 并且没有任何一个第三方包和核心包名称相同 模块加载的心路历程 先找到当前文件所处目录中的node_modules目录 找到node_modules/需要的包/package.json文件 找到node_modules/需要的包/package.json中的main属性 main属性中就记录了需要的包的入口模块 如果没有main属性就会找node_modules/需要的包下的index.js文件 如果index.js也没有就会去上一级的node_modules去寻找规则同上 如果上上上很多级直到当前磁盘的跟目录还没找到则会报错 每一个项目有且只有一个node_modules 5.5 package.json每个模块（项目）都需要一个package.json文件，该文件配置了一些模块信息以及项目操作（启动，build等）以及包以来这个文件可以通过npm init来初始化1234567891011121314151617181920212223242526272829&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"scripts\":&#123; \"start\": \"hexo server\", \"clean\":\"hexo clean\", \"build\":\"hexo generate\", \"deploy\":\"hexo deploy\" &#125;, \"hexo\": &#123; \"version\": \"3.7.1\" &#125;, \"dependencies\": &#123; \"gitment\": \"0.0.3\", \"hexo\": \"3.2.0\", \"hexo-asset-image\": \"0.0.3\", \"hexo-deployer-git\": \"0.3.1\", \"hexo-generator-archive\": \"0.1.4\", \"hexo-generator-category\": \"0.1.3\", \"hexo-generator-index\": \"0.2.0\", \"hexo-generator-json-content\": \"3.0.1\", \"hexo-generator-tag\": \"0.2.0\", \"hexo-renderer-ejs\": \"0.3.0\", \"hexo-renderer-marked\": \"0.3.0\", \"hexo-renderer-stylus\": \"0.3.1\", \"hexo-server\": \"0.2.0\" &#125;&#125; scripts该项目的脚本命令，可以自己写 devDependencies：打包之前依赖 dependencies：打包之后也需要依赖其他的简单就不说了 还有package-lock.json是依赖包的依赖 ^版本号，代表最低版本号，为了保持版本一致不建议使用 package.json和package-lock.json npm5以前是不会有package-lock.json这个文件的npm5以后才加入这个文件当安装包的时候，npm都会生成或者更新package-lock.json这个文件。 npm5以后的版本安装包不需要加–save参数，它会自动保存依赖信息 package-lock.json这个文件会报错node_modules中所有包的信息（版本，下载地址） 这样的话重新npm install的时候速度就可以提升 从文件来看，有一个lock称之为锁 这个lock是用来锁定版本的 如果项目依赖了^1.1.1版本 重新install其实会下载最新版本，而不是1.1.1 这个package-lock.json文件的另一个作用就是锁定版本号，防止自动升级 5.6 模块构建npmnpm即代表一个网站，所有js包仓库也代表一个命令模块初始化： npm init (npm init -y 快速生成) 安装所有包 npm install 安装单个包 npm install 包（@版本号） -s 打包之后也依赖 -d 打包之前依赖 -g 全局 删除包 npm uninstall 包（@版本号） -s 打包之后也依赖 -d 打包之前依赖 -g 全局 切换源地址 npm install 包 –registry 路径（修改这次下载）npm config set registry 路径(永久修改) 查看npm信息 npm config list 安装淘宝镜像 npm install -g cnpm 6 Express框架express基于 Node.js 平台，快速、开放、极简的 Web 开发框架，它已经帮我们封装好了很多包，我们直接拿来用就可以了express安装 npm install express 6.1 HELLO WORLD12345678910111213141516// 0 安装// 1 引用var express = require('express')// 2 创建你服务器的应用程序，就是原来的http.createServervar app = express();// 当服务器收到get请求的时候，执行处理回调函数app.get('/',function(req,res)&#123; res.send('hello world'); //传统的方法在这里依然可以使用 //res.write('hello world') //res.end()&#125;)// 相当于server.listenapp.listen(3000,function() &#123; console.log('服务器已启动')&#125;) 6.2 基本路由用框架之前我们的代码很丑，各种if嵌套，现在我们可以平行的开发123456789101112131415161718192021222324var express = require('express')// 2 创建你服务器的应用程序，就是原来的http.createServervar app = express();app.get('/about',function(req,res)&#123; res.send('你好，我是Express');&#125;)app.get('/',function(req,res)&#123; res.send(` &lt;DOCTYPE html&gt; &lt;html lang='en'&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello Express&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; `);&#125;)// 相当于server.listenapp.listen(3000,function() &#123; console.log('服务器已启动')&#125;) get：get请求处理123app.get('/',function() &#123; res.send('hello')&#125;) post：post请求处理123app.post('/',function() &#123; res.send('hello')&#125;) 6.3 public公开资源 var app = express()app.use(‘public’,express.static(‘./public/‘)) 第一个public相当于别名，你也可以叫a，不过再访问就需要/a/资源了 第二个参数express.static(‘./public/‘)，相当于真实的你要公开的资源目录我们在上一个代码基础上进行公开资源123456789101112131415161718192021222324252627var express = require('express')// 2 创建你服务器的应用程序，就是原来的http.createServervar app = express();app.use('public',express.static('./public/'))// 公开指定目录// 只要这样做了，你就可以直接通过/public/xx的方式访问public目录中的所有资源了app.get('/about',function(req,res)&#123; res.send('你好，我是Express');&#125;)app.get('/',function(req,res)&#123; res.send(` &lt;DOCTYPE html&gt; &lt;html lang='en'&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;hello Express&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; `);&#125;)// 相当于server.listenapp.listen(3000,function() &#123; console.log('服务器已启动')&#125;) 6.4 nodemon热更新对于nodejs我们每次编译之后都需要重启项目，很烦啊。我们可以用nodemon工具来启动node项目，实现热更新 安装全局 npm install –g nodemon 用nodemon启动项目 nodemon app.js 6.5 express重写留言板express提供了一个操作art-template的插件我们首先安装插件 npm install –save art-templatenpm install –save express-art-template 说明： app.engine(&#39;art&#39;,require(&#39;express-art-template&#39;)),第一个参数，表示当渲染以.art结尾的文件的时候（如果是.html则像我这样写成.html） express-art-template是专门用来在Express中把art-template整合到Express中 虽然这里不需要引用art-template，但是也必须先安装,原因就在于express-art-template依赖了art-template express为Response相应对象提供了一个方法：render,render方法默认是不可以使用的，但是如果配置了模板引擎就可以使用了 res.render(&#39;html模板名&#39;，{模板数据}), 第一个参数不能写路径，默认会去项目中的views目录查找该模板文件 也就是说Express有一个约定：开发人员把所有的视图文件都放到views目录中,如果在views中还有一个文件夹（admin），则res.render(‘admin/index.html’) 如果想要修改默认的views目录可以这么写,app.set(&#39;views&#39;,新的路径) 获取post信息 安装插件 npm install --save body-parser 引包 var bodyParser = require(&#39;body-parser&#39;) 配置body-parser app.use(bodyParser.urlencoded({extended:false})) app.use(bodyParser.json()) 只要加入了这个配置，则在req请求对象上会多出来一个属性：body，也就是说可以直接通过req.body来获取数据我们html页面还是之前的页面，只是修改了nodejs，如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var express = require('express')// post中间件var bodyParser = require('body-parser')var app = express()app.use('/public/',express.static('./public/'))var comments = [ &#123; name:\"张三\", message: '今天天气不错', dataTime: '2015-10-16', &#125;, &#123; name:\"张三2\", message: '今天天气不错', dataTime: '2015-10-16', &#125;, &#123; name:\"张三3\", message: '今天天气不错', dataTime: '2015-10-16', &#125;,]// 配置使用art-template模板引擎// 使用art-template模板引擎app.engine('html',require('express-art-template'))// 配置body-parser中间件app.use(bodyParser.urlencoded(&#123;extended:false&#125;))app.use(bodyParser.json())app.post('/pinglun',function(req,res) &#123; var comment = JSON.stringify(req.body,null,2) comment.dateTime = '2018-12-12' comments.unshift(comment) res.redirect('/') // 相当于 res.statusCode = 302 ; res.setHeader('Location','/')&#125;)app.get('/',function(req,res) &#123; res.render('index.html',&#123; comments:comments &#125;)&#125;)app.get('/pinglun',function(req,res) &#123; var comment = req.query comment.dateTime = '2018-12-12' comments.unshift(comment) res.redirect('/') // 相当于 res.statusCode = 302 ; res.setHeader('Location','/')&#125;)// 对于post请求我们需要用一个中间件body-parserapp.get('/post',function(req,res)&#123; res.send('post page')&#125;)app.listen(3000,function()&#123; console.log('runing...')&#125;) 7 Express管理系统7.1 系统数据和页面我们这里新建一个.json来配置数据，成为我们的数据库 db.json 12345678910&#123; \"students\":[ &#123;\"id\":1,\"name\":\"张三\",\"gender\":0,\"age\":18,\"hobbies\":\"吃饭睡觉打豆豆\"&#125;, &#123;\"id\":1,\"name\":\"张三\",\"gender\":0,\"age\":18,\"hobbies\":\"吃饭睡觉打豆豆\"&#125;, &#123;\"id\":1,\"name\":\"张三\",\"gender\":0,\"age\":18,\"hobbies\":\"吃饭睡觉打豆豆\"&#125;, &#123;\"id\":1,\"name\":\"张三\",\"gender\":0,\"age\":18,\"hobbies\":\"吃饭睡觉打豆豆\"&#125;, &#123;\"id\":1,\"name\":\"张三\",\"gender\":0,\"age\":18,\"hobbies\":\"吃饭睡觉打豆豆\"&#125;, &#123;\"id\":1,\"name\":\"张三\",\"gender\":0,\"age\":18,\"hobbies\":\"吃饭睡觉打豆豆\"&#125; ]&#125; 建立HTML列表模板代码片段12345678910111213141516171819202122&lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;&#123;each students&#125;&#125; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;&#123; / each &#125;&#125; &lt;/tbody&gt;&lt;/table&gt; 7.2 服务端NodeJs123456789101112131415161718192021222324252627var fs = require('fs')var express = require('express')var app = express()app.use('node_modules',express.static('./node_modules/'))app.use('public',express.static('./public/'))app.engine('html',require('express-art-template'))app.get('/',function(req,res) &#123; // readFile的第二个参数是可选的，传入utf-8就是告诉它把读取到的文件直接按照uft-8编码 // 除了这样来转换之外，也可以通过data.toString()的方式 fs.readFile('./db.json','utf8',function(err,data) &#123; if(err)&#123; return res.status(500).send('server error') &#125; console.log(data) &#125;) res.render('index.html',&#123; students:Json.pares(data).students &#125;)&#125;)app.listen(3000,function() &#123; console.log('runing。。。。')&#125;) 7.3 系统路由基于系统我们设计的路由列表 请求方法 请求路径 get 参数 post参数 备注 GET /students 渲染列表页面 GET /students/new 渲染添加学生页面 POST /students name,age,gender,bobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /students/edit id,name,age,gender,bobbies 处理编辑请求 GET /students/delete id 处理删除请求 我们现在想把router路由单独拿出来app.js1234567891011121314var express = require('express')var router = require('./router')var app = express()app.use('node_modules',express.static('./node_modules/'))app.use('public',express.static('./public/'))app.engine('html',require('express-art-template'))router(app)app.listen(3000,function() &#123; console.log('runing。。。。')&#125;) router.js123456789101112131415161718192021222324252627var fs = require('fs')module.exports = function(app) &#123; app.get('/students',function(req,res) &#123; // readFile的第二个参数是可选的，传入utf-8就是告诉它把读取到的文件直接按照uft-8编码 // 除了这样来转换之外，也可以通过data.toString()的方式 fs.readFile('./db.json','utf8',function(err,data) &#123; if(err)&#123; return res.status(500).send('server error') &#125; console.log(data) &#125;) res.render('index.html',&#123; students:Json.pares(data).students &#125;) &#125;) app.get('/students/new',function(req,res) &#123;&#125;) app.post('/students',function(req,res) &#123;&#125;) app.get('/students/edit',function(req,res) &#123;&#125;) app.post('/students/edit',function(req,res) &#123;&#125;) app.get('/students/delete ',function(req,res) &#123;&#125;)&#125; 对于上面的代码，Express提供了一种更好的方式专门用来包装路由的 var router = express.Router() app.js 作为app.js职责 创建服务 做一些相关配置 模板引擎 body-parser解析表单post请求体 提供静态资源服务 挂载路由 监听端口服务 123456789101112131415var express = require('express')var router = require('./router')var app = express()app.use('node_modules',express.static('./node_modules/'))app.use('public',express.static('./public/'))app.engine('html',require('express-art-template'))// 把路由容器挂在到APP服务中app.use(router)app.listen(3000,function() &#123; console.log('runing。。。。')&#125;) router.js123456789101112131415161718192021222324252627282930313233var fs = require('fs')// 1. 创建一个路由容器var router = express.Router()// 2. 把路由都挂载到router路由容器中 router.get('/students',function(req,res) &#123; // readFile的第二个参数是可选的，传入utf-8就是告诉它把读取到的文件直接按照uft-8编码 // 除了这样来转换之外，也可以通过data.toString()的方式 fs.readFile('./db.json','utf8',function(err,data) &#123; if(err)&#123; return res.status(500).send('server error') &#125; console.log(data) &#125;) res.render('index.html',&#123; students:Json.pares(data).students &#125;) &#125;) router.get('/students/new',function(req,res) &#123; res.render('new.html') &#125;) router.post('/students/new',function(req,res) &#123;&#125;) router.get('/students/edit',function(req,res) &#123;&#125;) router.post('/students/edit',function(req,res) &#123;&#125;) router.get('/students/delete ',function(req,res) &#123;&#125;) // 3. 导出router module.exports = router; 7.4 添加页面在上面HTML基础上我们需要添加一个《添加》按钮来跳转到添加页面 列表页面1234567891011121314151617181920212223242526&lt;h2 class=\"sub-header\"&gt;Section title&lt;/h2&gt;&lt;a class=\"btn btn-success\" href=\"/students/new\"&gt;添加学生&lt;/a&gt;&lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;&#123;each students&#125;&#125; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &#123;&#123; / each &#125;&#125; &lt;/tbody&gt;&lt;/table&gt; &lt;/div&gt; 添加学生页面new.html123456789101112131415161718192021222324252627&lt;div class=\"col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main\"&gt; &lt;h2 class=\"sub-header\"&gt;添加学生&lt;/h2&gt; &lt;form action=\"/students/new\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"\" name=\"name\" placeholder=\"请输入姓名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;性别&lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input class=\"radio\" name=\"gender\" id=\"inlineRadio1\" value=\"0\"&gt;男 &lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input class=\"radio\" name=\"gender\" id=\"inlineRadio1\" value=\"1\"&gt;女 &lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;年龄&lt;/label&gt; &lt;input type=\"number\" class=\"form-control\" id=\"\" name=\"age\" placeholder=\"请输入年龄\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;爱好&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"\" name=\"hobbies\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;添加&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; app.js12345678910111213141516171819202122var express = require('express')var router = require('./router')var bodyParser = require('body-parser')var app = express()app.use('node_modules',express.static('./node_modules/'))app.use('public',express.static('./public/'))app.engine('html',require('express-art-template'))// 配置模板引擎和body-parser一定要在app.use(router)挂在路由之前// parse application/x-www-forn-urlencodedapp.use(bodyParser.urlencode(&#123;extended:false&#125;))// parse application/jsonapp.use(bodyParser.json())// 把路由挂在到app下router(app)app.listen(3000,function() &#123; console.log('runing。。。。')&#125;) router.js12345678910111213141516171819202122232425262728293031323334353637var fs = require('fs')var router = express.Router() router.get('/students',function(req,res) &#123; fs.readFile('./db.json','utf8',function(err,data) &#123; if(err)&#123; return res.status(500).send('server error') &#125; console.log(data) &#125;) res.render('index.html',&#123; students:Json.pares(data).students &#125;) &#125;) router.get('/students/new',function(req,res) &#123; res.render('new.html') &#125;) router.post('/students/new',function(req,res) &#123; // 1.获取表单数据 // 2.将数据保存到db.json文件中以持久化 // 先读取出来转换成对象 // 往对象中push数据 // 把对象转换为字符串 // 把字符串再次写入文件 // 3.发送相应 &#125;) router.get('/students/edit',function(req,res) &#123;&#125;) router.post('/students/edit',function(req,res) &#123;&#125;) router.get('/students/delete ',function(req,res) &#123;&#125;) // 3. 导出router module.exports = router; 为了下面讲解方便，我们先来说一下回调函数 7.5 回调函数12345678function fn() &#123; setTimeout(function() &#123; var data = 'hello' return data &#125;,1000)&#125;console.log(fn()) 通过以上代码我们输出的结果是undifand原因是异步，我们已经输出结果的时候data还没有赋值，里面的异步方法还没有调用如果我们需要获取其中的一步操作，必须通过回调函数来获取 12345678910function fn(callback) &#123; setTimeout(function() &#123; var data = 'hello' callback(data) &#125;,1000)&#125;fn(function(data) &#123; console.log(data)&#125;) 这里的fn参数就是一个函数（回调函数callback），在异步延迟之后调用（callback（data）） 7.6 文件操作提取为了我们代码高重用性，我们把对文件（数据）的操作单独提取出来它的职责是只对文件操作，并不关心业务如何 students.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143var fs = require('fs')// 定义文件路径var dbPath = './db.json'/*** 获取所有学生列表* callback中的参数* 第一个参数是err* 成功是null* 错误对象是错误对象* 第二个参数是结果* 成功是数组* 错误是undefined* return[]*/exports.find = function(callback) &#123; fs.readFile(dbPath,'utf8',function(err,data) &#123; if(err)&#123; return callback(err) &#125; callback(null,Json.parse(data).students) &#125;)&#125;/*** 添加保存学生*/exports.save = function(student, callback) &#123; fs.readFile(dbPath,'utf8',function(err,data) &#123; if(err)&#123; return callback(err) &#125; var students = JSON.parse(data).students // 处理id唯一不重复 student.id = students[students.length - 1].id + 1; // 把用户传递的对象数据保存到数组中 students.push(student) // 把对象数据转换成为字符串 var fileData = Json.stringify(&#123; students:students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath,fileData,function(err) &#123; if(err) &#123; // 错误就把错误对象传递给前面 return callback(err) &#125; // 成功就没有错，所以错误对象是null callback(null) &#125;) &#125;)&#125;/*** 查询特定学生*/exports.findById = function(id,callback)&#123; fs.readFile(dbPath,'utf8',function(err,data) &#123; if(err)&#123; return callback(err) &#125; var students = Json.parse(data).students var ret = students.find(function(item) &#123; return item.id === parseInt(id) &#125;) callback(null,ret) &#125;)&#125;/*** 更新学生*/exports.updateById = function(student, callback) &#123; fs.readFile(dbPath,'utf8',function(err,data) &#123; if(err)&#123; return callback(err) &#125; var students = Json.parse(data).students // 把student.id统一转换成数字类型 student.id = parseInt(student.id) // 需要修改那个，就把哪个找出来 // ES6中的一个数组方法find // 需要接受一个函数作为参数 // 当某个便利符合 item.id === student.id 条件的时候find会终止便利，同时返回遍历到的实例 var stu = students.find(function(item) &#123; // 保证写入到文件中的id类型为数字 return itme.id === parseInt(student.id) &#125;) // 遍历拷贝对象 for(var key in student)&#123; stu[key] = student[key] &#125; // 把对象数据转换成字符串 var fileData = JSON.stringify(&#123; students:students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath,fileData,function(err) &#123; if(err) &#123; // 错误就把错误对象传递给前面 return callback(err) &#125; // 成功就没有错，所以错误对象是null callback(null) &#125;) &#125;)&#125;/*** 删除学生*/exports.deleteById = function(student, callback) &#123; fs.readFile(dbPath,'utf8',function(err,data) &#123; if(err)&#123; return callback(err) &#125; var students = Json.parse(data).students //findInex方法专门用来根据条件查询元素的下标 var deleteId = students.findIndex(function(item) &#123; return item.id === parseInt(id) &#125;) // 根据下标从数组中删除对应的学生对象 students.splice(deleteId) // 把对象数据转换成字符串 var fileData = JSON.stringify(&#123; students:students &#125;) // 把字符串保存到文件中 fs.writeFile(dbPath,fileData,function(err) &#123; if(err) &#123; // 错误就把错误对象传递给前面 return callback(err) &#125; // 成功就没有错，所以错误对象是null callback(null) &#125;) &#125;)&#125; router.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var fs = require('fs')var router = express.Router()var Student = require('./students') router.get('/students',function(req,res) &#123; Student.find(function(err,students) &#123; if(err)&#123; return res.status(500).send('服务器错误') &#125; students:students &#125;) &#125;) router.get('/students/new',function(req,res) &#123; res.render('new.html') &#125;) router.post('/students/new',function(req,res) &#123; // 1.获取表单数据 // 2.将数据保存到db.json文件中以持久化 // 先读取出来转换成对象 // 往对象中push数据 // 把对象转换为字符串 // 把字符串再次写入文件 // 3.发送相应 Student.save(req.body,function(err) &#123; if(err) &#123; return res.status(500).send('Server error') &#125; res.redirect('/students') &#125;) &#125;) router.get('/students/edit',function(req,res) &#123; // 1.在客户端的列表中处理连接问题（需要有id参数） // 2.获取要编辑的学生id // 3.渲染编辑页面 // 根据id把学生信息查询出来 // 使用模板引擎渲染页面 Student.findById(req.query.id,function(err,student) &#123; if(err)&#123; return res.status(500).send('Server error') &#125; res.render('edit.html',&#123; student:student &#125;) &#125;) &#125;) router.post('/students/edit',function(req,res) &#123; // 1. 获取表单数据 // req.body // 2. 更新 // Student.updateById() // 3.发送响应 Student.updateById(req.body,function(err,student) &#123; if(err)&#123; return res.status(500).send('Server error') &#125; res.redirect('/') &#125;) &#125;) router.get('/students/delete ',function(req,res) &#123; // 1.获取要删除的id // 2.根据id执行删除操作 // 3.根据操作结果发送相应数据 Student.deleteById(id,function(err) &#123; if(err)&#123; return res.status(500).send('Server error') &#125; res.redirect('/students') &#125;) &#125;) // 3. 导出router module.exports = router; 列表页面(添加一个编辑按钮和隐藏域)12345678910111213141516171819202122232425262728293031&lt;h2 class=\"sub-header\"&gt;Section title&lt;/h2&gt;&lt;a class=\"btn btn-success\" href=\"/students/new\"&gt;添加学生&lt;/a&gt;&lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;#&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;爱好&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &#123;&#123;each students&#125;&#125; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt; &lt;a href=\"/students/edit?id=&#123;&#123;$value.id&#125;&#125;\"&gt;编辑&lt;/a&gt; &lt;a href=\"/students/delete?id=&#123;&#123;$value.id&#125;&#125;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &#123;&#123; / each &#125;&#125; &lt;/tbody&gt;&lt;/table&gt; &lt;/div&gt; 修改学生页面（添加个隐藏域,然后就是给表单中的input添加默认值）edit.html1234567891011121314151617181920212223242526272829&lt;div class=\"col-sm-9 col-sm-offset-3 col-md-10 col-md-offset-2 main\"&gt; &lt;h2 class=\"sub-header\"&gt;修改学生&lt;/h2&gt; &lt;form action=\"/students/new\" method=\"post\"&gt; &lt;!--用来存放一些不希望客户看到的，但是需要被提交到服务器端的数据--&gt; &lt;input type=\"hidden\" value=\"&#123;&#123;student.id&#125;&#125;\" name=\"id\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"\" name=\"name\" placeholder=\"请输入姓名\" value=\"&#123;&#123;student.name&#125;&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;性别&lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input class=\"radio\" name=\"gender\" id=\"inlineRadio1\" value=\"0\"&gt;男 &lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input class=\"radio\" name=\"gender\" id=\"inlineRadio1\" value=\"1\"&gt;女 &lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;年龄&lt;/label&gt; &lt;input type=\"number\" class=\"form-control\" id=\"\" name=\"age\" placeholder=\"请输入年龄\" value=\"&#123;&#123;student.age&#125;&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"\"&gt;爱好&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"\" name=\"hobbies\" value=\"&#123;&#123;student.hobbies&#125;&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;添加&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 7.7 总结一下编写的步骤 处理模板 配置开放静态资源 配置模板引擎 简单路由：/students渲染静态页面出来 路由设计 提取路由模块 由于接下来一些列业务都需要处理数据文件，所以我们自己封装students.js 先写好student.js文件结构 查询所有学生列表 findById save updataById delereById 实现具体功能 通过路由接收请求 接收请求中的数据（get，post） req.query req.body 调用数据操作API处理数据 根据操作结果给客户的发送响应 业务功能属性 列表 添加 编辑 删除"},{"title":"NodeJs1","date":"2018-12-15T01:50:17.000Z","path":"2018/12/15/NodeJs1/","text":"0 NodeJS背景0.1 NodeJS是什么我们先看看官网上如何评价 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 首先为什么说是基于Chrome V8 引擎？因为在此之前js只能作为前端开发，并且运行在浏览器中。直到Chrome V8 引擎出现才把js分离出来运行在后台。其中Chrome V8 引擎可以理解为JVM，是js的运行环境。 0.2 NodeJS和JS有什么区别其实两者底层基本一样，语法都是基于ECMAScript。 NodeJS 没有BOM和DOM操作。 提供了一些os(操作系统)、file system(文件系统)、net(网络系统)、database(数据库)的API。 直接运行在命令窗口，需要NodeJS环境。 WebJS 具有BOM和DOM操作。 不具有其他的服务端API。 运行在浏览器上。 我们可以在这里查看Node的API。 0.3 NodeJS安装去官网下载之后下一步下一步即可运行脚本方法： node 文件.js 1 NodeJS基本用法1.1 NodeJS读取文件在操作文件之前我们先引用包（类似于java中引用jar包） var fs = require(‘fs’) 这里的fs就是我们的操作文件包 写文件拿到fs对象后调用writeFile方法具体代码参考如下 123456789var fs = require('fs');// 第一个参数：文件路径// 第二个参数：文件内容// 第三个参数：回调函数 // 成功时：error是null // 失败时：error是错误对象fs.writeFile('./data/test.md',\"hello word\",function(error) &#123; console.log('文件写入成功')&#125;) 读文件拿到fs对象后调用readFile方法具体代码参考如下 12345678910111213var fs = require('fs');// 第一个参数：文件路径// 第二个参数：回调函数 // 成功时：error是null，data是对象 // 失败时：error是错误对象，data是空fs.readFile('./data/test.md',function(error,data) &#123; // 这里返回的是二进制数据，我们需要通过toString方法把其转换为我们认识的字符 if(error)&#123; console.log('文件读取失败了') &#125;else&#123; console.log(data.toString()) &#125;&#125;) 1.2 HTTP核心模块 加载http核心模块 使用htto.createServer()方法创建一个web服务器，返回一个Server实例 服务器可以接收请求和发送请求 通过request.url判断请求路径 通过response.write()来发送相应数据（一定要使用end结束，否则客户端会一直等待） 绑定端口号，启动服务 我们参考下面代码12345678910111213141516171819// 加载http核心模块var http = require('http')// 使用http.createSrever()方法创建一个web服务器，返回一个Server实例var server = http.createServer();// 服务器可以接收请求和发送请求server.on('request',function(request,response) &#123; console.log('收到客户端的请求了'); // 通过request.url判断请求路径 console.log('收到客户端的请求路径是'+request.url); // 发送返回数据 response.wirte('hello'); // 结束会话 response.end(); // 上面的方法也可以这么写 response.end('hello');&#125;)// 绑定端口号，启动服务server.listen(3000,function() &#123; console.log('服务启动了');&#125;) 根据不同路径判断输出不同的值响应只能是字符串或二进制，所以我们需要把JSON转成字符串1234567891011121314151617181920212223242526272829303132// 加载http核心模块var http = require('http')// 使用http.createSrever()方法创建一个web服务器，返回一个Server实例var server = http.createServer();// 服务器可以接收请求和发送请求server.on('request',function(request,response) &#123; var url = request.url; if(url === '/')&#123; response.end('index') &#125;else if(url === '/login')&#123; response.end('login') &#125;else if(url === '/products')&#123; var products = [ &#123; name:'12', price: 12, &#125;, &#123; name:'22', price: 22, &#125;, ] // 响应只能是字符串或二进制，所以我们需要把JSON转成字符串 response.end(JSON.stringify(products)); &#125;else&#123; response.end('404') &#125;&#125;)// 绑定端口号，启动服务server.listen(3000,function() &#123; console.log('服务启动了');&#125;) 1.3 其他API 获取机器信息直接看代码 123456//用来获取机器信息的var os = require('os');//获取当前机器的cpuconsole.log(os.scpus());//获取内存console.log(os.totalmem()); 操作路径直接看代码 1234//用来获取机器信息的var path = require('path');//获取一个路径中的扩展部分console.log(path.extname('c:/a/b/c/d/hello.text')); 2 Node中的几点说明2.1 模块化编程首先现在js无论前端还是后端都是模块化编程，ES6中用import和export来进行模块导入导出在nodeJS中我们用require和export来实现导入导出 require是一个方法，它是用来加载模块的 node中有两种模块 具名的核心模块（fs,http） 用户自己编写的的文件模块 相对路径必须加./ 不过可以省略后缀名（.js） 在Node中，没有全局作用域，只有模块作用于 外部访问不到内部 内部也访问不到外部 exports可以把所需要的被外部访问的成员在此定义 exports默认是一个空对象我们来看一个例子，创建两个js（a.js，b.js）123456789var foo = 'aaa'console.log('a start')function add(x,y)&#123; return x + y;&#125;var ret = require('./b,js')console.log(ret.foot) // 调用b中变量console.log(ret.add(10,30)) // 调用b中变量console.log('a end') 1234567console.log('b start')// console.log(add(10,20)) 这个是错误的，因为b中无法调用a中方法exports.foo='hello'; // 交给exports让外部可以调用exports.add = function(x,y)&#123; return x + y;&#125;console.log('b end') 2.2 模块化编Content-Type在我们发送返回消息(response)的时候，我们返回给浏览器信息时通常加上请求头 response.setHeader(‘Content-Type’,’text/html; charset=utf-8’) Content-Type我们可以理解为header的Key text/html传输的文本类型 charset=utf-8传输的字节编码，这里为utf-8 这时候我们可以再浏览器返回值值中查看如图所示： 请看下面一段代码1234567891011121314151617181920212223// 加载http核心模块var http = require('http')// 使用http.createSrever()方法创建一个web服务器，返回一个Server实例var server = http.createServer();// 服务器可以接收请求和发送请求server.on('request',function(request,response) &#123; var url = request.url; if(url === '/plain')&#123; // text/plain就是普通文本 res.setHeader('Content-Type','text/plain; charset=utf-8'); response.end('hello 世界') &#125;else if(url === '/html')&#123; // text/html就是html标记语言，浏览器会进行渲染 res.setHeader('Content-Type','text/html; charset=utf-8'); response.end('&lt;p&gt;hello world &lt;a herf=\"\"&gt;点击&lt;/a&gt;&lt;/p&gt;') &#125;else&#123; response.end('404') &#125;&#125;)// 绑定端口号，启动服务server.listen(3000,function() &#123; console.log('服务启动了');&#125;) 而我们通查不把HTML写在js中，而是通过fs模块进行读取.html 1234567891011121314151617181920212223242526// 加载http核心模块var http = require('http')var fs = require('fs')// 使用http.createSrever()方法创建一个web服务器，返回一个Server实例var server = http.createServer();// 服务器可以接收请求和发送请求server.on('request',function(request,response) &#123; var url = request.url; if(url === '/')&#123; fs.readFile('./resource/index.html',function(err,data) &#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); response.end('文件读取失败') &#125;else&#123; res.setHeader('Content-Type','text/html; charset=utf-8'); response.end(data) &#125; &#125;) &#125;else&#123; response.end('404') &#125;&#125;)// 绑定端口号，启动服务server.listen(3000,function() &#123; console.log('服务启动了');&#125;) Content-Type的更多类型请点击这里 3 NodeJs实现服务器3.1 访问路径访问本地数据这里我们可以通过http获取访问的路径，之后用fs来读取我们该路径下固定文件夹下的具体文件123456789101112131415161718192021222324var http = require('http')var fs = require('fs')var server = http.createServer();// 定义访问路径var wwwDir = 'D:/Movie/www'server.on('request',function(request,response) &#123; var url = request.url; var filePath = '/index.html'; if(url !== '/')&#123; filePath = url; &#125; fs.readFile(wwwDir + filePath,function(err,data) &#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); response.end('文件读取失败') &#125;else&#123; res.setHeader('Content-Type','text/html; charset=utf-8'); response.end(data) &#125; &#125;)&#125;)server.listen(3000,function() &#123; console.log('服务启动了');&#125;) 3.2 替换模板文件要做到替换模板文件我们需要做两个操作 得到wwwDir目录列表中的文件名和目录名（fs.readdir） 将得到的文件名和目录名替换到template.html中 在template.html中需要替换的位置预留一个特殊标记 根据files生成需要的HTML内容 我们创建一个.html，下面是一段代码片段123&lt;td data-value=\"apple/\"&gt; &lt;a class=\"icon dir\" herf=\"D:/Movie/www/apple/\"&gt;^-^&lt;/a&gt;&lt;/td&gt; 我们把^-^特殊标记替换成我们自己想要的名字可以用replace替换123data = data.toString()data = data.replace('^-^','苹果')res.end(data) 3.3 Art-Template我们用art-template插件来完成替换功能，官网art-template既可以用在web上也可以用在Nodejs中art-template是将文件看成字符串，即使在js中的模板也会被替换掉，至于执行js那是浏览器的事儿 安装 npm install art-template 该命令在哪里执行就会把包下载到哪里。默认下载到node_moudules目录中 web引用 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;111&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--注意：在浏览器中需要引用/lib/template-web.js文件--&gt; &lt;script src=\"node_modules/art-template/lib/template-web.js&gt;\" &lt;script type=\"text/template\" id=\"tp1\"&gt; 名字: &#123;&#123; name &#125;&#125; 年龄: &#123;&#123; age &#125;&#125; 来自: &#123;&#123; provice &#125;&#125; // 这里是循环 喜欢: &#123;&#123;each hobbies&#125;&#125; &#123;&#123;$value&#125;&#125; &#123;&#123;/each&#125;&#125; &lt;/script&gt; &lt;script&gt; var ret = template('tp1',&#123; name : 'Jack', age: 18, provice: '北京', hobbies:['写代码','唱歌','打游戏'] &#125;) console.log(ret) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Node引用 在需要使用的地方加载art-template模块 12345678910111213141516171819202122var template = require('art-template')var tplStr = `&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;111&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;名字: &#123;&#123; name &#125;&#125;&lt;/p&gt; &lt;p&gt;年龄: &#123;&#123; age &#125;&#125;&lt;/p&gt; &lt;p&gt;来自: &#123;&#123; provice &#125;&#125;&lt;/p&gt; &lt;p&gt;喜欢: &#123;&#123;each hobbies&#125;&#125; &#123;&#123;$value&#125;&#125; &#123;&#123;/each&#125;&#125;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;` var ret = template(tplStr,&#123; name : 'Jack', age: 18, provice: '北京', hobbies:['写代码','唱歌','打游戏'] &#125;) console.log(ret) 3.4 改进服务器代码12345678910111213141516171819202122232425262728293031var http = require('http')var fs = require('fs')var template = require('art-template')var server = http.createServer();// 定义访问路径var wwwDir = 'D:/Movie/www'server.on('request',function(request,response) &#123; var url = request.url; fs.readFile('./template',function(err,data) &#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); response.end('404 Not Found') &#125;else&#123; res.setHeader('Content-Type','text/html; charset=utf-8'); fs.readdir(wwwDir,function(err,files) &#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); response.end('Can not find wwDir.') &#125; &#125;) // 接下来就是文本替换了 var htmlStr = template.render(dara.toString(),&#123; // 要替换的文本 &#125;) res.end(htmlStr) &#125; &#125;)&#125;)server.listen(3000,function() &#123; console.log('服务启动了');&#125;) 3.5 静态文件资源作为我们的服务端，不可能让用户能访问我们所有的文件，所以我们需要管理哪些资源用户可以访问，哪些不可以，能访问的就是我们所谓的静态资源 当我们访问服务器发生了以下几个重大事件 1.浏览器服务器2.服务器读取模板文件3.模板文件替换后在浏览器中渲染4.浏览器运行代码，当读到link，script等标签时需要再去服务器获取资源5.服务器判断请求路径是否可以访问 12345678910111213141516171819202122232425var http = require('http')var fs = require('fs')var server = http.createServer();// 定义访问路径server.on('request',function(request,response) &#123; var url = request.url; if(url === '/')&#123; fs.readFile('./views/index.html',function(err,data) &#123; if(err)&#123; res.setHeader('Content-Type','text/plain; charset=utf-8'); response.end('文件读取失败') &#125;else&#123; res.setHeader('Content-Type','text/html; charset=utf-8'); response.end(data) &#125; &#125;) &#125; else if(url.indexOf('/public/') === 0 )&#123; // 判断当访问路径含有/public/ fs.readFile('.'+ url) &#125;&#125;)server.listen(3000,function() &#123; console.log('服务启动了');&#125;) 这里还需要说明一下，我们在模板引擎中的link，script标签，引用地址应该是一个相对路径一个url地址，而不是绝对的了因为在浏览器真正发送请求的时候会把http://127.0.0.1:3000拼上1&lt;link rel=\"stylesheet\" href=\"/public/lib/....\" 同理我们的a标签引用如果是页面内部调整也需要考虑到服务器，比如跳转到首页我们可以这样写 1&lt;a href=\"/\"&gt;&lt;/a&gt; 4 案例整合通过这些知识，我们用一个留言板的案例来整合所学习的知识 4.1 HTML模板部分我们用Art-Template来作为我们的模板 消息列表页面 123456789&lt;div class=\"comments container\"&gt; &lt;ul class=\"list-group\"&gt; &#123;&#123;each comments&#125;&#125; &lt;li class=\"list-group-item\"&gt; &#123;&#123;$value.name&#125;&#125;说&#123;&#123;$value.message&#125;&#125; &lt;span class=\"pill-right\"&gt;&#123;&#123;$value.dataTime&#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 添加消息页面 123456789101112131415161718// 表单中需要提交的元素必须具有name属性// 1.默认提交行为// action 就是表单提交的地址，说白了就是url的请求地址// method 请求方法// 2.表单异步提交（ajax）&lt;from action=\"/pinglun\" method=\"get\"&gt; &lt;div class=\"from-group\"&gt; &lt;label for=\"input_name\"&gt;你的名字&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" required minlength=\"2\" maxlength=\"10\" id=\"input_name\" placeholder=\"请输入姓名\" name=\"name\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"textarea_message\"&gt;留言&lt;/label&gt; &lt;textarea class=\"form-control\" name=\"message\" id=\"textarea_message\" cols=\"30\" rows=\"10\" required minlength=\"5\" maxlength=\"20\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;发表&lt;/button&gt;&lt;/from&gt; 4.2 url.parse()url.parse()用来解析url和参数我们可以在命令行输入node进入node环境测试 node url.parse(‘http://127.0.0.1:3000/pinglun?name=zhangsan&amp;message=1234456&#39;) 结果如图所示 url.parse(‘http://127.0.0.1:3000/pinglun?name=zhangsan&amp;message=1234456&#39;,true) 结果如图所示 可以看出url.parse不近能帮我们解析出url还能帮我们解析出参数 4.3 NodeJs部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374var http = require('http')var fs = require('fs')var template = require('art-template')// 引入url解析var url = require('url')var server = http.createServer();var comments = [ &#123; name:\"张三\", message: '今天天气不错', dataTime: '2015-10-16', &#125;, &#123; name:\"张三2\", message: '今天天气不错', dataTime: '2015-10-16', &#125;, &#123; name:\"张三3\", message: '今天天气不错', dataTime: '2015-10-16', &#125;,]server.on(function(req,res) &#123; //使用url.parse方法将路径解析为一个方便操作的对象 var parseObj = url.parse(req.url,true); //获取不包含字符串部分路径 var pathname = parseObj.pathname; if(pathname === '/')&#123; fs.readFile('./views/index.html',function(err,data)&#123; if(err)&#123; return res.end('404 Not Found') &#125; var htmlStr = template.render(data.toString(),&#123; comments:comments &#125;) res.end(htmlStr) &#125;) &#125; else if(pathname === '/pinglun')&#123; // 这里我们需要做到以下几步 // 1. 获取表单提交的数据 // 2. 生成日期到数据对象中，然后存储到数组中 // 3. 让用户重定向跳转到首页/ var comment = parseObj.query comment.dataTime = '2018-12-12' comments.push(comment); //这时候服务端已经把数据存储好了，接下来让用户重定向到首页 //1. 状态码设置为302临时重定向 // statusCode //2. 在响应头中通过Location告诉客户端往哪从定性 // setHeader //如果客户端发现收到服务器端的响应状态码是302就会自动去响应头中找Location //所以就能看到客户端自动跳转了 res.statusCode = 302; res.setHeader('Location','/'); // 一次请求对应一次响应结束 res.end(); &#125; else&#123; // 其他的都处理成404找不到 fs.readFile('./vies/post.html',function(err,data) &#123; if(err)&#123; return res.end('404 Not Found') &#125; res.end(data) &#125;) &#125;&#125;)server.listen(3000,function() &#123; console.log('服务启动了');&#125;)"},{"title":"需求分析","date":"2018-12-09T09:38:27.000Z","path":"2018/12/09/需求分析/","text":"1 需求的定义1.1 什么是需求需求是为了满足某类用户的某种欲望或解决某些问题时所产生的现象 1.2 需求的层次马斯洛需求层次理论 生理需求&gt;安全需求&gt;社交需求&gt;尊重需求&gt;自我实现 生理需求：饿了么安全需求：360社交需求：QQ，微信尊重需求：知乎自我实现：抖音 1.3 刚需/痛点，痒点 痛点对应的就是解决核心的问题，痛点就是刚需 痒点就是满足欲望，是消费升级的副产品 1.4 需求的分类需求按分类分为内部需求和外部需求 内部需求 外部需求 用户需求 客户/合作需求 运营需求 市场需求 技术需求 数据需求 用户需求解决或满足用户在某些场景下为了达到某些目的所产生的需求 运营需求满足公司内部运营对某类事件或活动所产生的推广等性质的需求 技术需求代码重构，系统安全等，技术人员提出的需求 数据需求 基本数据 用户数据 点击埋点 路径漏斗 数据知道产品，需要做到问道任何数据，均可以流畅的回答 客户需求/合作需求 需要平衡商业展示和用户体验（比如：观看视频之前的广告，有一定的收入但是影响用户体验） 市场/战略需求 战略需求往往代表着市场的前沿，具有一定的前瞻性与风险 1.5 需求的来源 用户访谈 主要通过用户调研和市场调研 定性|定量面对面访谈|问卷调查可用性测试|PUSH|有偿调查 定性走开放性问题，定量走简单可选择的问题观察&gt;引导，深挖但不被误导 数据分析通过基础的数据分析辅佐你想要优化的方向，是做需求的核心目的之一。 基本数据 Crash DAU/MAU 留存 用户数据 性别 地狱 标签（包括购买率，页面流失情况，功能使用情况，产品情况） 点击埋点 点击次数 点击人数 路径漏斗 页面层级 页面流失 竞品分析 选择相当的竞品 功能颗粒度足够细 长期维护（带版本） 发觉竞品路线 学会标注重点 用户反馈用户反馈主要通过用户评论用户反馈还可以通过微博，QQ/微信群，贴吧，亲朋好友，各类应用市场获取 头脑风暴 3-8人 定义一个主题 提前准备 1.6 四要素比对需求提炼中注意4个要素 人物 场景 任务 目标 案例：建议能将运动中拍到的照片传到运动的轨迹中去，便于查询存档。 人物 场景 任务 目标 用户属性 运动结束后 上传照片到轨迹 查询，存档？ 运动属性 一个爱运动的女性 人物 场景 任务 目标 使用者&amp;决策者 用户使用场景vs产品提供场景 多样性 用户的目标vs我们的目标 人群：宽&amp;窄 复杂程度 用户属性 习惯性的对每个需求都拆分成4个结构，并对其进行分析比对，然后筛选出我们真正的需求。 1.7 需求的转化 2 需求转化我们需要把来自各方的需求转化为我们产品的真正需求 两个例子 用户需求：希望有一个搜索评论的功能，有些歌忘了名字，但是还记得评论 1234产品需求：发现音乐搜索支持搜索评论·新增搜索评论类型·搜索结果页面新增评论TAB 2.用户需求：增加学习时长分享功能，统计的学习时长可以让用户进行“晒”12产品需求：·新增学习记录分享页面，支持微信，微博，朋友圈分享 2.1 需求表达常见的问题 问题 思考不够全面 关联性不够清晰 复杂逻辑梳理困难 文字表达不直观 产品，研发，测试缺少统一参照标准 解决办法 发散思维 层级关系，俯视地图 梳理逻辑关联 图形化表达 归档 解决工具 思维导图 产品结构图，功能结构图 功能/页面流程图 交互原型图 需求文档 生命周期 分析调研 梳理思维 归纳逻辑 可视化 文档化 工具推荐 纸笔/XMind XMind XMind Axure Word 接下来我们来详细看一下这些解决办法 2.2 思维导图有一点儿想法就要记录在思维导图上，大而全，我们以后会进行细致赛选 思维导图是什么？ 可以总结为1点多线1面 思维导图有什么作用 从点到面的联想 理清思路 记录灵感 2.3 产品结构图 产品结构图要点 重在呈现整体产品结构 体现模块/页面之间的关系 页面&amp;功能 颗粒度粗而全 防止出现缺页面，缺少模块的现象，以鸟瞰的方式对整个产品的页面结构形成一个直观的认识 2.4 功能结构图功能图可以画多个，每个功能一个图，比如登录功能图功能结构图特点： 颗粒度足够细 适度提炼 比如一个音乐播放器的功能图如下： 2.5 流程图流程图可以不用多说了，在高中课本中就学过流程图 功能流程图我们来看一个用户登录的案例：用户点击登录，有账号直接登录，无账号引导注册，登陆支持第三方登录，第一次第三方登录引导绑定手机： 页面流程图特点： 功能归类为页面 判断层级关系 评估用户行为路径 判断工作量 泳道图 这个是高级的流程图 产品时跨端的 业务流程是在不同角色/平台之间切换 2.6 交互原型图一般原型我们都用Axure画，当然PS的图片也可以算一种原型图，更当然，静态页面实现简单的交互也可以算原型图。只不过写静态页面成本高，没有Axure有效率特点: 高仿真 有交互 俯视地图（页面流程图） 下图也是一张交互原型图 2.7 需求文档有了这些我们最好再有一个需求文档来帮助我们归档特点 写给自己和测试看的 保持更新 区分更新字体 文字+图混搭 需求文档，作为3大文章之一（市场，竞品，需求）。我们后面在详细说明。 3 需求管理需求管理主要有一下几个部分组成 需求池管理 明确接口人 明确时间 保持更新 保持反馈 去伪存真 用户 场景 数据 成本 优先级判断 用户判断 场景判断 生命周期 需求马斯洛 紧急重要四象限 产品迭代 版本规划 3.1 需求池什么事需求池？ 需求池就是各式各样需求的集合地，也是灵感和思绪的归宿，更是版本需求的出口 需求池需要明确四个特性 明确接口人 明确需求收集时间 保持更新 保持反馈 我们来看一个需求池例子 编号 模块 需求描述 需求类型 接口人 优先级 责任人 版本排入 1 支付 支付成功页新增3个广告位 运营需求 XXX P1 XXX v1.2 2 首页 首页新增宝马广告位 宝马合作需求 XXX P4 XXX v1.1 3 支付 重构支付流程页面 技术需求 XXX P3 XXX 待排入 4 支付 购物车-支付页新增路径埋点 数据需求 XXX P0 XXX v1.3 当然我们也需要有一个自己的需求池（收集自己的点子） 编号 模块 需求描述 需求类型 接口人 优先级 责任人 版本排入 7 商品支持拼多多模式 商品支持拼多多模式 idea 无 待定 待定 3.2 Feature ListFeature List（需求列表）需求列表是需求池的衍生物我们可以建立一个需求列表。如下 模块 子模块 功能 功能描述 目标描述 需求来源 需求类型 优先级 工作量 备注 说明： 大的功能点 二级分类 具体功能名称 解决问题的行为与操作 可量化及明确的点 举例： 播放器 播放控制条 单手控制 用户在地铁或行走时，能通过单手操作进行播放控制，达到编解码目的 转双手控制进度,音量至单手操作比例30%以上，误触比例为0.01%以下 用户反馈 用户需求 P1 7人日 需要进行数据埋点，挖掘误触率 3.3 去伪存真说白了就是真需求，假需求。这个其实是仁者见仁智者见智的一个东西，不过我们可以根据以下几个标准来衡量 以用户为中心 以用户为中心，模拟/研究用户使用习惯和思考方式，深挖用户真正的底层需求 以场景为中心 看看这个需求是不是符合我们的产品，总不能让我的QQ产品来实现点餐 以数据为均衡标准 通过上线之后的版本和之前得版本对比，来看看这次修改的需求效果如何，是否反而减少了用户量 以成本为考量我们可以如下图评估一下 我们需要找到最第二象限的需求，优先级高 3.3 优先级判断需求优策略 线上问题优先 核心业务优先 战略需求优先 我们可以把需求分成四个象限，如图所示 我们看一下各个象限的问题 紧急又重要的事情太多，代表需求管理有问题 重点放在重要不紧急的事情； 对于紧急不重要的事情可以做，但不要投入过多的人力和经理 尽量不要做不重要也不紧急的事 对此我们可以从以下四个部分吧需求分成P0-P3（其实最好是P0-Pn） 生命周期判断根据目前我们产品正处于的生命周期来排序我们需求的优先级生命周期如图所示： 马斯洛需求分析法根据马斯洛需求分析法，判断我们的需求属于哪个层次 用户分析法看我们的需求是否接近核心用户，重叠度越高则需求越优先 场景分析法和我们产品契合度高的业务优先级高根据使用人数，产生问题频次，还有满意度"},{"title":"竞品分析","date":"2018-12-09T02:35:50.000Z","path":"2018/12/09/竞品分析/","text":"1 竞品分析的概念介绍1.1 什么是竞品分析竞品分析顾名思义，是对竞争对手的产品进行比较分析。值对现有的潜在竞争产品的优势和劣势进行评价。在用户体验行业，则更加倾向于同类产品的分析，特别是产品交互界面，视觉表现方面的分析。 1.2 什么时候竞品分析竞品分析使用阶段以及调研目标我们来看一个表格，表格从左到右是项目的进展 需求分析 立项 设计阶段 上线验证 产品经理 确定方向，了解市场 差异点，功能，框架创新，优缺点分析 用户研究 参考竞品用户群体以及需求优先级 对比竞品已完成情况，用户反馈，输出结果 交互设计 竞品主要任务流程，页面框架，逻辑性，页面语言风格 视觉设计 色彩，颜色层次，页面细节 1.3 竞品分析的目的 选中目标+行为移植+价值分析 = 收益 找准对的目标，寻找目标身上的价值移植到我们的产品中，并添加我们自己的价值来创造收益 选择&gt;分析&gt;罗列 1.4 如何做竞品分析 选择竞品 竞品选择我们有两种，一种是直接对手，一种是间接对手 直接对手： 市场范围相似&amp;商业模式相似 客户群体相似 产品功能差异不大 间接对手： 市场范围相同&amp;商业模式不同 客户群体相似 产品功能互补，或未来存在重叠的可能 分析维度和决策依据我们可以列出一个excel表格来分析 竞品1 竞品2 竞品3 维度1 数据 维度1 分析维度的选择取决于你的目标，例如 目标1：我想知道哪些功能，哪些功能属性必不可少，值得借鉴一番（维度：功能穷举） 目标2：我想知道如何进行细节设计（维度：操作任务） 目标3：我想知道这些产品最终突出细节特点是什么，值得借鉴一番（维度：设计特点） 决策依据则反映了你的专业性这么多维度的结果数据，你到底在乎哪些？目标1：我想知道哪些功能，哪些功能属性必不可少，值得借鉴一番（维度：功能穷举）以新闻为例 腾讯新闻（优先级3星） 网易新闻（优先级3星） … 内容 新闻头条 分类新闻 图片 视频 专题 博客 比赛分数 股票市场信息 新闻（网友） 评论（媒体） 评论（媒体） 功能 新闻排行 follow新闻 用户编辑贡献新闻 根据位置推送新闻 自定义导航 天气 投票 目标2：我想知道如何进行细节设计（维度：操作任务）就是基于用户的视角来体验产品 打开应用 选择频道 浏览标题列表 刷新 获取更多 进入/推出文章 阅读文章 阅读 自定义阅读模式（字体，背景） 查看文章内图片 分享/保存/收藏 阅读上一篇/下一篇 返回标题列表 浏览图片 查看图片 图片切换 获取数据 可以试用通过用户了解竞争产品使用百度指数等工具获取数据拨打竞争产品的客服了解竞品产品 分析 提出合理假设：我们认为某某竞品的成功因素如下…在这些要点中，他们形成了如下的闭环…这个闭环的业务链条，对其所相关的用户/商家等操作者带来了如下的价值… 对假设进行逆向确认如果没有某某功能要点，竞品的价值链条会变成下面这样…这可能导致的结果有… 对自己的产品进行剖析现在我们对标的产品，其在应用价值方面，优缺点如下…我们的价值链条用如下方式闭环…我们对相关的用户/商家等操作者带来了如下价值…与竞争对手相比，我们的整条价值链的差异在哪里…这些差异会导致我们好竞品的敌手存在这些强弱之处… 在SWOT模型中一般SO说的是自己，WT说的是自己与竞品对比后的结果 给出可执行的结论经过以上分析，我们的产品改进方向如下…改进步骤如下…改进的各个阶段，我们对竞标产品的竞争优势情况如下… 沟通 深入其中的人往往忘记了别人还在边缘把自己当做一个教室重复重复再重复 1.5 竞品分析模板 行业背景 确定竞品 竞品分析3.1 定位及功能 产品定位（包括目标人群等） 产品功能3.2 设计和技术 交互和体验 视觉和风格 亮点功能和核心技术3.3 运营及商业化 运营模式 盈利模式 市场推广3.4 用户数据 用户数量和活跃度 转化率，健康度 在线时长 地域差异3.5 策略 版本迭代和演变 公司策略3.6 优缺点借鉴 总结 2 几个问题 为什么市场分析已经做了精品相关的内容，还需要专门做竞品分析？ 对应的时机不同：时长分析一般是在初试一个产品的时候进行的。而竞品分析则会在产品的整个生命迭代周期里都会做 侧重点不同：市场分析的竞品分析内容，基本上是蜻蜓点水的进行简要概括，而竞品分析则非常细致，从流程，界面，用户体验，核心价值点等各个方面进行比对。 我做了一个创新产品，在世面上好像没有类似的产品，那竞品分析怎么搞? 不用搞，请专注于市场分析，并明确产品迭代策略，等精品出现了再去研究它。"},{"title":"市场分析","date":"2018-12-08T03:17:36.000Z","path":"2018/12/08/市场分析/","text":"1. 市场容积我们经常听到一种说辞：这个项目，我个人感觉有/没有市场。。。我都是生活在一个真实的世界中，我们都会对某件事物接受程度有个模糊认识，其中最典型的就是如果你处在某个行业，或者热衷于某个领域，就会觉得周围都是在这个领域中的人，就会觉得这个领域中的想法很有市场其实这个只是一个很片面，很模糊的观点，大多数都很不靠谱 1.1 市场容积分析我们首先要考虑3个问题 目标用户群体量多大？有多少市场潜力 （他们有多少人） 针对目标产品，其应对的用户群的需求点有那些？（他们用了我产品会变成什么样） 目标用户痛点如何？当前在用何种方式解决？（他们现在怎么样） 市场容量分析是产品落地的基础当我们有一个点子出现的时候，如果要落地为产品，总要做下市场容量分析。1) 看看自己的点子前景如何？2) 也为后期争取项目资源做好理论依据。 1.2 如何获取市场容积具体操作是需要我们收集一些权威的网站报告。比如中研网,中国报告大厅,中国产业信息研究网当然我们也可以去百度文库搜索搜索 案例：家电医保卡12345根据商务部流通服务业典型企业调查数据，2014年家电服务业全国经营单位有10.8万个，从业人员为312.1万人，全行业四项主要业务（装，洗，养，修）营业收入为1956.5亿元，比2013年提高了11.8%。2014年的数据表明，家电服务市场已经在我国形成了千亿级别的市场，而且保持了较高的增长率。（数据来源：《中国家电服务行业发展报告2015》） 家电医保卡。这是一个针对家电进行售后服务的产品，这个案例中总结几个小技巧1) 一般来说，隔一年的诗句是很容易看到免费报告的。类似2017年能看到2015年报告。2) 所以，如果出现这种情况，记得做下趋势/增长率分析。这会对我们预估现有的市场容量做一个参考。3) 要有产品针对性。例如家电医保卡这种需要地域竞争的产品，就需要做好地域分布分析。 2. 需求点2.1 什么是需求点继续看上面的例子。众所周知，大家电品类是现在电商的重点品类，仅天猫，京东，苏宁等电商，该品类的年GMV汇总已经超过千亿元。可是，在购买了大家电以后，下一步的电商服务会有哪些？ 电器品类 服务市场需求点 空调 清除过滤网，蒸发器等内部灰尘，清除病菌潜在危险 内外机移机，主要有搬家等场景，让空调在新的地点继续使用 油烟机 解决用户自行清洗的费时费力，以及专业的清洗效果 洗衣机 清除内外桶之间积垢，消除病菌潜在的危险 冰箱 清除冰箱内部污垢，消除异味 热水器 清除热水器内外水垢，杂质，提高电器工作效率 热水器移机，同样也是搬家场景，让热水器在新的地点继续使用 根据以上表格，我们可以总结出几下几个需求点 健康：因作业的专业性，用户无法自行动手。这一类的情况，对此健康生活不关注的用户经常放任不管，只有特别关注健康的用户会有持续性的需求。 便捷和省钱：用户可以自己动手，但是费时费力。这一类情况，用户关注一般就是便捷和省钱，否则就会生出“还不如我自己来弄”的想法 专业：用户无法自己动手。这一类的情况，用户关注的这是主要是作业的专业性。“当初花那么多钱买的千万别给搞坏了” 2.2 如何获取需求点我们主要有两种方式：用户拜访，问卷调查 好处 坏处 用户拜访 发挥空间大，可以采集很多无法格式化的信息 不好大面积推开，只能安排少量人员去执行，不好事后统计，需要执行者自行总结和整理 问卷调查 格式化的问卷调查有利于统计和分析，可以借助客服/市场团队的资源，大面积进行 问卷调查的内容是预先设定好的，缺乏变通，对不能格式化的信息无法获取 所以我们一般的做法是 先进行用户拜访 格式化出问题 大范围问卷调查 3. 产品方案3.1 结合自身，锁定人群我们分析了市场容积和用户的需求点，这时候我们就可以总结出我们想要的结果，一个产品方案记住，没有一款产品可以包打天下，我们要说的不是宏观市场有多大，而是我们的市场有多大 可以投入的资源 + 需要锁定的人群 》》 可以得到的经济价值 以家电医保卡为例 可以投入的资源： 1500个家电网点 覆盖全国98%的城市 涵盖空调，冰箱洗衣机，各种家电等服务范围 需要锁定的人群： 健康？省钱+便捷？专业？ 可以得到的经济价值 通过测算用户的使用率和标准用户的平均消费情况来计算预期市场经济价值 我们可以看一个样本 电器品类 数量（台/户） 清晰频次（次/年） 清洗市场单价（元） 成本（元） 空调 1.5 2 120 70 油烟机 1 1 150 90 洗衣机 1 1 120 70 冰箱 1 0.5 120 70 热水器 1 0.5 120 70 年度合计 6 7 750 440 123456我国家庭数量已经到到3.5亿多户，城镇家庭约2亿户根据用例选择，在一年类进行验算如下：1. 按10%的用户清洗市场需求，收入预期为 750元*2000万人 = 150亿2. 按1%的用户清洗市场需求，收入预期为 750元*200万人 = 15亿3. 按0.1%的用户清洗市场需求，收入预期为 750元*20万人 = 1.5亿随着人均收入的不断提升及健康意识增强，用户的清洗需求率会不断提高，市场容量也不断增大 3.2推导产品方案有了我们的资源有了我们的用户现在我们可以推导出产品的方案：我们有什么？我们如何包装我们的资源？这里我们需要区分核心资源和增值资源 核心资源：用来解决用户的痛点 增值资源：用来帮用户下最后的决心，解决转化率问题 已有能力 售后（核心） 客服 金融 安装，清洗，维修 免取件费，快递退换货专享通道 延保，意外保障 结合这些已有能力我们可以推出以下套餐 服务类型 套餐内容 延保服务 延长保修一年 清洗（核心） 洗衣机清洗一次 清洗（核心） 烟灶清洗套餐服务一次 客服 专属通道 物流 运费券 4. 竞争力分析如果我们锁定了我们的产品方案，那我们要看看，市场上有哪些雷同的产品他们的市场占有率如何，产品竞争力如何我们的定义的目标产品方案，是否有足够的生存空间？ 4.1 竞品调研一般来说，竞争力分析主要有两种： 如果有明确的市场对标对象，则对这个对标对象进行单一对标分析 如果没有明确的市场对标对象，则需要列举市场上主要的TOP级竞争对手，逐一做单一分析，最后汇总。 竞品分析调研 天猫： 无理由保修 免费维修 三包范围外的因灰尘，受热，内部潮湿/冷凝，动力高峰/电压不稳所引起的故障 除修复产品故障外，还额外提供100元/次的服务满意金现金。 享受减免80%维修费用的优惠维修服务 由于疏忽或不慎跌落，碰撞，挤压而造成意外损坏导致产品无法使用的情况下 除修复产品故障外，还额外提供100元/次的服务满意金现金 换新服务 如产品被严重损坏经检测判断故障无法修复或维修费用高于故障产品市场零售价时，消费者支付少量的折旧费，即可获得服务商提供的换新服务 京东： 会员plus 150元/年 首次体验价149元 免费试用30天 2张运费券 购买正版后返京东豆 专享客服 退换无忧 免（退换维修）运费 免费上门取件 畅销电子书一年 自营运费补贴 60张运费券 购物回馈 按照品类回馈0.5%-2%的京东豆（&lt;=2000元价值京东豆） 亚马逊 亚马逊prime 388元/年 海外购订单 单比订单满200元，无限次跨境免运费 国内订单 零门槛，无限次免邮（自营+平台） 免费试享30天 首次体验价188元 总结 网站 售后 物流 客服 其他增值 促销 试用期 定价 总结 京东 / 60张运费券 专享客服，免（退换维修）运费，免费上门取件 畅销电子书一年，按照品类回馈0.5%-2%的京东豆 圣诞1元试用，京准达 30天，2张运费券 首次149元，150元/年 核心不凸显 亚马逊 / 海外购单比订单满200元，无限次跨境免运费，国内订单零门槛，无限次免邮（自营+平台） / / / 30天 首次体验价188元，388元/年 重叠度不高 天猫 三包范围外的因灰尘，受热，内部潮湿/冷凝，动力高峰/电压不稳所引起的故障，由于疏忽或不慎跌落，碰撞，挤压而造成意外损坏导致产品无法使用的情况下，除修复产品故障外，还额外提供100元/次的服务满意金现金，换新服务 / / / / / 按品类按价格段定价 缺乏增值能力 这个时候，我们可以推导出：与竞争对手相比，我们的竞争力体现在地方… 4.2 竞争力分析工具我们一般采用SWOT分析法对竞争力分析的结果进行总汇： 内因 外因 正面 优势(售后资源优势，累积了大量的家电用户群) 机会（市场上尚无引领性厂商，老百姓需求迫切度高，市场潜力巨大） 负面 劣势（销售优势品类单一：清洗增值服务不够吸引人） 挑战（服务规范化难度大，参差不齐，政府支持力度不够，缺乏支撑） 如何做SWOT分析呢？ 内因：QCDMS法 从质量，价格，能力，技术，资产，销量五个方面去分析 按照重要程度，列举有重要意义的内容 外因：PEST法 从政策法律，宏观经济，社会情况，整体技术水平四个方面去分析 按照重要程度，列举有重要意义的内容 SWOT分析的核心可以认为是两部分： 优势与劣势（S/W）：这一部分是分析内因 机会与挑战（O/T）：这一部分是分析外因 5. 产品迭代策略5.1 SWOT策略最后我们根据市场分析情况来确定我们的产品迭代策略：先切分哪块市场？先对标哪个主要的竞争对手？先包装哪些内容？第二步，第三步如何? 策略名称 策略解释 总结 WT策略 (劣势挑战) 努力让自己的弱势最小化，努力避免风险 守城，慢慢来吧 SO策略（优势机会） 努力让自己的优势最大化，让机会最大化 高风险，玩的就是心跳 WO策略（劣势机会） 努力你不自己弱势，从而努力赢得一些机会 现实主义，小富即安 ST策略（优势挑战） 努力让自己优势最大化，并通过减少风险，消除威胁因素 镣铐舞蹈，苦乐掺半 小米最开始为发烧而生就是SO策略，只做最低价来占领市场（当时智能机很贵），不顾其他性能和温度。直到小米4才开始有设计注重性能开始WO策略 5.2 推导迭代策略根据上面说明的我们来推导我们的家电医保卡迭代策略 版本 策略 目的 说明 一期 SO策略 冷启动，先进入清洗市场 万屋清新-清洗服务，增值服务-免邮/客服 二期 WO策略 弥补缺点，对标天猫，赢在价值 苏宁帮客-维修服务，增值服务-延保/免邮/客服 三期 WT策略 规范服务质量，开启价格战模式，丰富内容 万事无忧-增值服务强化，服务治理-淘汰，评分 5.3 迭代策略总结 首先我们确定的迭代策略一定是基于SWOT的分析结果。 其次在不同的产品阶段，我们可以采用不同的策略来指导产品方案 例如在冷启动阶段，我们可以采用高风险的策略，来赢得尽可能多的机会，以保证冷启动的成功，当然拼输了在这个阶段也无所谓 而在运营阶段，可以逐步弥补弱势，步步为营的去蚕食别人的市场。 在进入常规运营阶段，可以采用守城的策略，尾骨经营成果。 最后，不要拘泥于形式和套路 市场与市场竞争是一种很灵活的东西，受大量的不定因素左右，有时候后有些创造力是可以的。 6 总结6.1 市场分析总结 市场容量分析 大小 趋势 分类 需求点 锁定产品方案 我们有什么 我们打算切割哪块市场 竞争力分析 咱们那啥跟他们斗 迭代策略 咱们怎么切入这个市场 6.2 市场分析报告 市场分析 市场容量分析（当前规模） 增长趋势分析（近几年的增长速率和增长点） 市场需求分析 典型目标人群介绍 归纳核心需求点 建议目标产品方案描述 建议目标产品方案描述 对标竞争对手，做竞争力对比 通过SWOT分析，做出分析汇总 建议市场竞争策略 搬出SWOT分析结果，选择对策策略 明确产品迭代策略，写出RoadMap 注意：我们不是市场分析师，我们的公司也不是咨询机构在我们的工作中，基本上不可能进行规模浩大的市场分析。因为如果消耗成本去完成一次大规模的市场调研分析，还不如把成本投入去试错。所以，请把市场分析工作做的简短和直接，以需求为向导，以产品为核心"},{"title":"MySQL高级","date":"2018-12-04T01:18:52.000Z","path":"2018/12/04/MySQL高级/","text":"0 视图0.1 视图定义视图是有查询结果形成的一张虚拟表，是表通过某种运算得到的一个投影。同一张表可以创建多个视图创建视图语法： create view 视图名称 as select 语句 说明： 视图名跟表名是一个级别的名字，隶属于数据库； 该语句的含义可以理解为：就是将该select命名为该名字（视图名） 该视图也可以设定自己的字段名，而不是select语句本身的字段名（通常不设置） 视图的使用几乎和表一样（只不过一般都用做查询，很少增删改，增删改在后面说明） 0.2 视图的作用 可以简化查询案例：1.查询平均价格前3的栏目以前的SQL语句1select cat_id,avg(shop_price) as pj from ecs_goods group by cat_id order by pj limit 3; 应用视图的1) 创建一个视图1create view ecs_goods_v1 as select cat_id,avg(shop_price) as pj from ecs_goods group by cat_id; 2) 查询平均价格前3只需要查询视图即可1selcet * from ecs_goods_v1 order by pj desc limit 3; 案例：2.查询出商品表，以及所在的栏目名称以前的sql语句12select goods_id,goods_name,b.cat_name,shop_price from ecs_goods a left join ecs_category b on a.vat_id=b.cat_id 1) 创建视图123create view ecs_goods_v2 as select goods_id,goods_name,b.cat_name,shop_price from ecs_goods a left join ecs_category b on a.vat_id=b.cat_id 2) 查询视图1selcet * from ecs_goods_v2; 可以进行权限控制把表的权限封闭，但是开放相应的视图权限，视图里只开放部分数据，比如用户表为例，两个网站搞合作，可以查询对方网站的用户，需要向对方开放用户表的权限，但是又不想开放用户表中的密码字段。再比如一个goods表，两个网站搞合作，可以互相查询对方的商品列表，比如进货价格字段不能让对方看到案例1) 创建一个视图，视图中不能包含进价字段（in_price）1creat view goods_v1 as select id,goods_name,shop_price from goods; 2) 创建一个用户，授予查询权限，只能操作goods_v1表（视图）1grant select on php.goods_v1 to &apos;xiaoming&apos;@&apos;%&apos; identified by &apos;123456&apos;; 3) 这样就把新建的用户给合作方 0.3 视图操作 查询视图语法： select * from 视图名 [where 条件] 视图和表一样，可以添加where条件 修改视图 alter view 视图名称 as select …. 删除视图 drop view 视图名称 查看视图结构和表一样，语法： desc 视图名称 查看所有视图和表一样，语法： show tables; 注意：没有show views 语句 视图和表得关系表 &gt;&gt;——&gt;&gt; 视图表改变了视图就改变了视图 &gt;&gt;——&gt;&gt; 表修改：1) 如果没有计算的来的值（avg），视图改变可以影响表增加：2) 如果没有不能为空而又刚好没被视图收录的字段，视图创建可以影响创建 视图算法algorithm = merge/temptable/undefined 名称 算法 创建方式 merge 当引用视图时，引用视图的语句与定义视图的语句合并（默认） 意味着视图只是一个语句规则，当查询视图时，吧查询视图的语句与创建时语句where子句等合并，分析，形成一条select语句 temptable 当引用视图时，根据视图语句创建一张临时表 根据创建语句，瞬间创建一张临时表，然后查询视图的语句，从该临时表查询数据 undefined 未定义，让系统自动选择 1 SQL编程1.1 声明变量 会话变量定义形式 set @变量名 = 值; 说明：1) 和js类似，第一次给其赋值，就算定义了2) 它可以在变成环境和非编程环境中使用3) 使用的任何场合都该带“@”符号 普通变量定义形式： declare 变量名 类型 【default 默认值】; 说明：1) 他必须先声明（即定义），此时也可以赋值；2) 赋值跟会话变量一样set 变量名 = 值；3) 它只能在编程环境中使用！！！(编程环境指的是：存储过程，函数，触发器) 变量赋值形式1) 语法1： set 变量名 = 表达式; 此语法中的变量必须先使用declare声明 2) 语法2: set @变量名 = 表达式 此方式可以无需declare语法声明，而是直接赋值，类似js定义变量并赋值； 3) 语法3： select @变量名:= 表达式； 此语句会给变量赋值，同时还会作为一个select语句输出结果 4) 语法4： select 表达式 into @变量名; 此语句虽然看起来是select语句，但是其实并不输出结果集，而是给变量赋值 1.2运算符 算术运算符 +,-,*,/,% 注意musql没有++和-- 关系运算符 &lt; &lt;= = &lt;&gt; != 逻辑运算符 and or not 1.3语句包含模块所谓语句包含符，在js中，以及大部分其他语言中，大都是{}它用在很多场合if，switch，for，function而mysql编程包含的语句符是： begin【什么】 end【什么】 1.4条件判断MySQL支持两种判断if判断和case判断 if单分支语法： if 条件 then //代码 end if; 双分支 if 条件 then //代码1 else //代码2 end if; 多分枝 if 条件 then //代码1 elseif 条件 then //代码2 else //代码3 end if; 注意：通常情况下;表示sql的结束，同时向服务器提交并执行，但存储过程中很多SQL语句每一句都是;分开的，这时候我们就需要用其他符号来代替向服务器提交的命令 delimiter 符号 案例：接收4个数字，如果输入1=春天，2=夏天，3=秋天，4=冬天，其他=出错先修改;符号 delimiter $ 1234567891011121314create procedure p1 (n int)begin if n=1 thenselect &apos;春天&apos; as &apos;季节&apos;;elseif n=2 thenselect &apos;夏天&apos; as &apos;季节&apos;;elseif n=3 thenselect &apos;秋天&apos; as &apos;季节&apos;;elseif n=4 thenselect &apos;冬天&apos; as &apos;季节&apos;;elseselect &apos;错误&apos; as &apos;季节&apos;;end if;end$ case判断 case 变量when 值 then 语句;when 值 then 语句;else 语句;end case; 上面的例子我们改变如下 12345678910create procedure p2 (n int)begin case nwhen 1 then select &apos;春天&apos; as &apos;季节&apos;;when 2 then select &apos;夏天&apos; as &apos;季节&apos;;when 3 then select &apos;秋天&apos; as &apos;季节&apos;;when 4 then select &apos;冬天&apos; as &apos;季节&apos;;else select &apos;错误&apos; as &apos;季节&apos;;end case;end$ 1.5循环Mysql支持的循环有loop，while，repeat循环 loop循环 标签名:loopleave 标签名（退出循环）end loop; 案例：循环1到n的和 12345678910111213create procedure p3 (n int)begin declare i int default 1; declare s int default 0; aa:loop if i&gt;n then leave aa; end if; set s=s+i; set i=i+1; end loop; select s;end$ while循环 标签名 while 条件 do// 代码end while 12345678910create procedure p4 (n int)begin declare i int default 1; declare s int default 0; while i&lt;=n do set s=s+i; set i=i+1; end while; select s;end$ repeat循环 repeat// 代码until 条件 end repeat; 12345678910create procedure p5 (n int)begin declare i int default 1; declare s int default 0; repeat set s=s+i; set i=i+1; until i&gt;n end repeat; select s;end$ 2 存储过程存储过程是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过制定存储过程的名字，并给出参数（如果该存储过程携带参数）来执行。存储过程是数据库中的一个重要对象，任何一个设计良好的数据库应用程序都应该用到存储过程。 2.1 好处 存储过程只是在创建时进行编译，以后每次执行存储过程不需要再重新编译，而一般SQL语句每执行一次就编译一次，所以使用存储过程可以提高数据库执行速度。 当对数据库进行复杂操作时（如对多个表进行增删改时），可以将此复杂操作用存储过程封装起来，与数据库提供的事务结合一起使用 存储过程可以重复使用，减少数据库开发人员的工作量 安全性提高，可设定只有某些用户才具有对指定的存储过程使用权限 2.2 存储过程操作 创建存储过程 1234create procedure 存储过程名称(参数1,参数2,...)begin // 代码end 存储过程的参数部分为输入参数（in），输出参数（out），输入输出参数（inout），默认是输入参数。如果存储过程中就一条语句，begin和end是可以省略的。 说明：1) 存储过程中，可有各种变成元素：（变量，流程控制，函数调用）；2) 还可以有：增删改查等各种sql语句3) 其中select（或show，或desc）会作为存储过程执行后的“结果集”返回；4)形参可以设定数据的“进出方向” 案例1：查询一个表里面某些语句 1234create procedure p10()beginselect * from ecs_goods;end; 案例2：输入一个字符串，如果是h输出价格大于1000商品，其他输出小于1000商品 12345678910create procedure p11(str char(1))beginif str = &apos;h&apos; thenselect * from ecs_goods where price&gt;1000;elseselect * from ecs_goods where price&lt;=1000;end if;end;call p11(&apos;h&apos;); 调用存储过程语法： call 存储过程() 删除存过程 语法: drop procedure [if exists] 存储过程名 创建复杂存储过程 案例1：带输出参数的存储过程 123456create procedure p12(in n int,out res int)begin set res = n*n;end;set @res=0;call p12(100,@res);selcet @res; 案例2:带有输入输出参数的存储过程123456create procedure p13(inout n int)begin set n = n*n;end;set @a = 20; call p13(@a);select @a; 2.3 变量 系统变量 MySQL启动的时候就存在的变量，以@@开头的都是系统变量 查询mysql版本： select @@version; 用户变量用户变量只要在前面加一个@就可以12set @name=&apos;linjiad&apos;;select @name; 3 函数和js中的函数几乎一样：需要先定义，然后调用。只是规定这个函数必须需要一个返回值; 3.1 定义函数语法： 123456create function 函数名(参数) returns 返回值类型begin// 代码return xx值;end; 说明：1) 函数内部可以有各种编程语言元素：变量，流程控制，函数调用；2) 函数内部可以有增删改等语句3)但：函数内部不可以有查（select或show，或desc）这种返回结果集的语句 3.2 调用跟系统函数调用一样：任何需要数据的位置，都可以调用该函数 案例1：返回两个数的和123456create function he(num1 int,num2 int) return intbeginreturn num1+num2;end;select he(100,120); 案例2: 返回1到n的和123456789101112create function hee(n int) return intbegindeclare i int default 1;declare s int default 0;while i &lt;=n doset s= s + i;set i= i + 1;end while;retuen s;end;select he(100,120); 注意：创建的函数是属于数据库的，只能在创建函数的数据库中才能使用； 3.3 SQL内部函数 数字类 1) select rand(); //返回0到1之间的随机数2) select * from it_goods //随机取出两个商品3) select floor(3.9) // 向上取整 44) select ceil(3.1) // 向下取整 35) select round(3.5) // 四舍五入 4 大小写转换 1) select ucase(‘linjiad’) //转换成大写2) select icase(‘linjiad’)//转换成小写 字符串截取 1) select left(‘abcde’,3) //从左边截取2) select right(‘abcde’,3) //从右边截取3) select substring(‘abcde’,2,3) //从第二个位置开始，截取3个4) select concat(‘abc’,’:de’) //字符串项链 10:abcde5) coalesce(str1,str2) //返回参数中的第一个非空表达式select stuname.stusex,coalesce(writtenexam,’缺考’),coalesce(labexam,’缺考’) from stuinfo6) select length(‘锄禾日当午’) //显示字节个数 107) select char_length(‘锄禾日当午’) //显示字符个数 58) select length(trim(‘ abc ‘)) //trim 用来去除字符串两边空格9) select replace(‘abc’,’bc’,’pache’) //将bc替换成pache 时间类 1) select unix_timestamp() // 时间戳2) select from unixtime(unix_timestamp()) //将时间戳转换成日期格式select from_unixtime(unix_timestamp(),’%Y-%m-%d’);3) curdate (); //返回今天得日期select curdate(); // 2018-12-074) select now();// 去除当前时间select now();// 2018-12-07 15:02:595) select year(now()) 年, mouth(now()) 月,day(now()) 天,hour(now()) 小时。minute(now()) 分,second(now()) 秒 6) select datediff(now(),’1997-7-1’)// 两个日期相聚多少天7) if(表达式,值1,值2) //类似三元云算法select concat(10,if(10%2=0,’偶数’,’奇数’))8) date_sub 和date_add //时间加减date_sub(时间日期时间,interval 数字 时间单位) ①：时间单位：可以是year month day hour minute second ②数字：可以是正数和负数（具体看案例2） 案例案例1： 查询今天得电影①curdate()求出今天的日期②把添加的时间戳，转换成日期select title from dede_archives where curdate()=from_unixtime(senddate,’%Y-%m-%d’); 案例2： 求昨天添加的电影① 去除昨天日期select date_sub(curdate(),interval 1 day)或者select date_add(curdate(),interval -1 day) 4 触发器4.1 简介 触发器是一个特殊的存储过程，它是Mysql在insert，update，delete的时候自动执行的代码块。 触发器必须定义在特定表上 自动执行，不能直接调用作用：监视某种情况并触发某种操作触发器的思路：监视X表，如果X表里面有增删改的操作，则自动触发Y里面增删改操作。比如用户表增加新用户，相应的订单表增加该用户的信息。 目前mysql不支持多个具有同一个动作，同一时间，同一事件，同一地点，的触发器。 4.2 创建触发器 监视地点（table） 监视事件（insert/update/delete） 触发时间（after/before） 触发事件（insert/update/delete） 语法： 123456create trigger 触发器名after/before inster/update/delete on 表名for each row begin // sql语句及代码（触发的语句可以是一句或多句）end 4.3 案例 案例1：第一个触发器，购买一个订单表减少一个 1) 监视地点 it_order表2) 监视事件 it_order表的inset操作3) 触发时间 it_order表的inset之后4) 触发事件 it_goods表减少库存的操作 123456create trigger t1after inster on it_orderfor each row begin update it_goods set goods_number=goods_number - 1 where id = 2;end 这个t1是有问题的，我们购买任何商品都是减少id=2的对应库存 案例2: 购买商品，减少对应库存如何在触发器中引用行的值？对于insert而言，新增的行用new来表示，行中的每一列的值，用new.列名来表示。 123456create trigger t1after inster on it_orderfor each row begin update it_goods set goods_number=goods_number - new.much where id = new.goods_id;end 案例3：取消订单时，减掉的库存要添加回来 删除行我们用old来表示，如果要引用里面的数据，则使用old.列名来表示 1) 监视地点 it_order表2) 监视事件 it_order表的delete操作3) 触发时间 it_order表的delete之后4) 触发事件 it_goods表减少库存恢复过来 123456create trigger t3after delete on it_orderfor each row begin update it_goods set goods_number=goods_number + old.much where id = old.goods_id;end 案例4：修改订单时，库存也要做对应修改（可以修改购买数量，也可以修改类型）如果是修改操作要引用it_order里面的值修改前的数据用old表示，old.列名引用被修改之前的值修改后的数据用new表示，new.列名引用被修改之后的值 1) 监视地点 it_order表2) 监视事件 it_order表的update操作3) 触发时间 it_order表的update之后4) 触发事件 it_goods表要修改对应的库存 1234567create trigger t4after update on it_orderfor each row begin update it_goods set goods_number=goods_number + old.much where id = old.goods_id;update it_goods set goods_number=goods_number - new.much where id = new.goods_id;end 4.4 其他操作 删除触发器 drop trigger 触发器名称 查看触发器 show triggers 4.5 befor和afterafter是先完成数据的增删改，再出发，触发器中的语句晚于监视的增删改，无法影响前面的增删改动作类似于自助餐，先付钱，在吃饭，无法影响吃多少 befor是先完成出发，再增删改，触发的语句先于监视的增删改发生，我们有机会判断修改即将发生的操作 案例：对于已下的订单，进行判断，如果订单数量&gt;5，就认为是恶意订单，强制吧所定的商品数量改成5 1) 监视地点 it_order表2) 监视事件 it_order表的insert操作3) 触发时间 it_order表的insert之前4) 触发事件 如果购买数量＞5就把购买数量改成5 12345678create trigger t5after insert on it_orderfor each row begin if new.much&gt;5 thennew.much=5;end if;end"},{"title":"Docker简介","date":"2018-11-30T01:20:09.000Z","path":"2018/11/30/Docker简介/","text":"0 场景简述0.1虚拟化技术所谓的虚拟化技术实际是一种资源管理技术，他可以将我们计算机中的实体资源进行虚拟化虚拟化技术种类有很多，例如：软件虚拟化，硬件虚拟化，内存虚拟化，网络虚拟化，桌面虚拟化，虚拟机等目的：就是为了提供我们计算机的使用率在实际的生产环境中，虚拟化技术主要用来解决高性能的屋里硬件产能过剩和老的旧的硬件产能过低的重组重用，透明化底层屋里硬件，从而最大化的利用屋里硬件对资源充分利用 0.2 虚拟化技术分类 全虚拟化架构我们的虚拟机VMware就是利用了这种技术操作系统可以和虚拟机系统不相同 OS虚拟化架构OS虚拟化架构出来的操作系统要和我们底层的操作系统共享系统内核（即相同的操作系统）我们的Docker就是用了这种架构 硬件层虚拟化架构 0.3 Docker容器容器主要的作用就是装东西，比如我们的数组，集合也是容器，我们可以使用数组，集合来存储我们的数据我们也可以使用Docker来装我们的软件，比如：我们可以把mysql安装到docker容器中，tomcar，redis，nginx都可以安装到docker中我们把响应的软件安装到docker容器中以后好处： 方便我们队软件环境进行搬运 开发环境，测试换件，生产环境————&gt;统一我们的软件，有了docker以后我们可以极大的减少我们的部署成本，可以把mysql安装到dicker中，这样可以直接把容器给他 各个容器之间是隔离状态：这样就减少了我们软件之间的影响 docker是os层虚拟化架构的一种体现产品，os层虚拟化架构虚拟出来的操作系统需要和宿主机中的操作系统共享一个内核，docker容器的体积相对较小 0.4 Docker的组件 客户端和服务端在宿主机启动的所有docker容器中，启动的虚拟机都是客户端，而我们的宿主机是服务端 镜像镜像是一组文件的集合，竟像是构建Docker的基石（相当于操作系统镜像，能安装操作系统），其中包括了容器的文件系统结构与内容 注册中心类似于我们的Maven仓库，在注册中心中存储了很多的常用镜像，docker中的注册中心地址是docker——hub 容器容器就是镜像的运行实例，镜像和容器之间的关系就类似于类和对象的关系我们的容器创建时需要通过镜像来进行构建的 1 Docker的操作1.1安装Docker使用yum命令来进行在线安装 yun install docker [配图]提示信息[配图]输入y进行安装[配图]安装之后我们检查docker版本 docker -v[配图] 1.2卸载Docker查看docker的安装包 yum list installed|grep docker [配图] 删除安装包，就是删除刚才看到的文件 yum -y remove docker.x86_64yum -y remove docker-client.x86_64yum -y remove docker-common.x86_64 删除docker镜像 rm -rf /var/lib/docker/ 再次检查Docke是否删除成功 yum list installed|grep docker[配图] 1.3启动/关闭Dockersystemctl命令是系统服务管理指令，他是service和chkconfig两个命令组合 systemctl start docker 启动dockersystemctl status docker 产看docker的启动状态systemctl stop docker 停止dockersystemctl restart docker 重启docker docker info 查看docker的重要信息docker -help 查看docker的帮助文档 1.4启动Docker报错有时候我们启动docker会报错如下[配图]我们查看docker状态[配图]这里表示的意思是此linux的内核中的SELinux不支持overlay2 graph driver，解决办法有两个， 要么升级内核版本（升级操作系统） 要么在docker里禁用selinux --selinux-enabled=false vi /etc/sysconfig/docker [配图]再次启动docker，并且查看docker状态 1.5列出镜像列出宿主机上所有存在的镜像 docker images 第一次安装docker的时候是没有镜像的，索引我们看到的镜像信息是空的 列名 含义 备注 PEPOSITORY 镜像所在的仓库名称 TAG 镜像标签 为了区分同一个仓库下的不同镜像，Docker提供了一种标签(Tag)的功能，每个景祥在列出来的时候都带有一个标签 IMAGE ID 镜像ID CREATED 创建时间 创建镜像的时间（不是获取镜像的时间） SIZE 镜像大小 90 注：这些镜像都是存储在Docker宿主机的/var/lib/docker目录下的 1.6搜索镜像去注册中心（docker hub）上去所属需要的镜像 docker search 镜像名 如：搜索tomcat镜像[配图] 列名 含义 NAME 仓库名称 DESCRIPTION 镜像描述 STARS 综合评分，反应一个镜像受欢迎程度 OFFICIAL 是否官方 AUTOMATED 自动构建，表示该镜像由Docker Hub自动构建流程创建的 1.7拉取镜像我们拉取镜像默认是从Docker Hub镜像仓库上进行获取的，在Docker Hub的官网上我们可以看到一些信息[配图] 国情原因，国内下载Docker Hub官方的相关镜像比较慢，可以使用国内（docker.io）的一些镜像加速器，镜像保持和官方一致，关键是速度快 常用的镜像加速器有Mirror与Private Registry区别如下 序号 Private Registry 备注 1 Private Registry(私有仓库)是开发者或者企业自建的镜像缓存库，通常用来保存企业内部的Docker镜像，用于内部开发流程和产品的发布，版本控制 Mirror是一种代理中转服务器，我们（比如daocloud）提供的Mirror服务，直接对接Docker Hub的官方Registry。Docker Hbu上有数以十万计的各类Docker镜像 2 在使用Private Registry时，需要在Docker Pull或Dockerfile中直接接入Private Registry的地址，通常这样会导致与Private Registry的绑定，缺乏灵活性 使用Mirror服务，只需要在Docker守护经常（Dacmon）的配置文件中加入Mirror参数，即可在局范围内透明的访问官方的Docker Hub，避免了对Dockerfile镜像引用来源的修改 ustc镜像是老牌的linux镜像服务提供者配置ustc镜像加速 编辑文件 vi /etc/docker/daemon.json 在配置文件中配置如下内容 { “registry-mirrors”:[“https://docker.mirrors.ustc.edu.cn&quot;]} 重启docker systemctl restart docker 如果重启docker以后还是无法进行加速，可以重启宿主机尝试 拉取镜像： docker pull 镜像名称 拉取tomcat镜像 docker pull tomcat 1.8 删除镜像我们可以删除指定的镜像也可以删除所有镜像 删除指定镜像 docker rmi 镜像名称/镜像ID 删除所有镜像 1docker rmi `docker images -q` 注:中间的字符可以被当作linux的命令进行解析执行docker images -q 获取所有镜像的ID 2 Docker容器操作2.1 查看容器查看正在运行的容器 docker ps [配图] 列名 含义 CONTAINER ID 容器的id IMAGE 创建容器时所使用的镜像 COMMAND 运行容器中的软件执行的命令 CREATED 容器创建时间 STATUS 容器的状态：UP表示运行状态 Exited表示关闭状态 PORTS 宿主机端口和容器中软件的端口的对应关系 NAMES 容器名称 查看多有的容器（包括正在运行的容器和之前启动过的容器） docker ps -a 查看最后一次运行的容器 docker ps -l 查看停止的容器 docker ps -f status=exited 2.2 创建容器创建容器命令 docker run 创建容器参数介绍 参数名称 参数含义 -i 运行容器 -t 表示容器启动后进入命令行，加入这两个参数后，容器创建就能登录进去。分配一个伪终端 -d 在run后面加上-d参数，则会创建一个守护模式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i-t两个参数，创建后就回自动进入容器） –name 为创建的容器命名 -v 表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个-v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到宿主机上 -p 表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个-p做多个端口映射 2.3 交互式容器创建一个交互式容器取名为mycentos docker run -it –name=mycentos centos /bin/bash 使用ps查看容器状态[配图] 使用exit退出容器[配图]然后再查看容器状态[配图]我们退出了容器也就关闭了容器 2.4 守护式容器创建的容器名不能重复 docker run -di –name=mycentos2 centos 创建好后我们进入这个容器 docker exec -it 容器名称/容器ID /bin/bash 2.5 停止与启动容器 停止容器 docker stop 容器名称/容器ID 启动已经关闭的容器 docker start 容器名称/容器ID"},{"title":"JavaScript对象","date":"2018-11-27T07:38:38.000Z","path":"2018/11/27/JavaScript对象/","text":"0 对象0.1简介JavaScript 中的所有事物都是对象：字符串、数值、数组、函数…此外，JavaScript 允许自定义对象。JavaScript 提供多个内建对象，比如 String、Date、Array 等等。 对象只是带有属性和方法的特殊数据类型。 对象只是一种特殊的数据。对象拥有属性和方法。 0.2创建对象创建新对象有两种不同的方法： 定义并创建对象的实例 12345person=new Object();person.firstname=\"John\";person.lastname=\"Doe\";person.age=50;person.eyecolor=\"blue\"; 使用函数来定义对象，然后创建新的对象实例 123456789function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor;&#125;var myFather=new person(\"John\",\"Doe\",50,\"blue\");var myMother=new person(\"Sally\",\"Rally\",48,\"green\"); 也可以把方法添加到 JavaScript 对象1234567891011121314function person(firstname,lastname,age,eyecolor)&#123; this.firstname=firstname; this.lastname=lastname; this.age=age; this.eyecolor=eyecolor; this.changeName=changeName; function changeName(name) &#123; this.lastname=name; &#125;&#125;myMother.changeName(\"Doe\"); 1 Object对象Object是javaScript中一切对象的父类对象 0.1 创建Object对象语法 obj = new Object([value]) 参数 obj 必需 Object 对象分配到的变量名称。 值 可选 任一 JavaScript 基元数据类型（数字、布尔值或字符串）。 如果值是一个对象，则返回的对象是未修改的。 如果值是 null、“未定义”或“未提供”，则创建无内容的对象。 0.2 属性 属性 描述 __proto__ 属性 指定对象的原型。 constructor 属性 指定用于创建对象的函数。 prototype 属性 为对象的类返回原型的引用。 proto 属性语法: object.__proto__ object 必需。要对其设置原型的对象。__proto__ 属性名称以两个下划线开始和结束。 1) 下面的代码示例显示如何为对象设置原型。12345678910function Rectangle() &#123;&#125;var rec = new Rectangle();if (console &amp;&amp; console.log) &#123; console.log(rec.__proto__ === Rectangle.prototype); // Returns true rec.__proto__ = Object.prototype; console.log(rec.__proto__ === Rectangle.prototype); // Returns false&#125; 2) 下面的代码示例演示如何通过将属性添加到原型来将其添加到对象中。12345678910111213var proto = &#123; y: 2 &#125;;var obj = &#123; x: 10 &#125;;obj.__proto__ = proto;proto.y = 20;proto.z = 40;if (console &amp;&amp; console.log) &#123; console.log(obj.x === 10); // Returns true console.log(obj.y === 20); // Returns true console.log(obj.z === 40); // Returns true&#125; 3) 下面的代码示例通过在 String 对象上设置新原型将特性添加到该对象。123456789101112131415161718var stringProp = &#123; desc: \"description\" &#125;;String.__proto__ = stringProp;var s1 = \"333\";var s2 = new String(\"333\");if (console &amp;&amp; console.log) &#123; console.log(String.desc === \"description\"); // Returns true console.log(s1.desc === \"description\"); // Returns false console.log(s2.desc === \"description\"); // Returns false s1.__proto__ = String; // Can't be set. s2.__proto__ = String; console.log(s1.desc === \"description\"); // Returns false console.log(s2.desc === \"description\"); // Returns true&#125;"},{"title":"AJAX","date":"2018-11-23T01:28:17.000Z","path":"2018/11/23/AJAX/","text":"0 AJAX基础简介0.1 什么是AJAX？async javascript and xml异步的JS和XML 0.2. xml可扩展的标记语言 作用是用来存储数据的（通过自己扩展的标记名称清晰地展示出数据结构） ajax之所以成为异步的js和xml，主要原因是：当初最开始使用ajax实现客户端和服务端数据通信的时候，传输数据格式一般都是xml格式的数据，我们把它称之为异步js和xml（现在一般都是基于JSON格式来进行数据传输的） 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;root&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;score&gt; &lt;english&gt;90&lt;/english&gt; &lt;math&gt;100&lt;/math&gt; &lt;chinese&gt;97&lt;/chinese&gt; &lt;/score&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;25&lt;/age&gt; &lt;score&gt; &lt;english&gt;90&lt;/english&gt; &lt;math&gt;100&lt;/math&gt; &lt;chinese&gt;97&lt;/chinese&gt; &lt;/score&gt; &lt;/student&gt;&lt;/root&gt; 0.3 异步的JS这里的异步不是说ajax只能基于异步进行请求（虽然建议都使用异步编程），这里的异步指的是局部刷新 1 前后端分离前后端分离的导火线就是全局刷新和局部刷新 1.1刷新全局(不分离)在非完全前后端分离的项目中，前端开发只需要完成页面的制作，并且把一些基础的人机交互效果使用js完成即可，页面中需要动态呈现内容的部分，都是交给后台开发人员做数据绑定和基于服务器进行渲染的（服务器渲染）[优势] 动态战士的数据在页面的源代码中课件，有利于SEO优化推广（有利于搜索引擎的收录和抓取） 从服务器端获取的结果就已经是最后要呈现的结果了，不需要客户端做额外的事情，所以页面加载速度快（前提是服务器端处理的速度够快），所以类似京东，淘宝这类网站，首屏数据一般都是经由服务器端渲染的 [弊端] 如果页面中存在需要实时更新的数据，每一次想要展示最新数据，页面都需要重新的刷新一次，这样肯定不行 都交给服务器端做数据渲染，服务器端的压力大，如果服务器处理不过来，页面显现的速度会更慢 3.这种模式不利于开发，（开发效率低） 目前市场上大部分项目都是前后端完全分离的项目（也有非完全前后端分离的项目） 1.2 局部刷新(分离)前后端完全分离的项目，页面中需要动态绑定的数据是交给客户端完成渲染的 向服务器发送AJAX请求 把从服务器端获取的数据解析进行处理，拼接成我们需要的HTML字符串 把拼接好的字符串替换页面中某一部分的内容（局部刷新），页面整体不需要重新加载，局部渲染即可 [优势] 我们可以根据需求，任意修改页面中某一部分的内容（例如实时刷新），整体页面不刷新，性能好，体验好（所有表单验证，需要实施刷新的需求都要局域AJAX实现） 有利于开发，提高开发效率1) 前后端分离，后端不需要考虑前端是如何呈现的，前端也不需要考虑后台使用什么技术，真正意义上实现了技术划分2) 可以同时进行开发：项目开发开始，首先指定前后端数据交互的接口文档（文档中包含了，调取那个接口或者那些数据等协议规范），后台把接口写好（目前很多公司也需要前端自己拿NODE来模拟这些接口） [弊端] 不利于SEO优化：第一次从服务器端获取的内容不包含需要动态绑定的数据，所以页面的源代码中没有这些内容，不利于SEO收录，后期经过JS添加到页面中的内容，并不会卸载页面的源代码中（是源代码不是页面结构） 交由客户端进行渲染，首先需要把页面呈现，然后再通过JS的异步AJAX请求获取数据，然后数据绑定，浏览器把动态数据增加的部分重新渲染，无形中兰妃了一些时间，没有服务器端渲染页面呈现的速度快 2 AJAX参数详解2.1 创建一个AJAX对象12345678910111213// 创建AJAX对象let xhr = new XMLHttpRequest(); //不兼容IE6及更低版本的浏览器（IE6：ActiveXObject）//打开请求地址（可理解为一些基础配置，但是并没有发送请求）xhr.open([method],[url],[async],[user_name],[user_password]);// 监听AJAX状态改变，获取相应信息（获取响应头信息，获取响应主体信息）xhr.onreadystatechange=()=&gt;&#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200)&#123; let result = xhr.responseText;//获取相应主题中的内容 &#125;&#125;// 发送AJAX请求（括号中的内容就是请求的主题内容）xhr.send(null); 2.2 配置（open）的参数xhr.open([method],[url],[async],[user_name],[user_password]);1. [method]请求方式1) GET系列的请求 get delete 从服务器上删除某些文件 head 只想获取服务器返回的响应头信息（相应主体内容不需要获取） …2) POST请求方式 post put 向服务器中增减指定的资源文件 不管是哪一种请求方式，客户端都可以把信息传递给服务器，服务器也可以把信息返回给客户端，只是GET系列一般以获取为主（给的少，拿得多）而POST系列一般以推送为主（给的多，拿得少）1) 我们想获取一些动态展示的信息一般都用GET请求，因为只需要向服务器发送请求，告诉服务器端我们想要什么2) 在实现注册功能的时候，我们需要吧客户端输入的信息发送给服务器进行存储，服务器一般返回成功还是失败等状态，此时我们一般都是基于POST请求完成的 2. GET VS POSTGET系列请求和POST系列请求系列请求，在项目实战中存在很多区别1) GET请求传递给服务器的内容一般没有POST请求传递给服务器的多原因：GET请求传给服务器内容一般都是基于url地址问号传参来实现的，而POST请求一般都是基于设置请求主体来实现的。各浏览器都有自己的关于URL最大长度限制（谷歌：8K，火狐：7k，IE：2K）超过限制长度的部分，浏览器会自动截取掉，导致传递给服务器的数据缺失。理论上POST请求通过主体传递是没有大小限制的，真实项目中为了保证传输的速率，我们也会限制大小（例如：上传的资料或者图片我们会做大小的限制）2) GET请求很容易出现你缓存（这个缓存不可控：一般我们不需要），而POST不会出现缓存（除非做特殊处理）123456789setTimeout(()=&gt;&#123; $.ajax(&#123; url:'getList?lx=news', ... success=&gt;&#123; //第一次请求数据回来，间隔一分钟后，浏览器又发送一次请求，但是发送新的请求，不管是地址还是传递的参数都和上一次一样，浏览器很有可能会把上一次数据获取，而不是获取最新数据 &#125; &#125;,60000);&#125;) 解决方法：每一次重新请求的时候，在URL的末尾追加一个随机数，保证每一次请求的地址不完全一致，就可以避免是从缓存中读取的数据123456789setTimeout(()=&gt;&#123; $.ajax(&#123; url:'getList?lx=news&amp;_='+Math.random(), ... success=&gt;&#123; &#125; &#125;,60000);&#125;) 3) GET请求没有POST请求安全（POST也并不是十分安全，只是相对安全）原因：还是因为GET是URL传参给服务器有一种比较简单的黑客技术：URL劫持，也就是可以把客户端传递给服务器的数据劫持掉，导致信息泄露 3. [url]请求地址真实项目中，后台开发工程师会写一个API文档，在API文档中汇总了获取哪些数据需要使用那些地址，我们按照文档操作即可 4. [async]异步ASYNC异步（SYNC同步），设置当前AJAX请求时异步还是同步的，不写默认是异步（TRUE），如果设置为FALSE，则代表当前请求时同步 5. [user_name],[user_password]用户名和密码这两个参数一般不用，如果你请求的URL地址所在的服务器设定了访问权限，则需要我们提供可通信的用户名密码才可以（一般服务器都是可以允许匿名访问的） 2.3 AJAX状态码描述当前AJAX操作的状态的xhr.readyState 0 :UNSENT 未发送，只要创建一个AJAX对象，默认是0 1 :HEADERS_RECEIVED当前AJAX的请求已经发送，并且已经接收到服务器端返回的响应头信息了 3 :LOADING响应主体内容正在返回的路上 4 :DONE响应主体内容已经返回给客户端 2.4 HTTP网络状态HTTP网络状态码：记录了当前服务器返回的状态（xhr.status） 200: 成功，一个完整的HTTP事务完成（以2开头的状态码一般都是成功） 以3开头的一般也都是成功，只不过服务器做了特殊处理 301:Moved Permanently 永久颛臾（永久重定向） 302:Moved temporarily 临时转移（临时重定向，新的HTTP版本中任务307是临时重定向）一般用于服务器负载均衡：当前服务器处理不了，我们把当前请求临时交给其他的服务器处理（一般图片请求经常出现302，很多公司都有单独的图片服务器） 304: Not Modified 从浏览器缓存中获取数据把一些不经常更新的文件或者内容缓存到浏览器中，下一次从缓存中获取，减轻服务器压力，也提高页面加载速度 一般4开头的都是失败，而且服务器的问题偏大 400:请求参数错误 401:无权限访问 404:访问地址不存在 以5开头的一般都是失败，而且服务器的问题偏大 500:Internal Server Error未知的服务器错误 503:Service Unavailable服务器负载 2.5 AJAX参数及方法运行下面代码查看AJAX属性及方法12let xhr = new XMLHttpRequest();dir(xhr) [属性] readState 存储的是当前AJAX的状态码 response/responseText/responseXML 都是用来接受服务器返回的响应主体中的内容，只是根据服务器返回内容格式不一样，我们使用不同的属性接收即可 responseText是最常用的，接收到的内容格式是字符串格式的（一般服务器返回的数据都是JSON格式字符串） responseXML偶尔会用到，如果服务器端返回的是XML文档数据，我们需要使用这个属性接收 starus 记录了服务器返回的HTTP状态码 statusText 返回状态码的描述 timeout 设置当前AJAX请求的超时时间，假设我们设置的时间为3000（MS），从AJAX请求发送开始，3秒后响应主体内容还没有返回，浏览器就会把当前的AJAX请求任务强制断开 [方法] abort() 强制中断AJAX请求 getAllResponseHeaders() 获取指定属性名的响应头信息，例如：xhr.getResponseHeader(‘date’)获取响应头中存储的服务器时间 open() 打开一个URL地址 overrideMimeType() 重写数据的MIME类型 send() 发送AJAX请求（括号中书写的内容是客户端基于请求主体把信息传递给服务器） setRequesHeader(key,value) 设置请求头信息（可以是设置的自定义请求头） [事件] onabort 当AJAX状态发生改变，会触发这个事件 onreadystatechange AJAX状态发生改变，会触发这个事件 ontimeout 当AJAX请求超时，会触发这个事件 [代码示例]12345678910111213141516171819202122232425262728293031323334353637let xhr = new XMLHttpRequest();xhr.open('get','url?_='+Math.random(),true);// xhr.setRequestHeader('cookie','培训')设置请求头内容不能出现中文，并且header的key不能使cookie//请求头必须在OPEN之后SEND之前xhr.setRequestHeader('aaa','xxx');//设置请求超时时间xhr.timeout = 10;xhr.ontimeout = ()=&gt;&#123; console.log('请求已超时'); xhr.abort();&#125;xhr.onreadystatechange=()=&gt;&#123; let &#123;readyState:state,status&#125;=xhr // 如果跳过这个if没有return则说明成功了 if(!/^(2|3)\\d&#123;2&#125;$)/.test(status)) return; // 在状态为2的时候就可以获取响应头信息 if (state === 2)&#123; let headerAll = xhr.getAllResponseHeaders(), //获取的是服务器时间是格林尼治时间(相比于北京时间差了8小时)，通过new Date可以把这个时间转换为北京时间 serverDate = xhr.getResponseHeader('data'); console.log(headerAll,new Date(serverDate)); return; &#125; // 在状态为4的时候响应主体已经回来了 if (state === 4)&#123; //获取的结果一般是JSON字符串（可以使用JSON.PARSE把其转换为JSON对象） let valueText = xhr.responseText, //获取到的结果是SML格式的数据（可以通过XML的一些常规操作获取存储的信息） //如果服务器返回的是XML文档，responseText获取的结果是字符串而responseXML获取的是标准XML文档 valueXML = xhr.responseXML; console.log(valueText,valueXML); return; &#125; &#125;xhr.send('name=zxt&amp;age=28&amp;sex=man'); 2.6 AJAX同步异步详解AJAX这个任务：发送请求接收到响应主体内容（完成一个完整的HTTP事务） xht.send() 开始任务 xht.readyState === 4; 结束任务 [同步] 1234567let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;xhr.send();// 只输出一次结果 12345678let xhr = new XMLHttpRequest();xhr.open('get','temp.json',false);xhr.send(); // [同步]开始发送AJAX请求，开启AJAX任务，在任务没有完成之前，什么事情都做不了，下面绑定事件也做不了xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;// 绑定方法之前状态已经为4了，此时AJAX的状态不会再改变成其他值，所以事件永远//也不会被触发，一次都没执行方法（使用AJAX同步编程，不要把SEND放在事件监听前，这样我们无法在绑定的方法中获取到响应主题内容） 原理如图所示： [异步]1234567let xhr = new XMLHttpRequest();xhr.open('get','temp.json');xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;xhr.send();// 输出结果分别是2，3，4 1234567let xhr = new XMLHttpRequest();xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;xhr.open('get','temp.json');xhr.send();// 输出结果分别是1,2，3，4 原理如图所示： [AJAX特殊性] 虽然是同步但是还是会输出1 123456789let xhr = new XMLHttpRequest();xhr.onreadystatechange = ()=&gt;&#123; console.log(xhr.readyState);&#125;//xhr.readyState === 1 AJAX特殊处理的一件事：执行OPEN状态改变为1，会主动把之前坚挺的方法执行一次，然后再去执行SENDxhr.open('get','temp.json',false);xhr.send();//xhr.readyState ===4 AJAX任务结束，主任务队列完成// 1，4 3 JS中常用的编(解)码方法3.1 正常编码解码 escape/unescape主要是把中文汉字进行编码和解码（一般只有JS语言支持，也经常应用于前端页面通信的时候中文编码问题） 12345let str = '培训@163.com'escape(str);// 显示\"%u57F9%u8BAD@163.com\"unescape('%u57F9%u8BAD@163.com')// 显示\"培训@163.com\" encodeURI/decodeURI 12345let str = '培训@163.com';encodeURI(str);// \"%E5%9F%B9%E8%AE%AD@163.com\"decodeURI('%E5%9F%B9%E8%AE%AD@163.com')// \"培训@163.com\" encodeURIComponent/encodeURIComponent 12345let str = '培训@163.com';encodeURIComponent(str);// \"%E5%9F%B9%E8%AE%AD%40163.com\"encodeURIComponent('%E5%9F%B9%E8%AE%AD%40163.com');// \"培训@163.com\" encodeURI区别encodeURIComponent1) encodeURI不处理特殊字符2) encodeURIComponent处理特殊字符我们URL问号传递参数的时候，我们传递的参数还是一个URL或者包含很多特殊字符，此时为了不影响主要的URL，我们需要吧传递的参数值进行编码，使用encodeURI不能编码一些特殊字符，所以只能使用encodeURIComponent处理 123456789101112let str = 'http://www.baidu.com?',obj=&#123; name:'培训', age:'9', url:'http://www.linjiad.cn/?lx=1'&#125;;//把obj中的每一项属性名和属性值拼接到url末尾for(let key in obj)&#123; str+=`$&#123;key&#125;=$&#123;obj[key]&#125;&amp;`;&#125;console.log(str.replace(/&amp;$/g,''));//后期获取URL问号传参的时候，我们把获取的值一次的解码即可 3.2 加密方式进行编码解码 可逆转加密（一般都是团队自己定义的规则） 不可逆加密（一般都是基于MD5加密完成的）MD5加密是不可逆的，网上解析是通过匹配大数据，能解析出常用的加密，不常用的是无法解析的 4 实现AJAX4.1 Jquery中的AJAX123456789101112131415161718192021222324$.ajax(&#123; url:'xxxx', // 请求的API地址 method:'get',// 请求方式GET/POST。。，在老的版本中使用的是type使用type和method实现的是相同效果 dataType:'json',// dataType知识我们预设获取结果的类型，不会影响服务器的返回 // （服务器一般给我们返回的都是JSON格式字符串），如果我们预设的是json，那么类库中将把服务器返回的字符串转换为json对象 // ，如果我们预设的事text（默认值），我们把服务器获取的结果直接拿过来即可，我们预设的值还可以是xml等 cache:false, // 设置是否清除缓存，只对GET系列请求有作用，默认是TRUE不清除缓存，手动设置为FALSE，JQ类库 // 会在请求URL的末尾追加一个随机数来清除缓存 data:null, //我们通过DATA可以吧一些信息传递给服务器；GET系列请求会把DAT中的内容拼接在URL的末尾， // 通过问号传参的方式传递给服务器，POST系列请求会把内容放在请求主体中传递给服务器，DATA的值可以设置为两种格式 //字符串，对象，如果是字符串，设置的值是什么传递给服务器的就是什么，如果设置的对象， // JQ会把对象变为xxx=xxx&amp;xxx=xxx这样的字符串传递给服务器 async:true,// 设置同步或者异步，默认是TRUE代表异步，FALSE是同步 success:function() &#123; // 当AJAX请求成功（readyState===4&amp;status是2或3开头的） // 请求成功后JQ会把传递的回调函数执行，并且把获取的结果当做实参传递给回调函数（result就是我们从服务器获取的结果） &#125;, error:function() &#123; // 请求错误触发回调函数 &#125;, complate:function() &#123; // 不管是否请求错误还是正确，都会触发回调函数（他是完成） &#125;&#125;) 4.2 封装AJAX123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778~function() &#123; class ajaxClass&#123; init()&#123; let xhr = new XMLHttpRequest(); xhr.onreadystatechange = () =&gt;&#123; if(!/^[23]\\d&#123;2&#125;$/.test(xhr.status)) return; if(xhr.readyState === 4)&#123; let result = xhr.responseText; switch (this.dataType.toUpperCase())&#123; case 'TEXT': case 'HTML': break; case 'JSON': result = JSON.parse(result); case 'XML': result = xhr.responseXML; &#125; this.success(result); &#125; &#125;; // 处理data if(this.data !== null)&#123; this.formatData(); if(this.isGet)&#123; this.url += `$&#123;this.querySymbol()&#125;`; &#125; &#125; // 是否去除缓存 this.isGet ? this.cacheFn():null; xhr.open(this.method,this.url,this.async); xhr.send(this.data); &#125; formatData()&#123; if(Object.prototype.toString.call(this.data)==='[object,object]')&#123; let obj = this.data, str = ''; for(let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; str += `$&#123;key&#125;=$&#123;obj[key]&#125;&amp;`; &#125; &#125; str = str.replace(/&amp;$/g,'') this.data = str; &#125; &#125; // 是否清楚缓存 cacheFn() &#123; !this.cache?this.url += `$&#123;this.querySymbol()&#125;_=$&#123;Math.random()&#125;`:null; &#125; // 判断结尾是否为？ querySymbol()&#123; return this.url.indexOf('?')&gt;-1?'&amp;':'?'; &#125; &#125; window.ajax = function(&#123; url = null, method = 'GET', type = 'GET', data = null, dataType = 'JSON', cache = true, async = true, success = null &#125; = &#123;&#125;)&#123; let example = new ajaxClass(); example.url = url; example.method = type === null?method:type; example.data = data; example.dataType = dataType; example.cache = cache; example.async = async; example.success = typeof success === 'function'?success: new Function(); example.isGet = /^(GET|DELETE|HEAD)$/i.test(example.method); example.init(); &#125; &#125;();"},{"title":"正则","date":"2018-11-21T02:20:44.000Z","path":"2018/11/21/正则/","text":"0 概述0.1 正则概念就是一个规则，用来处理字符串的一个规则 0.2 正则的用处 匹配:判断一个字符串是否包含我们所指定的规则 ref.test(str) 捕获：把字符串中符合规则的内容捕获到 ref.exec(str) 0.3 正则的元素每一个正则表达式都是由元字符和修饰符组成的 【元字符】在//之间具有意义的一些字符 【量词元字符】代表出现次数数量的元字符 【特殊符号】（()，[]） 【修饰符】① global（g）：全局匹配② ignoreCase（i）：忽略大小写匹配③ multiline（m）：多行匹配 1 创建正则我们可以先看看正则里都包含了哪些 console.log(RegExp.prototype); 1.1 字面量方式 var reg = /\\d/ 1.2实例创建 var reg = new RegExp(“”) 1.3两者区别 字面量：在字面量方式中，我们//之间包起来的所有内容都是元字符，有特殊意义的，大部分都是代表本身含义的普通的元字符1234var name = zhu;var reg = /^\\d+\"+name+\"\\d+$/g;Console.log(reg.test(\"2015zhu2016\"))// false;Console.log(reg.test('2015\"\"nameeeee2016'))// true; 在这段代码中，并非是name代表zhu而是仅代表name本身，并且+为出现e的次数 创建实例12var reg = new RegExp(\"/^\\\\d+\"+name+\"\\\\d+$/\",g);console.log(reg.test(\"2015zhu2016\")) //true; 这里name就代表的是zhu注意：1.创建实例中转移符为两个\\\\d2.创建实例中修饰符作为第二个参数传入 1.4 字符串match方法字符串中的match方法：把所有和正则匹配的字符都获取到1234var reg = /\\d+?/g;var str = \"zhufeng2015peixun2016\";var ary = str.match(reg);console.log(ary) 虽然当前情况下，match比我们的exec更加的简便一些，但是match中存在一些自己处理不了的问题：在分组捕获的情况下，match只能捕获到大正则匹配的内容，而对于小正则捕获的内容是无法获取的 1.5 字符串中replace把原有的字符串替换成新的字符在不使用正则的情况下，每当执行一次只能替换一个字符123var str = \"zhufeng2015zhufeng2016\"str = str.replace(\"zhufeng\",\"zhufengjiaoyu\").replace(\"zhufeng\",\"zhufengjiaoyu\")// \"zhufengjiaoyujiaoyu2015zhufeng2016\" 这样出现zhufengjiaoyujiaoyu并没有实现需求；1234var str = \"zhufeng2015zhufeng2016\"str = str.replace(/zhufeng/g,\"zhufengjiaoyu\");console.log(str);// \"zhufengjiaoyu2015zhufengjiaoyu2016\" replace第一项的值是一个正则的实现原理 2 语法规则2.1 元字符在//之间具有意义的一些字符 \\：转义字符，转义后面字符所代表的含义 ^ :以某一元字符开始 $ :以某一元字符结束 \\n :匹配一个换行符 . :除了\\n以外的任意字符 123456var reg = /^0.2$/ // 以0开头2结尾中间除了\\n的任意字符Console.log(reg.test(\"0.2\")) // trueConsole.log(reg.test(\"0-2\")) // true reg = /^0\\.2$/ Console.log(reg.test(\"0.2\")) // falseConsole.log(reg.test(\"0-2\")) // true x|y:x或y其中一个 [xyz]:x或者y或者z其中一个 [^xyz]:除了xyz之外的任意字符 [a-z]:a-z之间任意一个字符 [^a-z]:除了a-z之间任意一个字符 \\d:一个0-9之间的数字 \\D:除了0-9之外的任意字符 \\w:数字，字母，下划线中的任意一个字符 [0-9a-zA-Z_] \\b:匹配一个边界符 \\s:匹配一个空白字段，空格或制表符，换页符 2.2 量词元字符代表出现次数数量的元字符 *:出现0到多次 +:出现1到 ?:出现0或1次 {n}:出现n次 {n,}:出现n到多次 {n,m}:出现n到m次 一个简单的手机验证1var reg= /^1\\d(10)$/ 2.3 特殊符号 ()分组作用改变x|y的优先级 var reg = /^18|19$/; 可以是18,19,189,119,819,1819…. var reg = /^(18|19)$/; 只能是18,19 []1) 在括号中出现的所有字段都代表本身意思的字符串（没有特殊含义）123var reg = /^0[.]$/ // 以0开头2结尾中间除了\\n的任意字符console.log(reg.test(\"1\")) // falseconsole.log(reg.test(\".\")) // true 2) 中括号中不识别两位数123var reg = /^[12]$/ // 1或者2中的其中一个var reg = /^[12-68]$/ // 1,2-6中的一个，8 三个中的一个var reg = /^[\\w-]$/ // 数字，字母，下划线，-中的一个 2.4 修饰符修饰符可以有效的解决正则捕获的懒惰性 global（g）：全局匹配ignoreCase（i）：忽略大小写匹配multiline（m）：多行匹配 3 正则用法3.1 匹配判断一个字符串是否包含我们所指定的规则 ref.test(str) 1234var reg = /\\d/ //包含一个0-9之间的数字console.log(reg.test(\"住\")); //falseconsole.log(reg.test(\"1\")); //trueconsole.log(reg.test(\"住111\")); //true 3.2 捕获把字符串中符合规则的内容捕获到 ref.exec(str) 123var reg = /\\d/;console.log(reg.exec(\"住\")); // nullconsole.log(reg.exec(\"1\")); // [\"1\",index:0,input:\"1\"] 3.3 捕获的内容格式第一项为当前数组最大正则捕获的内容 index：捕获内容所在开始索引位置input：捕获的原始字符串1234var reg = /\\d+/;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(res); //[\"2015\",index:7,input:\"zhufeng2015peixun2016\"] 3.4 正则捕获的特点1.懒惰型每一次执行exec只捕捉第一个正则匹配的内容，在不进行任何处理的情况下，在执行多次捕捉，不做的还是第一个匹配内容第一次：1234var reg = /\\d+/;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(res); //[\"2015\",index:7,input:\"zhufeng2015peixun2016\"] 第二次：还是一样1234var reg = /\\d+/;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(res); //[\"2015\",index:7,input:\"zhufeng2015peixun2016\"] 如何解决懒惰型： 在正则末尾加上一个修饰符g原理：加了全局修饰符g，正则每一次捕获或，我们的lastIndex的值都变为了最新的值，下一次捕获从最新的位置开始查找。1234567var reg = /\\d+/g;var str = \"zhufeng2015peixun2016\";var res = reg.exec(str);console.log(reg.lastIndex); //匹配开始位置 0console.log(res); //[“2015”,index:7,input:“zhufeng2015peixun2016”]Console.log(reg.lastIndex); //匹配开始位置 11console.log(res); //[“2016”,index:7,input:17“zhufeng2015peixun2016”] 捕获全部内容：12345678var reg = /\\d+/g;var str = \"zhufeng2015peixun2016\";var arr = [];while(res)&#123;arr.push(res[0]);res = reg.exec(str);&#125;console.log(arr); 2.贪婪性正则的每一次捕获都是按照匹配最长的结果捕获的例如：2符合正则2015也符合正则，我们默认捕获的是2015如何解决贪婪性：在量词元字符后面加上？即可12345678var reg = /\\d+?/g;var str = \"zhufeng2015peixun2016\";console.log(reg.exec(str)); //[\"2\",....]var ary = [],res = reg.exec(str);while(res)&#123;ary.push(res[0]);&#125;console.log(ary); 4正则分组4.1 分组引用\\2代表和第二个分组出现一模一样的内容；\\1和第一个分组出现一模一样的内容：一模一样：和对应的分组中的内容的值都要一样123var reg = /^(\\w)\\1(\\w)\\2$/;Console.log(reg.test(\"zzff\")); //trueConsole.log(reg.test(\"z0f_\")); //false 4.2 分组捕获正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到 (?:)在分组中?:的意思是只匹配不捕获 1234var reg = /^(\\d&#123;2&#125;(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(?:\\d&#123;2&#125;)(\\d)(?:\\d|X))$/ var str = \"142726199009181211\";console.log(reg.exec(str));// ary = [\"142726199009181211\", \"142726199009181211\", \"2726\", \"1990\", \"09\", \"18\", \"1\", index: 0, input: \"142726199009181211\", groups: undefined] ary[0] 大写正则匹配的全部内容ary[1] 第一个分组捕获的内容ary[2] 第二个分组捕获的内容Match捕获： console.log(str.match(reg)) 和exec获取的结果一样不同:12345var reg = /zhufeng(\\d+)/gvar str = \"zhufeng1234zhufeng3456zhufeng5678\";console.log(reg.exec(str)); //[\"zhufeng1234\", \"1234\", index: 0, input: \"zhufeng1234zhufeng3456zhufeng5678\", groups: undefined]console.log(reg.exec(str)); //[\"zhufeng3456\", \"3456\", index: 11, input: \"zhufeng1234zhufeng3456zhufeng5678\", groups: undefined]console.log(reg.exec(str)); //[\"zhufeng5678\", \"5678\", index: 22, input: \"zhufeng1234zhufeng3456zhufeng5678\", groups: undefined] 而match只能捕获大正则匹配的内容1console.log(str.match(reg)) //[\"zhufeng1234\", \"zhufeng3456\", \"zhufeng5678\"] 5 练习1.有效数字的正则1）”.”可以出现也可以不出现，一旦出现后面要跟着一位或多位数字2）最开始可以使+/-也可以没有3）整数部分，一位数可以使0-9之间的一个，多位数不能以0开头1var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ 2.年龄介于18-65之间 18-19 20-59 60-651var reg = /^[+-]?(\\d|([1-9]\\d+))(\\.\\d+)?$/ 3.邮箱认证（简版）左侧：数字，字母，下划线。。。1var reg = /^[\\w.-]+@[0-9a-zA-Z]+(\\.[a-zA-Z]&#123;2,4&#125;)(1,2)$/; 4.中国标准实名2-4位1var reg = /^[\\u4e00-\\u9fa5]&#123;2,4&#125;$/ 5.身份证号123var reg = /^\\d&#123;17&#125;(\\d\\X)$/// 21 0302 1990 12 30 00 1 9var reg = /^(\\d&#123;2&#125;(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X))$/"},{"title":"HTTP简述","date":"2018-11-15T07:28:39.000Z","path":"2018/11/15/HTTP简述/","text":"0简述0.1访问过程在输入网站到出现页面经历了怎样的心路历程？[Request请求阶段]1.首先根据用户输入的域名，到DNS服务区上进行反解析（通过域名找到对应服务器的外网IP）2.通过找到的外网IP，找到对应的服务器3.通过在地址栏中的端口号（没输入是因为不同协议都有自己默认的端口号）找到服务器上发布的对应项目 [Response请求阶段]4.服务器获取到请求资源文件的地址 例如：/stu/index.html把资源文件中的源代码找到5.服务器端会把找到的源代码返给客户端（通过HTTP等协议返回的） [浏览器渲染]6.客户端接收到源代码后，会交给浏览器内核进行渲染，最后由浏览器绘制出对应的页面 0.2URI，URL，URN1.[URI]统一资源标识符 2.[URN]统一资源路径地址 3.[URL]统一资源名称 URI = URL + URN 0.3 传输协议传输协议是用来完成客户端和服务器端的数据（内容）传输的，类似于快递小哥，负责吧客户和商家的物品来回传送 客户端不仅可以向服务器发送请求，而且还可以把一些内容传递给服务器 服务器端也可以吧内容返回给客户端 客户端和服务器端传输的内容总称为HTTP报文，这写报文信息都是基于传输协议完成传输的，客户端传递给服务器端的请求叫请求Request,服务器返给客户端叫响应Response，两个阶段总称为HTTP事务（一件完整的事情） 0.4 HTTP事务 当客户端像服务器端发送请求，此时客户端和服务器端会建立一个传输通道（链接通道），传输协议就是基于这个通道把信息进行传输的 当服务器端接收到请求信息，把内容返回给客户端后，传输协议就回自动销毁关闭0.5 传输协议分类 http:超文本传输协议（客户端和服务器端传输的内容除了文本以外，还可以传输图片，音频等文件流[二进制编码/BASE64码]，以及传输XML格式的数据等,）是目前市场是最广泛应用的传输协议 https:httpssl，它比http更加安全，因为数据内容的传输通道是经历过ssl加密的（他需要在服务器端进行特殊的处理），所以涉及到资金的网站一般都是https协议 ftp:资源文件传输协议，一般用于客户端吧资源文件（不是代码）上传到服务器端，或者从服务器端下载一些资源文件（一般ftp传输的内容会比http这类协议传输的内容多）0.6 HTTP报文 起始行 请求起始行响应起始行 首部（头部） 请求头:内置请求头，自定义请求头 响应头:内置响应头，自定义响应头 通用头:请求和响应都有的 3.主题 请求主题 相应主题 请求XXXX都是客户端设置这些信息，服务端获取这些信息响应XXXX都是服务器端设置的信息，客户端获取这些信息 0.7 总结客户端传递给服务器的诗句 URL问号传递参数 设置请求头 设置请求主体… 服务器端返回给客户端的内容 设置响应头（例如服务器时间） 设置响应主体… 第二部分 设置域名其实就是给不好记得服务器外网IP设置了一个好记的名字顶级域名（一级域名）：qq.com二级域名：www.qq.com v.qq.com sport.qq.com三级域名：kbs.sport.qq.com 第三部分 在服务器发布项目的时候，我们可以通过端口号区分当前服务器上不同的项目 一台服务器的端口号取值范围0-65535之间，如果电脑上安装了很多的程序，有一些端口号被占用了 HTTP：默认端口号80HTTPS：默认端口号443FTP：默认端口号21关于上诉三个端口号其实是很重要的，如果被其他程序占用，我们则不能使用了，所以服务器上一般是禁止安装其他应用程序的 第四部分：请求资源文件的路径名称 /stu/index.html 在服务器中发布项目的时候，我们一般都会配置一些默认文档：用户即便不输入请求文件的名称，服务器也会找到默认文档（一般默认文档都是index/default。。。） 我们通常为了做SEO优化，会把一些动态页面的地址（XX.PHP,XXX.ASP,XXX.JSP。。。）进行伪URL重写（需要服务器处理） http://item.jd.com/4325427.html不可能有一个商品，自己就单独写一个详情页面，肯定是同一个详情页做的不同处理 1) 第一种方案：由后台语言根据详情页模板动态生成具体的详情页面2) 第二种方案当前页面就是一个页面，例如：detail.html/detail.php…，我们做详情页面的时候，开发是按照detail.html?id=4325427来开发的；但是这方便做SEO优化。此时我们把真是的地址进行重写，重写为我们看到的4325427.html 第五部分：问号传参 ?name=zf&amp;age=9…把一些值通过xxx=xxx的方式，放在一个URL的末尾，通过问号传递 [作用] 在AJAX请求中，我们可以通过问号传递参数的方式，客户端把一些信息传递给服务器，服务器根据传递信息的不一样，返回不同的数据 123456// $.ajax(url,&#123;&#125;);// $.get(url,function()&#123;&#125;;)对于AJAX请求的特殊写法，原理上还是局域AJAX方法实现的$.post/$.script...$.ajax(&#123; url:'getPersonInfo?id=12'&#125;) 消除AJAX轻轻中GET方式缓存 1234$.ajax(&#123; url:'xxx?=0.123456', method:'get'&#125;); 我们会在请求URL的末尾加一个_=随机数，保证每一次请求的URL都是不一样的，以此来消除GET请求遗留的缓存问题 通过URL传递参数的方式，可以实现页面之间信息通信，例如：我们有两个页面A,B，A是列表页面B是详情页面，点击A中的某一条信息，进入到唯一的详情页面B，如何展示不同的信息，这种操作就是基于URL问号传递参数来实现的 在进入页面的时候，我们可以获取URL传递的参数值，根据传递参数值不一样，从服务器端获取不同的数据展示 在列表页面进行页面跳转的时候，我们需要记住的是跳转的同时传递不同的参数值 第六部分：HASH值 URL末尾传递的井号什么，就是HASH值[作用] 页面中锚点定位 前端路由（SPA单页面开发） 1优化技巧WEB前端开发常用的优化技巧减少HTTP请求的次数页面中每发送一次HTTP请求，都需要完成请求+响应这个完整的HTTP事务，会消耗一些时间，也可能会导致HTTP链接通道堵塞，为了提高页面加载速度和运行性能，我们应该减少HTTP的请求次数 采用CSS雪碧图（CSS Sprit/CSS 图片精灵）技术，把一些小图片合并在一张大图上，使用的时候通过背景图定位，定位到具体的某一张小图上css:1234567.pubBg&#123; background:url(\"../img/sprit.png\") no-repeat; background-size:x y;/*和原图的大小保持一致*/&#125;.box&#123; background-position: x y;/*通过背景定位，定位到具体的位置，展示不同的图片*/&#125; 1&lt;div class=\"pubBg box\"&gt;&lt;/div&gt; 真实项目中，我们最好把CSS或者JS文件进行合并压缩；尤其是在移动端开发的时候，如果CSS或者JS内容不是特别多，我们可以采取内嵌模式，以此减少HTTP请求的次数，加快页面加载速度：1) CSS合并成一个，JS最好也合并成一个2) 首先通过一些工具（例如：webpack）把合并后的CSS或者JS压缩成XX.min.js，减少文件大小3) 服务器端开启资源文件的GZIP压缩…通过一些自动化工具完成CSS以及JS的合并压缩，或者再完成LESS转CSS，ES6转ES5等操作，我们把这种自动化构建模式，称之为前端工程化开发 采用图片懒加载技术，在页面开始加载的时候，不请求真实的图片地址，而是用默认占图占位，当页面加载完成后，根据相关条件一次加载真实图片（减少页面首次加载HTTP请求的次数）真实项目中，我们开始图片都不加载，页面首次记载完成，先把第一屏中可以看见的图片进行加载，随着页面滚动，把下面区域中能够有显现的图片进行加载。 对于不经常更新的数据，最好采用浏览器的304缓存做处理例如：第一次请求CSS和JS下来，浏览器会把请求的内容缓存起来，如果做了304处理，用户再起请求CSS和JS。直接从缓存中读取，不需要再去服务器获取了（减少了HTTP请求次数） 当用户刷新页面（CTRL+F5）或者当前缓存的CSS或者JS发生了变动，都会从新从服务器进行拉取 对于客户端来讲，我们还可以基于localStorage来做一些本地存储，例如：第一次请求的数据或者不经常更新的CSS和JS，我们都可以吧内容存储在本地，下次页面加载，我们从本地中获取即可，我们设定一定期限或者一些标识，可以控制在某个阶段重新从服务器获取 根据图片懒加载级啊，我们可以扩充出，数据懒加载。懒加载1）开始加载页面的时候，我们只把首屏或者前两屏的数据从服务器端进行请求（有些网站首屏数据是后台渲染好的，整体返给客户端显现的）2) 当页面下拉，滚动到那个区域，在把这个区域所需要的数据进行轻轻（请求回来做数据绑定以及图片延迟加载等）3) 分页展示技术采用的也是数据的懒加载技术实现的：如果我们请求获取的数据是很多的数据，我们最好分批请求，开始只请求第一页的数据，当用户点击第二页（微博的下拉到一定距离后，宰庆秋第二页数据。。。）的时候再请求第二页数据。。。 5. 使用字体图标代替一些页面中的位图（图片），这样不仅做适配的时候方便，而且更加轻量级，而且减少了HTTP请求的次数（类似雪碧图） 如果当前页面中出现了AUDIO或者VIDEO标签，我们最好设置他们的preload=none：页面加载的时候，音频和视频不进行加载，播放的时候再开始加载（减少页面瘦子加载HTTP请求的次数）preload=auto：页面首次加载的时候就把音频和视频资源进行加载了preload=metadata：页面首次加载的时候只把音频视频资源的头部信息进行加载（比如时长） 7.在客户端和服务器端进行通信数据的时候，我们尽量采用JSON格式进行数据传输[优势]1) JSON格式的数据，能够清晰明了的展示出数据结构，而且也方便我们获取的操作2) 相对于很早以前的XML格式传输，JSON格式的数据更加轻量级3) 客户端和服务器端都支持JSON格式数据的处理，处理起来非常方便 真实项目中，并不是所有的数据都是JSON，我们尽量可能这样做，但是对于某些特殊需求（例如：文件流的传输或者文档传输），使用JSON就不合适了 采用CDN加速CDN地域式（地域分布式） 关于编写代码时候的一些优化技巧除了减少HTTP请求次数和大小可以优化性能，我们在编写代码的时候，也可以进行一些优化，让页面的性能有所提升（有些不好的代码编写习惯会导致页面性能消耗太大，例如：内存泄露） 在编写JS代码的时候剑灵减少对DOM的操作在JS中操作DOM是一个非常消耗性能的事情，但是我们有不可避免的操作DOM，我们只能尽量减少对于它的操作 [操作DOM弊端]1) DOM存在映射机制（JS中的DOM元素对象和页面中的DOM结构是存在映射机制的，一改则都改）这种映射机制，是浏览器按照W3C标准完成对JS语言的构建和DOM的构建（其实就是构建了一个监听机制），操作DOM是同时要修改两个地方，相对于一些其他的JS变成来说是消耗性能的。2) 页面中的DOM结构改变或者样式改变，会触发浏览器的回流（浏览器会把DOM结构重新进行计算，这个操作很消耗性能）和重绘（把一个元素的样式重新渲染） 编写代码的时候，更多的使用异步编程同步变成会导致：上面东西不完成，下面任务也做不了，我们开发的时候，可以吧某一区域模块都设置为异步编程，这样只要模块之间没有必然的先后顺序，都可以独立进行加载，不会受到上面模块的堵塞影响（用的不多） 尤其是AJAX数据请求，我们一般都需要使用异步编程，最好是基于promise设计模式进行管理（项目中经常使用fetch，axios等插件来进行AJAX请求处理，因为这些插件中就是基于promise设计模式对ajax进行的封装处理） 在真实项目中，我们尽量避免一次性循环过多数据（因为循环操作是同步编程），尤其是要避免while导致的死循环操作 CSS选择器优化1) 尽量减少标签选择器的使用2) 尽可能少使用ID选择器，多使用样式雷选择器（通用性强）3) 减少选择器前面的前缀，例如：1.headerBOX .nav .left a&#123;&#125; (选择器是从右往左查找的) 避免使用CSS表达式123.box&#123;background-color: expression((new Data()).getHours()%2?'red':'blue');&#125; 减少页面中的用于代码，尽可能提高方法的重复使用率：“低耦合高内聚” 最好CSS放在HEAD中，JS放在BODY尾部，让页面加载的时候，先加载CSS，在加载JS（先呈现页面，在给用户提供操作） JS中避免使用eval1) 性能消耗大2) 大妈压缩后，容易出现代码执行错乱问题 JS中尽量减少闭包的使用1) 闭包会形成一个不销毁的栈内存，过多的栈内存积累会影响页面的性能2) 还会容易导致内存的泄露 闭包自己的优势：保存和保护，我们只能尽量减少，但是无可避免 在做DOM事件绑定的时候，尽量避免一个个的事件绑定，而是采用性能更高的事件委托来实现 事件委托（事件代理）把事件绑定给外层容器，当里面的后代元素相关行为被触发，外层容器绑定的方法也会被触发执行（冒泡传播机制导致），通过事件源是谁，我们做不同的操作即可 尽量使用CSS3动画代替JS动画，因为CSS3的动画或者变形都开启了硬件加速，性能比JS动画好 编写JS代码的时候尽可能使用设计模式来构建体系，方便后期的维护，也提高了扩充性 关于页面的SEO优化技巧 页面中杜绝出现死链接（404页面）而对于用户用户输入一个错误页面我们要引导到404提示页面中（服务器处理的） 避免浏览器中异常错误的抛出尽可能避免代码出错使用TYE CATCH做异常信息捕获"},{"title":"安装mongodb","date":"2018-11-12T08:05:01.000Z","path":"2018/11/12/安装mongodb/","text":"0下载mongodb0.1下载去mongodb官网下载，传送门选择相应版本进行下载如图所示： 0.2解压tar包进入所mongodb下载位置，进行解压 tar -zxvf mongodb-linux-x86_64-rhel62-4.0.4.tgz 之后将解压包拷贝到指定目录 mv mongodb-linux-x86_64-rhel62-4.0.4/ /usr/local/mongodb 1创建配置文件1.1创建数据库文件夹进入对应的文件夹下 mkdir data 1.2创建日志文件 mkdir log 1.3 创建配置文件夹etc mkdir etc 1.4 创建配置文件进入etc目录下 cd /usr/local/mongodb/etc 在这个目录下创建mongodb.conf vim mongodb.conf 这里根据个人的安装路径进行配置，基于我的路径进行如下配置：12345678910111213141516#数据库路径dbpath=/usr/local/mongodb/data#日志输出文件路径logpath=/usr/local/mongodb/log/mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port=27017#关闭http接口，默认关闭27018端口访问#nohttpinterface = true#以守护程序的方式启用，即在后台运行fork = true 2启动mongodb2.1简单的启动mongodb进入mongodb文件下的bin文件夹下 cd /usr/local/mongodb/bin 执行命令./mongo即可 ./mongod -f /usr/local/mongodb/etc/mongodb.conf 之后我们可以查看27017端口号是否启动 netstat -tunlp|grep 27017 如图所示： 2.2添加管理用户(mongoDB 没有无敌用户root，只有能管理用户的用户 userAdminAnyDatabase)利用mongo命令连接mongoDB服务器端： ./mogo 输入下面命令进行添加用户1234&gt; use adminswitched to db admin&gt; db.createUser( &#123;user: &quot;pfnieadmin&quot;,pwd: &quot;123456&quot;,roles: [ &#123; role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; &#125; ]&#125;); 成功后，你将会看到:添加完用户后可以使用show users或db.system.users.find()查看已有用户.添加完管理用户后，关闭MongoDB，并使用权限方式再次开启MongoDB，这里注意不要使用kill直接去杀掉mongodb进程，（如果这样做了，请去data/db目录下删除mongo.lock文件），可以使用db.shutdownServer()关闭. 2.3使用权限方式启动在配置文件中添加：auth=true , 然后启动：1234567891011121314151617#数据库路径dbpath=/usr/local/mongodb/data#日志输出文件路径logpath=/usr/local/mongodb/log/mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port=27017#关闭http接口，默认关闭27018端口访问#nohttpinterface = true#以守护程序的方式启用，即在后台运行fork = trueauth=true 进入mongo shell，使用admin数据库并进行验证，如果不验证，是做不了任何操作的。 use admin db.auth(“pfnieadmin”,”123456”) #认证，返回1表示成功 如图所示，在进入mogoshell时直接用show users会报错，只有先认证后才能使用shell 3优化mongodb3.1设置mongod环境变量 cd /etcvim profile 到etc下打开profile文件在/etc/profile文件中，添加 export PATH=$PATH:/usr/local/mongoDB/mongodbserver/bin 如图所示：执行source /etc/profile，使系统环境变量立即生效 3.2设置mongo软连接 ln -s /usr/local/mongodb/bin/mongo /usr/bin/mongo 配置完成这些，我们关闭mongo服务，可以随处启动mongo mongod -f /usr/local/mongodb/etc/mongodb.conf 4遇到的坑如果单单是这样配置后，mongodb只能在本地使用,我们可以测试一下，输入命令 netstat -tnlp 如图所示：想要远程使用，需要配置配置文件mongodb.conf在mongodb. bind_ip=0.0.0.0 最终配置文件如下12345678910111213141516171819#数据库路径dbpath=/usr/local/mongodb/data#日志输出文件路径logpath=/usr/local/mongodb/log/mongodb.log#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件logappend = true#启用日志文件，默认启用journal = true#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet = true#端口号 默认为27017port=27017#关闭http接口，默认关闭27018端口访问#nohttpinterface = true#以守护程序的方式启用，即在后台运行fork = trueauth=true#绑定端口号，否则外网无法访问bind_ip=0.0.0.0 这时候我们再测试 netstat -tnlp 结果如图所示：之后我们需要配置腾讯云安全组：这时候我们通过浏览器进行访问，如图所示：这样我们就通过我们的本地工具进行连接吧，这里推荐工具ROBO连接后效果如图所示：为了方便使用我这里先把auth=true注掉取消认证"},{"title":"安装MySQL","date":"2018-11-12T06:19:05.000Z","path":"2018/11/12/安装MySQL/","text":"1.新建用户 1.1 登录MYSQL： @&gt;mysql -u root -p @&gt;密码 1.2 创建用户： mysql&gt; insert into mysql.user(Host,User,Password) values(“localhost”,”test”,password(“1234”)); 这样就创建了一个名为：test 密码为：1234 的用户。 注意：此处的”localhost”，是指该用户只能在本地登录，不能在另外一台机器上远程登录。如果想远程登录的话，将”localhost”改为”%”，表示在任何一台电脑上都可以登录。也可以指定某台机器可以远程登录。 1.3 然后登录一下： mysql&gt;exit; @&gt;mysql -u test -p @&gt;输入密码 mysql&gt;登录成功 2.为用户授权 授权格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”; 2.1 登录MYSQL（有ROOT权限），这里以ROOT身份登录： @&gt;mysql -u root -p @&gt;密码 2.2 首先为用户创建一个数据库(testDB)： mysql&gt;create database testDB; 2.3 授权test用户拥有testDB数据库的所有权限（某个数据库的所有权限）： mysql&gt;grant all privileges on testDB.* to test@localhost identified by ‘1234’; mysql&gt;flush privileges;//刷新系统权限表 格式：grant 权限 on 数据库.* to 用户名@登录主机 identified by “密码”; 2.4 如果想指定部分权限给一用户，可以这样来写: mysql&gt;grant select,update on testDB.* to test@localhost identified by ‘1234’; mysql&gt;flush privileges; //刷新系统权限表 2.5 授权test用户拥有所有数据库的某些权限： mysql&gt;grant select,delete,update,create,drop on . to test@”%” identified by “1234”; //test用户对所有数据库都有select,delete,update,create,drop 权限。 //@”%” 表示对所有非本地主机授权，不包括localhost。（localhost地址设为127.0.0.1，如果设为真实的本地地址，不知道是否可以，没有验证。） //对localhost授权：加上一句grant all privileges on testDB.* to test@localhost identified by ‘1234’;即可。 删除用户 @&gt;mysql -u root -p @&gt;密码 mysql&gt;Delete FROM user Where User=’test’ and Host=’localhost’; mysql&gt;flush privileges; mysql&gt;drop database testDB; //删除用户的数据库 删除账户及权限：&gt;drop user 用户名@’%’; &gt;drop user 用户名@ localhost; 修改指定用户密码 @&gt;mysql -u root -p @&gt;密码 mysql&gt;update mysql.user set password=password(‘新密码’) where User=”test” and Host=”localhost”; mysql&gt;flush privileges; 列出所有数据库 mysql&gt;show database; 切换数据库 mysql&gt;use ‘数据库名’; 列出所有表 mysql&gt;show tables; 显示数据表结构 mysql&gt;describe 表名; 删除数据库和数据表 mysql&gt;drop database 数据库名; mysql&gt;drop table 数据表名;"},{"title":"构建cli脚手架","date":"2018-11-11T04:38:43.000Z","path":"2018/11/11/构建cli脚手架/","text":"0搭建前准备环境0.1创建项目nodejs环境是必备的，这里不多说了，首先需要 npm init -y初始化一个项目。然后创建一个index.js,整个项目结构如下.之后我们需要写的部分都在index.js中。 0.2配置项目 这里注意下为了系统能识别为node脚本，需要在index首行声明如下 #!/usr/bin/env node 配置package.json在末尾加上这段配置 “license”: “ISC”, “bin”: { “cli”: “index.js” }, 说明一下cli即为我们的命令，可以理解为vue-cliindex则为我们需要执行的脚本 0.3生成全局命令在index.js的目录下输入 npm link 这样就生成了全局变量，在任何地方只要输入cli就会执行index.js中的脚本。可以写一个console.log试试 1命令包安装commander.js1.1commander说明commander是一个轻巧的nodejs模块，提供了用户命令行输入和参数解析强大功能可以在github上直接搜索这个项目传送门下载 npm install commander -s 引用 const program = require(‘commander’); 1.2commander配置直接复制Examples下的代码到index中1234567891011121314program .command('exec &lt;cmd&gt;') .alias('ex') .description('execute the given remote cmd') .option(\"-e, --exec_mode &lt;mode&gt;\", \"Which exec mode to use\") .action(function(cmd, options)&#123; console.log('exec \"%s\" using %s mode', cmd, options.exec_mode); &#125;).on('--help', function() &#123; console.log(''); console.log('Examples:'); console.log(''); console.log(' $ deploy exec sequential'); console.log(' $ deploy exec async'); &#125;); 这些就是一个命令全部内容命令名称为： .command(‘exec [env]’) list代表命令名称 [env]代表参数其中[]内的参数为可选参数其中&lt;&gt;内的参数为必填参数命令说明为： .description(‘execute the given remote cmd’) 操作方法为： .action(function(template, project){} 输入–help操作为： .on(‘–help’, function() {}) 其中 –help命令不需要额外配置，它会根据配置自动生成 1.3commander错误命令提示错误配置代码如下：12345program .command('*') .action(function(env)&#123; console.log('deploying \"%s\"', env); &#125;); 1.4commander配置版本号版本号配置代码如下12program .version('0.1.0') //调用-v或者 --version的时候输出该版本号 2下载包download-git-repo.js2.1准备模板这里我准备了三个模板供下载，在github上创建三个空项目，自动生成README.md出来如图所示：.创建项目这里就不多说了。 2.2下载download-git-repo.js用npm下载 npm install download-git-repo -s 引用 const download = require(‘download-git-repo’) 传送门 123download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; console.log(err?'err':'success')&#125;) downloadUrl 为仓库地址路径 project 为创建项目的名称，即我本地想叫什么名 {clone:true} 进行克隆 err=&gt;{}错误原因并在下载结束后执行方法2.3完成下载我们希望输入命令 cli vue new_vue 生成一个new_vue的项目并应用我们的vue_template模板，同理其他模板也用相应命令进行创建 首先我们创建一个对象来放我们的模板名称和路径和简介1234567891011121314151617templates=&#123; 'vue':&#123; url:\"https://github.com/linjiad/vue_template.git\", description:\"vue模板\", downloadUrl:\"direct:https://github.com:linjiad/vue_template#master\" &#125;, 'react':&#123; url:\"https://github.com/linjiad/react_template.git\", description:\"react模板\", downloadUrl:\"direct:https://github.com:linjiad/react_template#master\" &#125;, 'angular':&#123; url:\"https://github.com/linjiad/angular_template.git\", description:\"angular模板\", downloadUrl:\"direct:https://github.com:linjiad/angular_template#master\" &#125;&#125; 这里开始写program命令12345678910111213141516program .command('init &lt;template&gt; &lt;project&gt;') //命令 .description('初始化项目模板') .action(function(template, project)&#123; const &#123;downloadUrl&#125; = templates[template]; //根据模板名(template)下载对应模板，并命名为(project) //第一个参数：仓库地址 //第二个参数：下载路径,下载到哪 download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; if(err)&#123; return console.log('下载失败：'+err); &#125; else&#123; return console.log('下载成功'); &#125; &#125;) &#125;); 这样简单的模板下载就成功了 3交互handlebars和inquirer3.1配置模板中的package.json在模板中创建package.json,同时把需要客户填写的地方配置成可变的,代码如下123456789101112&#123; \"name\": \"&#123;&#123; name &#125;&#125;\", \"version\": \"1.0.0\", \"description\": \"&#123;&#123; description &#125;&#125;\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"keywords\": [], \"author\": \"&#123;&#123; author &#125;&#125;\", \"license\": \"ISC\"&#125; 其中”name”: ““为用户输入的项目名 “description”: ““,为项目说明 “author”: “linjiad“,为作者姓名3.2下载handlebars和inquirer handlebars:模板引擎传送门 npm install handlebars -s 引用 const handlebars = require(‘handlebars’); inquirer:向导传送门 npm install inquirer -s 引用 const handlebars = require(‘inquirer’); 3.2修改program命令我们的思路分为以下几部 把项目下的 package.json 文件读取出来 使用想到的方式采集用户输入的值 使用模板引擎把用户输入的数据解析到package.json中 解析完毕，把解析之后的结果重新写入package.json中在此之前我们要用的nodejs中的读写fs模块 const fs = require(‘fs’); 修改后代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243program .command('init &lt;template&gt; &lt;project&gt;') //命令 .description('初始化项目模板') .action(function(template, project)&#123; const &#123;downloadUrl&#125; = templates[template]; //根据模板名(template)下载对应模板，并命名为(project) //第一个参数：仓库地址 //第二个参数：下载路径,下载到哪 download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; if(err)&#123; return console.log('下载失败：'+err); &#125; else&#123; // 把项目下的package.json读取 // 采取向导方式采集用户输入的值 // 使用模板引擎把用户输入的数据解析到package.json // 解析之后的结果从新写入package.json inquirer.prompt([ &#123; typ: 'input', name: 'name', message: '请输入项目名称' &#125;, &#123; typ: 'input', name: 'description', message: '请输入项目简介' &#125;, &#123; typ: 'input', name: 'author', message: '请输入作者姓名' &#125;, ]).then((answers)=&gt;&#123; const packagePath = `$&#123;project&#125;/package.json`; //把数据替换到package.json中 const packageContent = fs.readFileSync(packagePath,'utf8'); const packageResult = handlebars.compile(packageContent)(answers); fs.writeFileSync(packagePath,packageResult) console.log(logSymbols.success,chalk.green(\"初始化模板成功\")) &#125;) &#125; &#125;) &#125;); 这样整个cli脚本就更加人性化了 4美化脚本4.1添加loading效果 ora.jsora:loading美化传送门下载 npm install ora -s 引用 var ora = require(‘ora’); 使用： const spinner = ora(‘正在下载模板…’).start(); spinner.fail(‘下载失败’);//下载失败提示 spinner.succeed(‘下载成功’); //下载成功提示 4.2添加字体颜色 ora.jschalk:字体美化传送门下载 npm install chalk -s 引用 var chalk = require(‘chalk’); 使用： chalk.red(“错误”)chalk.green(“成功”) 4.3特殊符号 log-symbols.jslog-symbols:特殊符号，如对号错号传送门下载 npm install log-symbols -s 引用 var logSymbols = require(‘log-symbols’); 使用： console.log(logSymbols.erro);console.log(logSymbols.success); 4.4修改program命令修改后的代码如下(既全部代码)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#!/usr/bin/env node//命令包const program = require('commander');//下载包const download = require('download-git-repo')//模板引擎const handlebars = require('handlebars');//向导const inquirer = require('inquirer');const fs = require('fs');//loading美化var ora = require('ora');//字体美化const chalk = require('chalk');//符号const logSymbols = require('log-symbols')program .version('0.1.0') //调用-v或者 --version的时候输出该版本号const templates=&#123; 'vue':&#123; url:\"https://github.com/linjiad/vue_template.git\", description:\"vue模板\", downloadUrl:\"direct:https://github.com:linjiad/vue_template#master\" &#125;, 'react':&#123; url:\"https://github.com/linjiad/react_template.git\", description:\"react模板\", downloadUrl:\"direct:https://github.com:linjiad/react_template#master\" &#125;, 'angular':&#123; url:\"https://github.com/linjiad/angular_template.git\", description:\"angular模板\", downloadUrl:\"direct:https://github.com:linjiad/angular_template#master\" &#125;&#125;program .command('init &lt;template&gt; &lt;project&gt;') //命令 .description('初始化项目模板') .action(function(template, project)&#123; //下载之前做loading提示 const spinner = ora('正在下载模板...').start(); const &#123;downloadUrl&#125; = templates[template]; //根据模板名下载对应模板，并命名为project //第一个参数：仓库地址 //第二个参数：下载路径,下载到哪 download(downloadUrl,project,&#123;clone:true&#125;,(err)=&gt;&#123; if(err)&#123; spinner.fail('下载失败');//下载失败提示 return console.log(logSymbols.error,chalk.red(err)) &#125; spinner.succeed('下载成功'); //下载成功提示 // 把项目下的package.json读取 // 采取向导方式采集用户输入的值 // 使用模板引擎把用户输入的数据解析到package.json // 解析之后的结果从新写入package.json inquirer.prompt([ &#123; typ: 'input', name: 'name', message: '请输入项目名称' &#125;, &#123; typ: 'input', name: 'description', message: '请输入项目简介' &#125;, &#123; typ: 'input', name: 'author', message: '请输入作者姓名' &#125;, ]).then((answers)=&gt;&#123; const packagePath = `$&#123;project&#125;/package.json`; //把数据替换到package.json中 const packageContent = fs.readFileSync(packagePath,'utf8'); const packageResult = handlebars.compile(packageContent)(answers); fs.writeFileSync(packagePath,packageResult) console.log(logSymbols.success,chalk.green(\"初始化模板成功\")) &#125;) &#125;) &#125;);program .command('list') //命令 .description('查看所有可用模板') .action(()=&gt;&#123; for(const key in templates)&#123; console.log(`$&#123;key&#125;:$&#123;templates[key].description&#125;.`) &#125; &#125;);program .command('setup [env]') //命令 .description('run setup commands for all envs') .option(\"-s, --setup_mode [mode]\", \"Which setup mode to use\") .action(function(env, options)&#123; var mode = options.setup_mode || \"normal\"; env = env || 'all'; console.log('setup for %s env(s) with %s mode', env, mode); &#125;);program .command('exec &lt;cmd&gt;') .alias('ex') .description('execute the given remote cmd') .option(\"-e, --exec_mode &lt;mode&gt;\", \"Which exec mode to use\") .action(function(cmd, options)&#123; console.log('exec \"%s\" using %s mode', cmd, options.exec_mode); &#125;).on('--help', function() &#123; console.log(''); console.log('Examples:'); console.log(''); console.log(' $ deploy exec sequential'); console.log(' $ deploy exec async');&#125;);program .command('*') //其他的命令 .action(function(env)&#123; console.log('不存在 \"%s\"命令', env); &#125;);program.parse(process.argv); 5npm发布包 打开npm官网 注册一个npm账号 在npm官网上搜索是否有重名4.讲package.json中的那么修改为发布到npm上的名 和本地项目名称没有关系 5.打开控制台，执行npm login，在控制台输入登录6.登陆成功后，在项目下执行npm publish进行发布7 在其他电脑上就可以安装成全局变量了 这样一个脚手架就搭建完毕了"},{"title":"Nginx服务2","date":"2018-11-11T01:09:07.000Z","path":"2018/11/11/Nginx服务2/","text":"5 权限管理5.1 简单权限控制有时候我们的服务器只允许特定主机访问，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在location里进行配置。可以直接在default.conf里进行配置。1234location / &#123; deny 123.9.51.42; allow 45.76.202.231;&#125; 5.2 复杂访问控制权限匹配在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。上面的需求，配置代码如下：123456location =/img&#123; allow all; &#125;location =/admin&#123; deny all;&#125; =号代表精确匹配，使用了=后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全。 5.3 使用正则表达式设置访问权限只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。代码如下：123location ~\\.php$ &#123; deny all;&#125; 6 Nginx设置虚拟主机6.1基于端口号配置虚拟主机基于端口号来配置虚拟主机，算是Nginx中最简单的一种方式了。原理就是Nginx监听多个端口，根据不同的端口号，来区分不同的网站。我们可以直接配置在主文件里etc/nginx/nginx.conf文件里， 也可以配置在子配置文件里etc/nginx/conf.d/default.conf。我这里为了配置方便，就配置在子文件里了。当然你也可以再新建一个文件，只要在conf.d文件夹下就可以了。添加配置文件中的server选项，这时候就会有两个server。123456server&#123; listen 8001; server_name localhost; root /usr/share/nginx/html/html8001; index index.html; &#125; 编在usr/share/nginx/html/html8001/目录下的index.html文件并查看结果。1&lt;h1&gt;welcome port 8001&lt;/h1&gt; 最后在浏览器中分别访问地址和带端口的地址。看到的结果是不同的。然后我们就可以在浏览器中访问http://112.74.164.244:8001了。 6.2基于IP的虚拟主机基于IP和基于端口的配置几乎一样，只是把server_name选项，配置成IP就可以了。比如上面的配置，我们可以修改为：123456server&#123; listen 80; server_name 112.74.164.244; root /usr/share/nginx/html/html8001; index index.html; &#125; 7 Nginx使用域名这里我购买的是腾讯云，所以根据提示直接在腾讯云上进行配置按照提示填写即可修改配置即可123456server&#123; listen 80; server_name www.linjiad.cn; root /usr/share/nginx/html/html8001; index index.html; &#125; 8Nginx反向代理8.1正向代理和反向代理大家都知道，我们现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。正向代理:如果你觉的反向代理不好理解，那先来了解一下正向代理。我相信作为一个手速远超正常人的程序员来说，你一定用过翻墙工具（我这里说的不是物理梯子），它就是一个典型的正向代理工具。它会把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做proxy服务器，再转发给客户。简单来说就是你想访问目标服务器的权限，但是没有权限。这时候代理服务器有权限访问服务器，并且你有访问代理服务器的权限，这时候你就可以通过访问代理服务器，代理服务器访问真实服务器，把内容给你呈现出来。 反向代理:反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。反向代理的用途和好处: 安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。 功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡8.2最简单的反向代理现在我们要访问http://www.linjiad.cn:8002/然后反向代理到http://www.linjiad.cn这个网站。我们直接到etc/nginx/con.d/8001.conf进行修改。添加个配置文件如下：1234567server&#123; listen 8002; server_name localhost; location / &#123; proxy_pass http://www.linjiad.cn; &#125;&#125; 一般我们反向代理的都是一个IP，但是我这里代理了一个域名也是可以的。其实这时候我们反向代理就算成功了，我们可以在浏览器中打开 8.3其它反向代理指令反向代理还有些常用的指令，我在这里给大家列出： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。9Nginx适配PC或移动设备现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。$http_user_agent的使用：Nginx通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。操作步骤如下： 在/usr/share/nginx/目录下新建两个文件夹，分别为：pc和mobile目录 输入命令如下 cd /usr/share/nginx mkdir pc mkdir mobile 在pc和miblic目录下，新建两个index.html文件，文件里下面内容 12&lt;h1&gt;I am pc!&lt;/h1&gt;&lt;h1&gt;I am mobile!&lt;/h1&gt; 进入etc/nginx/conf.d目录下，修改8001.conf文件，改为下面的形式: 1234567891011server&#123; listen 80; server_name nginx2.jspang.com; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &apos;(Android|webOS|iPhone|iPod|BlackBerry)&apos;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; 10Nginx的Gzip压缩配置10.1Gzip技术Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持从上图可以清楚的明白，gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。 10.2gzip的配置项Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。10.3gzip最简单的配置123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。如果你是windows操作系统，你可以按F12键打开开发者工具，单机当前的请求，在标签中选择Headers，查看HTTP响应头信息。你可以清楚的看见Content-Encoding为gzip类型。"},{"title":"Nginx服务1","date":"2018-11-10T12:32:46.000Z","path":"2018/11/10/Nginx服务1/","text":"0前期准备0.1 安装基础环境 yum -y install gcc gcc-c++ autoconf pcre-devel make automake yum -y install wget httpd-tools vim 0.2建立根目录 进入系统后，在目录下建立了一个linjiad的文件夹，命令是 mkdir linjiad。 进入 linjiad文件夹 ,命令是 cd linjiad。 分别使用mkdir建立 app,backup,download,logs,work文件夹。 1安装Nginx1.1准备安装 yum list | grep nginx 结果显示nginx的各个版本，如图所示： 创建一个文件 vim /etc/yum.repos.d/nginx.repo 复制进去这些配置 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/OS/OSRELEASE/$basearch/gpgcheck=0enabled=1 因为我的是centos和7的版本，所以改为这样。 1baseurl=http://nginx.org/packages/centos/7/$basearch/ 1.2开始安装安装的命令非常简单： yum install nginx 出现如图所示则证明安装成功 2修改Nginx的配置2.1查看nginx的安装查看nginx安装到哪里 rpm -ql nginx出现如图所示 其中nginx.conf 文件是Nginx总配置文件，在我们搭建服务器时经常调整的文件。 2.2配置nginx.conf进入etc/nginx目录下，然后用vim进行打开 cd /etc/nginxvim nginx.conf 配置如下: 1234567891011121314151617181920212223242526272829303132333435363738#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1;#错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; # 单个后台进程的最大并发数 worker_connections 1024;&#125;http &#123; #文件扩展名与类型映射表 include /etc/nginx/mime.types; #默认文件类型 default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #nginx访问日志存放位置 access_log /var/log/nginx/access.log main; #开启高效传输模式 sendfile on; #减少网络报文段的数量 #tcp_nopush on; #保持连接的时间，也叫超时时间 keepalive_timeout 65; #开启gzip压缩 #gzip on; #包含的子配置项位置和文件 include /etc/nginx/conf.d/*.conf;&#125; 进入进入conf.d目录vim default.conf进行查看。conf.d目录下的配置相当于子配置，配置如下1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123;listen 80; #配置监听端口server_name localhost; //配置域名#charset koi8-r; #access_log /var/log/nginx/host.access.log main;location / &#123;root /usr/share/nginx/html; #服务默认启动目录index index.html index.htm; #默认访问文件&#125;#error_page 404 /404.html; # 配置404页面# redirect server error pages to the static page /50x.html#error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启location = /50x.html &#123;root /usr/share/nginx/html;&#125;# proxy the PHP scripts to Apache listening on 127.0.0.1:80##location ~ \\.php$ &#123;# proxy_pass http://127.0.0.1;#&#125;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000##location ~ \\.php$ &#123;# root html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;# include fastcgi_params;#&#125;# deny access to .htaccess files, if Apache&apos;s document root# concurs with nginx&apos;s one##location ~ /\\.ht &#123;# deny all;#&#125;&#125; 通过这个配置我们可以知道我们的服务目录放在了/usr/share/nginx/html下，可以使用命令进入看一下目录下的文件 cd /usr/share/nginx/html ls 3Nginx的命令3.1启动Nginx服务在CentOS7.4版本里（低版本是不行的），是可以直接直接使用nginx启动服务的。 Nginx 使用systemctl命令启动还可以使用个Linux的命令进行启动，我一般都是采用这种方法进行使用。因为这种方法无论启动什么服务，都是一样的，只是换一下服务的名字（不用增加额外的记忆点）。 systemctl start nginx.service 输入命令后，没有任何提示，那我们如何知道Nginx服务已经启动了哪？可以使用Linux的组合命令，进行查询服务的运行状况。 ps aux | grep nginx 如果启动成功会出现如下图片中类似的结果。 3.2停止Nginx服务停止Nginx 方法有很多种，可以根据需求采用不一样的方法。 立即停止服务 ：这种方法比较强硬，无论进程是否在工作，都直接停止进程。 nginx -s stop 从容停止服务:这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。 nginx -s quit killall 方法杀死进程:这种方法也是比较野蛮的，我们直接杀死进程，但是在上面使用没有效果时，我们用这种方法还是比较好的 killall nginx systemctl 停止 systemctl stop nginx.service 3.2重启Nginx服务 重启Nginx服务 systemctl restart nginx.service 重新载入配置文件:重新编写或者修改Nginx的配置文件后，都需要作一下重新载入 nginx -s reload 3.3查看端口号在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用netstat -tlnp命令查看端口号的占用情况。 netstat -tlnp 4 自定义错误页面4.1 通用错误页面在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。 error_page 500 502 503 504 /50x.html; error_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误代码，/50.html 用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。 4.2 单独错误页面 单独为错误置顶处理方式有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下： error_page 404 /404_error.html; 然后到网站目录下新建一个404_error.html 文件，并写入一些信息。123456&lt;html&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;body&gt;&lt;h1&gt;404页面没有找到!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 然后重启我们的服务，再进行访问，你会发现404页面发生了变化。 4.3 错误页面换成地址把错误码换成一个地址处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。 error_page 404 http://www.baidu.com;我们使用了百度作为404页面没有找到的提示，就形成了，没有找到文件，就直接跳到了百度上了。"},{"title":"npm包管理服务器","date":"2018-11-10T09:46:54.000Z","path":"2018/11/10/npm包管理服务器/","text":"npm包管理，搭建自己前端的私库 0前期准备0.1 安装node环境首先介绍一下，可以购买云服务器，也可以自己搭建一个虚机。这里我购买的是腾讯云，购买就不多说了，购买之后下过如下之后去node官网下载node包，下载linux版之后放到linux下面某个目录，根据个人喜好之后进行解压 解压 tar xf node-v10.9.0-linux-x64.tar.xz 这里作为一个强迫症患者，我习惯把解压后的文件进行改名为nodejs 改名 mv node-v10.9.0-linux-x64 nodejs 下一步是配置软连接，可以理解为WIN系统下配置环境变量 配置软连接cd到目录下 ln -s /nodejs/bin/npm /usr/local/bin/ ln -s /nodejs/bin/node /usr/local/bin/ 为了方便以后下载包，我们可以下载一个cnpm 安装cnpm npm install -g cnpm –registry=https://registry.npm.taobao.org 同样建立软连接就不多说了 0.2 下载Sinopia npm install -g sinopia 这里也需要建立软连接 ln -s /usr/download/nodejs/lib/node_modules/sinopia/bin/sinopia /usr/local/bin/ 0.3 下载pm2 npm install -g pm2 建立软连接 ln -s /download/nodejs/lib/node_modules/pm2/bin/pm2 /usr/local/bin/ 1配置Sinopia1.1 首先开通端口号我这里用的是腾讯云，开通端口号在安全组中配置，如图所示 这里还有个坑，仅仅开通了端口号是不够的,还需要配置config.yml文件否则还是访问不到的 1.2 配置config.yaml文件打开config.yml文件，这个文件地址在 vim /root/.config/sinopia/config.yaml 在配置最后添加监听 listen: 0.0.0.0:4873 如图所示 config.config.yaml整体配置如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# 库存路径，需要考虑磁盘空间storage: ./storage web: # 自定义web项，即浏览器访问页面 # web interface is disabled by default in 0.x, will be enabled soon in 1.x # when all its issues will be fixed # # set this to `true` if you want to experiment with web ui now; # this has a lot of issues, e.g. no auth yet, so use at your own risk #enable: true title: linjiad # logo: logo.png # template: custom.hbsauth: htpasswd: # 添加用户（npm adduser）后自动创建，保存用户信息，可以初始化用户 file: ./htpasswd # Maximum amount of users allowed to register, defaults to \"+inf\". # You can set this to -1 to disable registration. #max_users: 1000 设置为-1不能npm adduser# a list of other known repositories we can talk to # 可以配置多个上游地址，后面packages中的proxy指定用哪个uplinks: npmjs: url: https://registry.npmjs.org/ # amount of time to wait for repository to respond # before giving up and use the local cached copy #timeout: 30s # 请求上游地址超时时间 # maximum time in which data is considered up to date # # default is 2 minutes, so server won't request the same data from # uplink if a similar request was made less than 2 minutes ago #maxage: 2m # 包过期时间 # if two subsequent requests fail, no further requests will be sent to # this uplink for five minutes #max_fails: 2 # 容许依赖请求最大失败数 #fail_timeout: 5m # 依赖请求超时时间 # 包的权限管理，$all为所有人，$authenticated为通过验证人packages: '@*/*': # 跟package.json中的name属性进行匹配 # scoped packages access: $all publish: $authenticated '*': # allow all users (including non-authenticated users) to read and # publish all packages # # you can specify usernames/groupnames (depending on your auth plugin) # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\" access: $all # allow all known users to publish packages # (anyone can register by default, remember?) publish: $authenticated # if package is not available locally, proxy requests to 'npmjs' registry proxy: npmjs# log settingslogs: - &#123;type: stdout, format: pretty, level: http&#125; #- &#123;type: file, path: sinopia.log, level: info&#125;# 设置监听地址，0.0.0.0匹配本机地址listen: 0.0.0.0:4873 这时候可以访问以下看看如图所示 1.3 用pm2管理项目为了一直启动需要安装pm2对项目进行管理用pm2启动sinopia pm2 start sinopia 设置开机启动 pm2 startup ubuntu # 或centos，看具体环境 保存设置 pm2 save 客户端操作通过以上步骤服务器端基本配置完毕，下面我们修改客户端来实现从我们自己的服务器下载包在客户端下载nrmnrm是个方便的npm源管理工具，来做快速registry切换，当然你也可以不用下载，直接修改本地的npm下载路径即可 npm install -g nrm 查看目前的路径 nrm ls 如图所示加入新创建的私有库地址 nrm add xgnpm http://{ip}:{port}/ 切换下载地址为私有库地址 nrm use xgnpm 然后我们可以实验一下随变下载一个包就会发现如果私有库没有这个包就会去npm下载并存在/root/.config/sinopia/sinopia里面如果有就会直接下载 备注：添加用户可以再客户端通过命令： npm adduser 来添加 3导言由于上一个服务器搭建成功后发现无法下载@的包，简直是坑有木有，上网上收集了一些资料发现原来sinopia早已不更新了，大家可以看我的报错如下：简直坑有木有 4安装verdaccio基于上一个服务器安装这里就不需要安装node等基础环境了，直接安装1安装verdaccio就可以 npm install -g verdaccio –unsafe-perm 配置软连接 ln -s /usr/download/nodejs/lib/node_modules/verdaccio/bin/verdaccio /usr/local/bin/ 这里可以查看一下我们都软连接了哪些命令 cd /user/local/binls 5修改verdaccio的配置和sinopia一样你在哪个目录运行，它的就会在对应的目录下创建自己的文件。目录下默认有两个文件：config.yaml和storage，htpasswd 是添加用户之后自动创建的;这里我和sinopia放在了一起。配置啥的都参照sinopia这里就不多说了之后用pm2启动就可以了。"},{"title":"商业模式新生代","date":"2018-05-26T01:57:25.000Z","path":"2018/05/26/商业模式新生代/","text":"这本书讲述了商业模式，好像是废话，不多说了看看本书的结构吧 1商业模式画布1.1商业模式定义商业模式描述了企业如何创造价值、传递价值和获取价值的基本原理。本书提供一个了商业模式的框架，它使得我们能够描述和思组织、竞争对手和其他企业的商业模式。该框架提供了一种描述商业模式的共同语言，有了它方便我们分析其他企业的商业模式并寻找商业上的创新。通过9个基本构造块就可以很好地描述并定义商业模式，它们可以展示出企业创造收入的逻辑。 1.29基本构造块CS客户细分CS客户细分，Customer Segments，企业或机构所服务的一个或多个客户分类群体。为了更好地满足客户，企业可能把客户分成不同的细分区隔，每个细分区隔中的客户具有共同的需求、共同的行为和其他共同的属性。企业必须做出合理决议，到底该服务哪些客户细分群体，该忽略哪些客户细分群体。然后凭借对特定客户群体需求的深刻理解，设计相应的商业模式。 VP价值主张VP价值主张，Value Propositions，通过价值主张来解决客户难题和满足客户需求。价值主张构造块用来描绘为特定客户细分创造价值的系列产品和服务，它是用户选择你的原因，是公司提供给用户的利益集合。 CH渠道通路CH渠道通路，Channels，通过沟通、分销和销售渠道向客户传递价值主张。作用：提升公司产品和服务在客户中的认知:帮助客户评估公司价值主张:协助客户购买特定产品和服务:向客户传递价值主张:提供售后客户支持。 CR客户关系CR客户关系，Customer Relationships，在每一个客户细分市场建立和维系客户关系。动机：客户获取；客户维系；提升销量。 R$收入来源R$收入来源，Revenue Streams，收入来源产生于成功提供给客户的价值主张。用于描述公司从每个用户群体获取的现金收入，需要从创收中扣除成本。 KR核心资源KR核心资源，Key Resources，核心资源是用来描绘商业模式有效运转所必须得最重要因素。如：实体资产；知识资产；人力资源；金融资产等。 KA关键业务KA关键业务，Key Activities，通过执行一些关键业务活动，运转商业模式。用来描绘为了确保其商业模式可行，企业必须做的最重要的事情。如：制造产品；问题解决；平台/网络。 KP重要合作KP重要合作，Key Partnerships，有些业务要外包，而另外一些资源需要从企业外部获得。用来描述让商业模式有效运作所需的供应商与合作伙伴的网络。 C$成本结构C$成本结构，Cost Structure，商业模式上述要素所引发的成本构成。成本结构特点：固定成本；可变成本；规模经济；范围经济。 2 式样本书说明了以下几种式样 2.1 非绑定式商业模式有三种不同的基本业务类型:客户关系型业务、产品创新型业务和基础设施型业务。每种类型都包含不同的经济驱动因素、竞争驱动因素和文化驱动因素。这三种类型可能同时存在于一家公司里，但是理论上这三种业务“分离”成独立的实体，以便避免冲突或不利的权衡妥协。 2.2 长尾式商业模式长尾式商业模式的核心是多样少量:他们关注于为利基市场提供大量产品，每种产品相对而言卖得都少。利基产品销售总额可以与凭借少量畅销产品产生绝大多数销售额的传统模式相媲美。.长尾模式需要低库存成本和强大的平台，并使得利基产品对于兴趣买家来说容易获得。 2.3 多边平台式商业模式多边平台将两个或者更多有明显区别但又相互依赖的客户群体集合在一起。只有相关客户群体同时存在的时候，这样的平台才具有价值。多边平台通过促进各方客户群体之间的互动来创造价值。多边平台需要提升其价值，直到它达到可以吸引更多用户的程度，这种现象被称为网络效应。比如：信用卡连接了商家和持卡人;计算机操作系统连接了硬件生产商、应用开发商和用户:报纸连接了读者和广告主;家用视频游戏机连接了游戏开发商和游戏玩家。这里的关键是多边平台必须能同时吸引和服务所有的客户群体并以此来创造价值。多边平台对于某个特定用户群体的价值本质上依赖于这个平台“其他边”的用户数量。如果有足够多的游戏，一款家用游戏机平台就能吸引足够多的玩家。另一方面，如果有足够的游戏玩家已经在玩游戏了，游戏开发商也会为新的视频游戏机开发(更多的)游戏二所以多边平台经常会面临着一个“先有鸡还是先有蛋”左右为难的困境。解决这个问题的方法是针对一个群体。尽管多边平台的运营商最主要的成本是运营费用，但是他们经常会通过为一个群体提供低价甚至免费的服务来吸引他们，并依靠这个群体来吸引与之相对的另一个群体。多边平台的运营商所面临的困难是选择哪个群体，以及以什么价格来吸引他们。 2.4 免费式商业模式在免费式商业模式中，至少有一个庞大的客户细分群体可以享受持续的免费服务。免费服务可以来自多种模式。通过该商业模式的其他部分或其他客户细分群体，给非付费客户细分群体提供财务支持。 免费广告：多变平台的式样基于广告的免费商业模式是多边平台的一个表现形式。平台的一边被设计成以免费的内容、产品或服务来吸引用户，平台的另一边通过销售广告位来产生收入。 费增收商业模式:基础免费，增值收费免费增收模式中有大量基础用户受益于没有任何附加条件的免费产品或服务。大部分免费用户永远不会变成付费客户:只有一小部分，通常不超过所有用户的10%的用户会订阅收费的增值服务。这一小部分付费用户群体所支付的费用将用来补贴免费用户。只有在服务额外免费用户的边际成本极低的时候这种模式才成为可能。在免费增收模式中，关键的指标是为单位用户提供免费服务的成本和免费用户变成付费用户的转化率。 开源:变形的免费增收模式例举RedHat的案例，我理解的是：类似短信服务平台从运营商那里购买短信通道，然后租赁给多个企业使用赚取服务费，因为没有企业愿意承担直接从运营商购买短信通道的高额费用。 保险模式:颠倒的免费增收在免费增收模式中，少量为高级服务付费的客户补贴大量非付费客户。而保险模式则相反，在保险模式中，大量用户定期支付小额费用，来保护自己预防那些一旦发生在财务上就是毁灭性的小概率事件。简而言之，大量付费客户补贴有实际需求的少量客户，而且付费客户可以在任何时间成为受益客户群中的一员(即获赔客户)。 诱钓模式诱钓指的是通过廉价的、有吸引力的甚至是免费的初始产品或服务，来促进相关产品或服务未来的重复购买的商业模式式样。这种模式也称为亏损特价品或剃刀与刀片模式。亏损特价品指的是最初补贴甚至亏本提供，目的是从客户后续购买产生利润的产品或服务。 剃刀与刀片用来描述使用最初产品或服务引诱客户而从后续销售中赚取收入的普遍想法。移动通信行就是个好案例，移动网络运营商提供绑定服务订阅的免费手机已经是标准的做法了。运营商起初赔钱免费赠送手机，但他们很容易通过后续的月服务费弥补损失。运营商以免费产品提供瞬间愉悦，随后产生经常性收入。 1904年，金·吉列将第一款可替换刀片剃须刀推向市场，并以极低的折扣销售刀架，甚至作为其他产品的赠品来销售，以此创造一次性刀片的需求。这种模式的关键是找到便宜甚至免费的初始产品和后续重复消费产品之间的紧密联系。控制这种“锁定”关系是成功的关键。通过专利限制，激烈保证了竞争对手无法为吉列刀架提供更便宜的刀片。剃须刀是世界上专利保护最完善的消费产品，有超过1000种专利/低价打印机，高价墨盒/最后我们来看一下这章脑图 2.5 开放式商业模式开放式商业模式可以用于那些通过与外部伙伴系统性合作，来创造和捕捉价值的企业。这种模式可以是“由外到内”，将外部的创意引入公司内部，也可以是“由内到外”，将企业内部闲置的创意和资产提供给外部伙伴。 3 设计 3.1 客户洞察基于客户洞察建立商业模式。我们要从客户的角度来看待商业模式，这可以让我们找到全新的机会。这并不意味着全按照客户的思维来设计商业模式，但是在评估商业模式的时候需要把客户的思维融入进来。创新的成功需要依靠对客户的深人理解，包括环境、日常事务、客户关心的焦点及愿望。采用客户视角是整个商业模式设计过程的指导原则，应该让客户视角来指引我们关于价值主张、渠道通路、客户关系和收入来源的选择。 真正的挑战在于建立对客户的彻底理解，并基于这种理解进行商业模式设计的选择。在产品和服务设计领域，许多领先企业都与社会学家合作，加深对客户的理解。创新的挑战是建立在对客户的深刻理解上，而不是简单的问他们需要什么。 另一个挑战在于要知道该听取哪些客户和忽略哪些客户的意见。应避免过于聚焦于现有客户细分群体，而应该盯着新的和为满足的客户细分群体。许多商业模式创新的成功，正是因为它们满足了新客户未得到满足的需求。 移情图（empathy map）首先找出客户细分群体，并选择一个开始客户描述分析。先给这个客户一个名字和一些人口统计特征，诸如收入、婚姻情况等。然后询问和回答以下六个问题，在活动挂图或白板上描绘你的新命名的客户。我们的目标是建立一种客户的视角，来持续质疑你的商业模式中的各种假设。 3.2 创意构思需要产生大量商业模式创意，并筛选出最好的创意生成全新商业模式创意。设计新的商业模式需要产生大量商业模式创意，并筛选出最好的创意，这个收集和筛选的过程叫做创意构思。设计新的商业模式时，面对的挑战是忽略现状和暂停关注运营的问题，这样我们才能得到真正的全新创意。 创意构思的两个阶段：创意生成，这个阶段重视数量。创意合成，讨论所有的创意，加以组合，并缩减到少量可行的可选方案。这些方案不一定要代表颠覆性的商业模式，也许只是把你现有的商业模式略做扩展。 商业模式创新的多个集中点我们可以把创新区分为4类不同集中点的商业模式创新，这4个集中点每一个都可以成为主要商业模式变化的起点。有时，商业模式可以引发自多个集中点。 资源驱动型创新起源于一个组织现有的基础设施，抑或合作关系拓展，抑或转变现有商业模式。 产品/服务驱动型创新是以建立新的价值主张的方式来影响其他商业模式构造块。 客户驱动型创新是基于客户需求、降低获取成本或提高便利性的。就像所有从单一集中点所引发的创新一样，来自客户驱动的创新同样可以影响商业模式的构造块。 财务驱动创新是由收入来源、定价机制或成本结构来驱动的，同样影响商业模式的其他构造块。 多中心驱动创新是由多个集中点驱动的，并会显著影响商业模式的其他多个构造块。 3.3 可视思考可视思考的价值。对于商业模式的相关工作来说，可视思考是必不可少的。我们所谓的可视思考，是指使用诸如图片、草图、图表和便利贴等视觉化工具来构建和讨论事情。因为商业模式是由各种构造块及其相互关系所组成的复杂概念，不把它描绘出来将很难真正理解一个模式。 可视化的商业模式画布的好处视觉化的语法。为勾画商业模式所需要的信息提供了视觉和文字指导，因为它会告诉你把哪些信息放入商业模式的哪个部分。 抓住大局。通过描绘出商业模式画布上的所有元素，可以直观的展示出商业模式大局。 查看关系。商业画布可以清晰的表达出各个商业元素之间的关系。 收集参考点。可以把心理得假设贴出来变成明确的信息作为参考。 共同的语言。提供了词汇表和语法帮助人们更好的理解对方，提高凝聚力。 共同的埋解。不同部门员工缺乏对商业模式全貌的认识，商业画布能让所有人快速理解商业模式。 灵感触发器。商业画布中的创意会引发更多创意。 演示。帮助你彻底思考修改某个商业模式元素后所带来的系统性影响。 内/外部推销。把创意和计划清晰的让内/外部人员理解。 3.4 故事讲述讲故事的目的是要把商业模式以形象具体的呈现出来，可以从不同的视角塑造出不同的人物形象，比如下面两种视角： 公司视角,让员工成为故事的主人公，因为员工频繁地关注着客户的烦恼，而新的模式就可以解决这些烦恼。在这样的故事中，员工体现的是商业模式的内部运作机制、为推行新的模式提供了依据。 客户视角，客户道出困扰他的烦恼和他必须解决的问题。然后讲述你们公司是如何帮他创造价值的。在故事中，她描述了她得到了什么样的产品和服务，这些产品和服务是如何解决他的问题的，以及作为一个消费者，他所愿意掏钱的产品和服务是什么样的。 3.5 情景推测作用：通过细化设计环境，帮助我们熟悉商业模式的设计流程基于情景的商业模式设计。情景推测吧抽象的概念变成具体的模型。下面是两种情景推测： 客户情景推测，客户是如何使用产品和服务的，什么类型的客户在使用它们，客户的顾虑、愿望和目的分别是什么。这种建立在客户洞察之上的情景推测更进一步，把对客户的了解融入一组独特、具体的图像。通过描述特定的场景，关于客户的情景推测就能把客户洞察具体形象地表现出来。 未来情景推测，说白了就是臆测未来，假设未来会发生何种变化，然后针对每一种变化设计并检验商业模式。此方法以商业创新为目的，帮助公司更好的应对未来发展。 4 战略 4.1 商业模式环境商业模式是在特定的环境中进行设计和执行的。建议把商业环境大体上映像成四块主要领域范畴： 1市场影响因素市场问题。从客户和提供给客户的产品或服务的视角发现驱动和改变市场的关键因索。 市场细分。发现主要的细分市场，描述它们的吸引力，寻找新的细分市场。 需要和需求。罗列出市场需求，分析市场需求目前的服务水平。 转换成本。描述与客户投靠竟争对手行为相关的因素。 收益吸引力。寻找出与收益吸引力和定价能力相关的因素。 2行业影响因素竞争对手。发现当前竞争对手和它们的相对优势。 行业新入者。发现新的崛起的行业对手，判断它们是否利用不同于你的商业模式与你竟争。 替代性产品和服务。描述你公司的产品和服务潜在替代品，包括其他市场和行业的产品和服务。 供应商和其他价值链参与者。在你公司所在的市场中，描述出目前关键的价值链参与者，并发现新崛起的参与者。 利益相关者。确认哪些参与者可能会影响你的公司和商业模式。 3关键趋势技术趋势。发现能威胁、改变或改良你的公司的商业模式的技术趋势。 监管法规趋势。描述影响你的商业模式的法规及其变化趋势。 社会和文化趋势。发现可能会，影响你的商业摸式的主要社会趋势。 社会经济趋势。概括与你的商业模式相关的主要社会经济趋势。 4宏观经济影响力全球市场情况。从宏观的经济视角总结全球市场目前的整体状况。 资本市场。描绘出与你的资本需求密切相关的资本市场状况。 商品和其他资源。重点关注你的商业模式中所需资源的当前价格及其未来趋势。 经济基础。描绘你的业务运营环境中的经济基础。 4.2 评估商业模式如同每年做身体检查一样，定期评估商业模式是一种重要的管理工具，它可以评估出组织在行业内的“健康”程度，并适时地做出一些相应的调整。这种健康检查可以成为商业模式不断改进优化的基础。商业模式视角下的蓝海战略《蓝海战略》这本书可以看看。管理多个商业模式 商业评估工具SWOT(优势，劣势，威胁，机会) 4.3 蓝海战略蓝海战略：通过改变现有的商业模式来区分与竞争对手的模式，从而创造出新的行业 去除：那些被行业认为理所应当的存在应该被去除 降低：哪种因素应该被降低到标准之下 提升：哪种因素应该被提高到标准之上 创造：哪种行业中没有的因素应该被创造出来 5 流程5.1 创新四大目标商业模式创新的目标：满足市场，满足被忽视的市场需求。 投放市场，把新技术、产品和服务推向市场。 改善市场，通过更好的商业模式来改进、颠覆或变革现有的市场。 创造市场，建立全新的市场。 5.2 五大阶段动员为一个成功的商业模式设计项目做好准备工作。 活动：确定项目目标、测试初步商业想法、规划、组件设计团队。 关键：合适的队友、经验和知识。 风险：高估了初始想法的价值。 理解研究和分析商业模式所需要的元素。 活动：环境分析、研究潜在客户、采访行业专家、研究前人做法（失败案例）、收集想法。 关键：对潜在目标市场的深入理解、超越传统目标市场定义的界限。 风险：研究过度（研究和目标脱节）、收到预先想法的影响，研究结果不客观。 设计构建和测试可行的商业模式可选方案，并挑选最佳的方案。 活动：头脑风暴、原型制作、测试、选择。 关键：与不同部门的员工一起设计、透过现状看本质的能力、投入时间，探索多种商业模式。 风险：低估或打压大胆想法、过快的钟情于某个想法。 实施在实际环境中实施商业模式原型。 活动：交流和参与、执行。 关键：最佳项目管理、快速调整商业模式的能力和意愿、平衡好旧模式和新模式。 风险：积极性降低、减弱。 管理结合市场反馈来调整和修改商业模式。 活动：分析环境、持续的评估你的商业模式、换一个角度思考你的商业模式、调整商业模式，配合公司整体战略、处理模式间的协同效应和冲突问题。 关键：目光长远、积极主动、商业模式的管理。 风险：成为成功的牺牲品，满足于现状而未能及时作出调整。 最后贴一个脑图地址吧"},{"title":"weex","date":"2018-05-24T01:43:24.000Z","path":"2018/05/24/weex/","text":"0.安装0.1 安装nodejs这个不多说了不会的面壁吧。 0.2 安装weex-toolkit这个是个坑啊，官方给出的安装是 npm install weex-toolkit -g 不过这个安装可能会各种失败，失败之后再安装就无法安装了。即使再用淘宝镜像。那怎么办呢？首先我们需要卸载一下weex-toolkit npm uninstall weex-toolkit -g 其次我们需要去电脑中删除些文件还有这个也需要删除删除了这些，我们再安装，注意要用管理员运行cmd这次我们用淘宝镜像，没有cnpm自己安装下就可以了 cnpm install -g weex-toolkit 安装之后查看版本 npm uninstall weex-toolkit -g 出现版本号既可以了 0.3 安装java及配置0.4 安装git0.5 安装webpack0.6 安装android-studio安装android-studio这儿啦下一步下一步就好啦现在安装android-studio不带android-sdk，所以需要自己装之后还会安装一起android包，这时候需要翻墙，要访问谷歌这里强烈建议用国内镜像如图所示 大连东软信息学院镜像服务器地址:http://mirrors.neusoft.edu.cn 端口：80 接着点击close，关闭对话框，再重新启动SDK Manager就行啦。经过漫长的下载安装过程后，我们可以看到，之前选中安装的项目后面的状态都由之前的“Not installed”变为了如今的“Installed”，这就表示我们已经安装成功了！之后再配置android-sdk打开环境变量路径：控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量。新建：ANDROID_HOME 并把我们刚才赋值的sdk路径作为值插入添加path值，与配置java相同 ;%ANDROID_SDK_HOME%\\platform-tools; 保证系统能找到platform-tools下的adb.exe即可输入adb查看，出现下面情况即配置成功。接着刚才安装android-studio由于本机没有安装过Android Studio，因此这里也没有可导入的配置信息。点击OK。点击Setup Proxy。按上图设置代理。点击OK。点击Next。安装类型选择为”Custom”，并点击Next。将UI主题选择为Darcula(此风格看起来更加极客)。点击Next。选择之前安装Android Studio的路径，可以看到看下上图所述提示。点击Next。点击FinishAndroid SDK已经是最新。点击Finish。点击”Start a new Android Studio project”即可开始第一个Android程序的开发。 1.开启weex之旅吧1.1建立weex项目目录建立weex项目名称为helloWeex weex create helloWeex 建立时和vue一样，输入项目名称是否为helloWeex项目描述项目作者是否用eslint，一个js语法标准是否测试之后项目就建好了,目录结构如下添加Android应用支持 weex platform add android 如果你要支持IOS平台的话，你还要添加IOS应用，但是抱歉的是我没有苹果电脑，所以这里就不演示苹果的添加了。 1.2在Android Studio里运行weex"},{"title":"Swagger2","date":"2018-05-21T09:50:05.000Z","path":"2018/05/21/Swagger2/","text":"Swagger2主要解决接口文档，有了它妈妈再也不用担心接口太多不方便管理了，只需要在写代码时候简单加入些注解即可，方便简单。 0.安装pom文件直接在pom中用Maven下载jar包12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 1.创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.dataacquisition;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author colin * @version 1.0.0 * @date 17/10/24 下午12:02. */@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; ParameterBuilder parameterBuilder = new ParameterBuilder(); List&lt;Parameter&gt; parameters = new ArrayList&lt;Parameter&gt;(); parameterBuilder.name(\"Content-Type\") .description(\"header\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false).build(); parameters.add(parameterBuilder.build()); parameterBuilder.name(\"Accept\") .description(\"header\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false).build(); parameters.add(parameterBuilder.build()); //上面是设置header return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 选择那些路径和api会生成document .apis(RequestHandlerSelectors.basePackage(\"com.iss.rest\"))// 对所有api进行监控// .apis(RequestHandlerSelectors.any())// 对所有路径进行监控 .paths(PathSelectors.any()) .build() .globalOperationParameters(parameters) .apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"经济运行大数据API\") .description(\"经济大数据\") .termsOfServiceUrl(\"www.baidu.com\") .contact(\"colin\") .version(\"1.0\") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。看一下这个目录结构这里还要说明一下引包 PathSelectors import springfox.documentation.builders.PathSelectors; 1.添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容GET接口 对于传统参数为？的123456789101112131415161718192021222324252627@ApiOperation(value = \"上传Excel\", notes = \"上传Excel并存入数据库\", code = 200, produces = \"application/json\")@ApiImplicitParams(&#123;@ApiImplicitParam(name = \"userId\",value = \"用户ID\",required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"filepath\", value = \"上传文件路径地址用“/”\",paramType = \"query\", required = true, dataType = \"String\"), @ApiImplicitParam( name = \"type\", value = \"上传文件类型\", required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"productId\", value = \"上传文件productId\", required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"version\", value = \"上传文件版本\", required = false,paramType = \"query\", dataType = \"String\")&#125;)@RequestMapping(value = \"/uploadExcel\", method = RequestMethod.GET)public String uploadExcel(HttpServletRequest request) &#123; String filepath = WebUtils.findParameterValue(request, \"filepath\"); String productId = WebUtils.findParameterValue(request, \"productId\"); if(StringUtils.isBlank(filepath)||!new File(filepath).exists())&#123; return \"请输入正确文件路径\"; &#125; if(!configProductService.selectProductByProductId(productId))&#123; return \"productId不存在，请输入正确的productId\"; &#125; String userId = WebUtils.findParameterValue(request, \"userId\"); String type = WebUtils.findParameterValue(request, \"type\"); if(StringUtils.isBlank(type))&#123; return \"请输入上传Excel的种类（type=）\"; &#125; String version = WebUtils.findParameterValue(request, \"version\"); String result = uploadExcelService.uploadExcel(filepath,userId,type,version,productId); String result2 = uploadExcelService.upload(filepath); return result;&#125; GET接口 对于参数为/的123456789101112131415161718192021222324252627282930313233@ApiOperation(value = \"获取所有新闻\", notes = \"获取所有新闻\", code = 200, produces = \"application/json\") @ApiImplicitParams(&#123;@ApiImplicitParam(name = \"infoType\",value = \"行业动态等类别\",required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"type\", value = \"所属行业\",paramType = \"query\", required = true, dataType = \"String\"), &#125;) @RequestMapping(value = \"/queryAllNewsNew/&#123;infoType&#125;/&#123;type&#125;/&#123;startTime&#125;/&#123;endTime&#125;/&#123;region&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;\", method = RequestMethod.GET, produces = &#123;\"application/json\"&#125;, consumes = &#123;\"application/json\"&#125;) public Result queryAllNewsNew(@PathVariable(\"infoType\") String infoType, @PathVariable(\"type\") String type, @PathVariable(\"startTime\") String startTime, @PathVariable(\"endTime\") String endTime, @PathVariable(\"region\") String region, @PathVariable(\"pageNum\") String pageNum, @PathVariable(\"pageSize\") String pageSize) &#123; if (StringUtils.isBlank(pageNum)) &#123; pageNum = \"1\"; &#125; if (StringUtils.isBlank(pageSize)) &#123; pageSize = \"10\"; &#125; ResultEducationInfo resultEducationInfo = new ResultEducationInfo(); resultEducationInfo.setRegion(region); resultEducationInfo.setCityName(region); resultEducationInfo.setInfoType(infoType); resultEducationInfo.setCrawlType(type);// resultEducationInfo.setTime(time); resultEducationInfo.setStartTime(startTime); resultEducationInfo.setEndTime(endTime); resultEducationInfo.setPageNum(pageNum); resultEducationInfo.setPageSize(pageSize); Result result = jsonSearchService.queryAllNews(resultEducationInfo); return result; //Result.success(result); &#125; POST接口1234567891011@ApiOperation(value = \"解析Excel\", notes = \"解析Excel\", code = 200, produces = \"application/json\")@ApiImplicitParam(name = \"filepath\", value = \"上传文件路径地址用“/”\",paramType = \"query\", required = true, dataType = \"String\")@RequestMapping(value = \"/analysisExcel\", method = RequestMethod.POST)public Map analysisExcel(HttpServletRequest request) &#123; String filepath = WebUtils.findParameterValue(request, \"filepath\"); if(StringUtils.isBlank(filepath)||!new File(filepath).exists())&#123; return null; &#125; Map result = uploadExcelService.analysisExcel(filepath); return result;&#125; 结果如图所示"},{"title":"jQuery生成二维码","date":"2018-05-18T08:59:40.000Z","path":"2018/05/18/jQuery生成二维码/","text":"还是扫描二维码登录的需求，既然和二维码相关肯定需要实现二维码生成啦！ 0安装生成二维码的包不止一种，这里一个坑 qrcode 包，他也可以生成二维码，但是很难设置二维码大小，颜色等，强烈不建议安装这个。我已经掉坑里过。那么推荐使用jquery.qrcode。 npm install jquery.qrcode -s 这里前提是需要安装jquery并且在webpack中配好，先说一下代码，以后会详细说明123456plugins:[ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\" &#125;), ] 1使用之后引用jquery.qrcode1require('jquery.qrcode') 在之后在Html中定义div容器1&lt;div id=\"query\"&gt;&lt;/div&gt; 这里可以不用设置div大小，因为可以再js中设置二维码大小 再之后是js部分 1234567891011//动态生成二维码 $(\"#query\").qrcode(&#123; render: \"canvas\", // 渲染方式有table方式和canvas方式 width: 256, //默认宽度 height: 256, //默认高度 text: encodeURI(\"http://www.cnblogs.com/HtmlCss3/\"）, //二维码内容 typeNumber: -1, //计算模式一般默认为-1 correctLevel: 2, //二维码纠错级别 background: \"#ffffff\", //背景颜色 foreground: \"#000000\" //二维码颜色&#125;); 说明下encodeURI是为了防止中文乱码。应该不会怎么用上。至于如果想在二维码中间添加图片，目前不支持添加图片，不过我们可以自己把图片移到中间位置"},{"title":"websocket+Springboot","date":"2018-05-18T06:54:16.000Z","path":"2018/05/18/websocket/","text":"今天要做一个手机扫描登录，功能拆分，需要websocket推送信息到页面，不废话了直接开始吧。 0.导言0.1什么是websocket它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 0.2准备都需要什么准备呢？毫无疑问需要客户端（浏览器），服务端（后台），这里后台我们用的是Springboot。 1.后台Springboot1.1引包在pom中引用webpack包123456&lt;!-- 操作websoket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2注入ServerEndpointExporter使用springboot内置tomcat进行部署的话，在编写websocket具体实现类之前，要注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint。1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;/** * Created by linjiad on 2018/5/18. */@Configurationpublic class WebSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 1.3写自己的实现类直接先看代码吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import net.sf.ehcache.util.concurrent.ConcurrentHashMap;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.Map;/** * Created by linjiad on 2018/5/18. */@ServerEndpoint(value = \"/websocket\")@Componentpublic class MyWebSocket &#123; //统计在线人数 private static int onlineCount = 0; //用本地线程保存session private static ThreadLocal&lt;Session&gt; sessions = new ThreadLocal&lt;Session&gt;(); //保存所有连接上的session private static Map&lt;String, Session&gt; sessionMap = new ConcurrentHashMap&lt;String, Session&gt;(); public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; onlineCount--; &#125; //连接 @OnOpen public void onOpen(Session session) &#123; sessions.set(session); addOnlineCount(); sessionMap.put(session.getId(), session); System.out.println(\"【\" + session.getId() + \"】连接上服务器======当前在线人数【\" + getOnlineCount() + \"】\"); //连接上后给客户端一个消息 sendMsg(session, \"恭喜你连接服务器成功！\"+session.getId()); &#125; //关闭 @OnClose public void onClose(Session session) &#123; subOnlineCount(); sessionMap.remove(session.getId()); System.out.println(\"【\" + session.getId() + \"】退出了连接======当前在线人数【\" + getOnlineCount() + \"】\"); &#125; //接收消息 客户端发送过来的消息 @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(\"【\" + session.getId() + \"】客户端的发送消息======内容【\" + message + \"】\"); String[] split = message.split(\",\"); String sessionId = split[0]; Session ss = sessionMap.get(sessionId); if (ss != null) &#123; String msgTo = \"【\" + session.getId() + \"】发送给【您】的消息:\\n【\" + split[1] + \"】\"; String msgMe = \"【我】发送消息给【\"+ss.getId()+\"】:\\n\"+split[1]; sendMsg(ss, msgTo); sendMsg(session,msgMe); &#125;else &#123; for (Session s : sessionMap.values()) &#123; if (!s.getId().equals(session.getId())) &#123; sendMsg(s, \"【\" + session.getId() + \"】发送给【您】的广播消息:\\n【\" + message + \"】\"); &#125; else &#123; sendMsg(session,\"【我】发送广播消息给大家\\n\"+message); &#125; &#125; &#125; &#125; //异常 @OnError public void onError(Session session, Throwable throwable) &#123; System.out.println(\"发生异常!\"); throwable.printStackTrace(); &#125; //统一的发送消息方法 public synchronized void sendMsg(Session session, String msg) &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这段代码里面注释都很清晰了，不多说了，重点是在 onMessage 方法中。后端就这么多久搞定了，很简单，把后端项目跑起来等待前端信息就可以了 2.前端2.1 页面HTMLHTML就很简单了，一个div,一个输入框，一个按钮就搞定1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jspang webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = \"message\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"ceshi\"&gt; &lt;button id=\"a\"&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 别问我为啥没引用js，因为我用的是webpack这个之后再讲。 2.2 js实现这个地方我分成了两部分，用import形式引入websocket部分先看index.js123456import websocket_config from './js/websocket_config.js';let websocket = new websocket_config.Websocket();$(\"#a\").on('click', function() &#123; let message = document.getElementById('ceshi').value; websocket.send(message); &#125;) 这段代码就是点击按钮把’ceshi’信息传给后台另一个websocket_config，我是把websocket部分封装进来12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Websocket&#123; constructor(url=\"ws://localhost:11000/websocket\") &#123; let self = this; self.url=url; let websocket = null; //判断当前浏览器是否支持WebSocket if('WebSocket' in window)&#123; self.websocket = new WebSocket(this.url); &#125; else&#123; alert(\"您当前浏览器不支持websocket\") &#125; //连接发生错误的回调方法 self.websocket.onerror = function()&#123; self.setMessageInnerHTML(\"error\"); &#125;; //连接成功建立的回调方法 self.websocket.onopen = function(event)&#123; self.setMessageInnerHTML(\"open\"); &#125; //接收到消息的回调方法 self.websocket.onmessage = function(event)&#123; console.log(event); self.setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 self.websocket.onclose = function()&#123; self.setMessageInnerHTML(\"close\"); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; self.websocket.close(); &#125; &#125; setMessageInnerHTML(innerHTML) &#123; document.getElementById('message').innerHTML += innerHTML + '&lt;br/&gt;'; &#125; closeWebSocket()&#123; this.websocket.close(); &#125; //发送消息 send(message)&#123; this.websocket.send(message); &#125;&#125;export default &#123;Websocket&#125;; 敲黑板划重点，这里有个坑，就是Class里面的this，前面我们这么写的 let self = this; 否则后面function里面this指向自己的function 3 看看具体效果吧直接输入信息会广播出去给所有人，如图所示所有人都会看到信息因为在后台代码12345678910111213141516171819202122232425262728293031//接收消息 客户端发送过来的消息 @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(\"【\" + session.getId() + \"】客户端的发送消息======内容【\" + message + \"】\"); String[] split = message.split(\",\"); String sessionId = split[0]; Session ss = sessionMap.get(sessionId); if (ss != null) &#123; String msgTo = \"【\" + session.getId() + \"】发送给【您】的消息:\\n【\" + split[1] + \"】\"; String msgMe = \"【我】发送消息给【\"+ss.getId()+\"】:\\n\"+split[1]; sendMsg(ss, msgTo); sendMsg(session,msgMe); &#125;else &#123; for (Session s : sessionMap.values()) &#123; if (!s.getId().equals(session.getId())) &#123; sendMsg(s, \"【\" + session.getId() + \"】发送给【您】的广播消息:\\n【\" + message + \"】\"); &#125; else &#123; sendMsg(session,\"【我】发送广播消息给大家\\n\"+message); &#125; &#125; &#125; &#125; //统一的发送消息方法 public synchronized void sendMsg(Session session, String msg) &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 如果，前面没有id则会循环sessionMap发给所有人如果，前面有id则单独发给一个人 session.getBasicRemote().sendText(msg);谁获取了什么消息"},{"title":"css3-grid网格化布局","date":"2018-05-17T08:32:49.000Z","path":"2018/05/17/css3-grid网格化布局/","text":"1.第一个 Grid 布局CSS Grid 布局由两个核心组成部分是: wrapper（父元素）和 items（子元素）。下面是一个 wrapper 元素，内部包含6个 items ：HTML部分12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个 grid(网格)，只要简单地把其 display 属性设置为 grid 即可：123.wrapper &#123; display: grid;&#125; 仅仅是这样并没有什么用处结果如图所示： 2.Columns(列) 和 rows(行)为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用 grid-template-row 和 grid-template-column 属性。 12345.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; //设置三列（1-4条线） grid-template-rows: 50px 50px;//设置两行（1-3条线）&#125; 记住几条线是接下来需要用的这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）如果这样设置12345.wrapper &#123; display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;&#125; 结果就是这样注意这里评分宽度尽量用（可以自适应） grid-template-columns: repeat(6, 1fr); 页面宽度平均分成6份，每个占一份 3.放置 items(子元素)3.1行要定位和调整 items(子元素) 大小，我们将使用 grid-column 和 grid-row 属性来设置：1234.item1 &#123; grid-column-start: 1; grid-column-end: 4;&#125; 当然也可以这么写123.item1 &#123; grid-column: 1 / 4;&#125; item1 占据从第一条网格线开始，到第四条网格线结束换句话说，它将独立占据整行.结果如图所示：这是怎么回事呢？为啥是1,4呢，原因如图 3.2列同理。列也就不用多说了，直接看代码123456789101112.item1 &#123; grid-column-start: 1; grid-column-end: 3;&#125;.item3 &#123; grid-row-start: 2; grid-row-end: 4;&#125;.item4 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 结果如下：基本布局这些就够了 4.矩阵布局——grid-template-areas直接代码讲解吧123456789101112131415161718192021.item-1 &#123; grid-area: header;&#125;.item-2 &#123; grid-area: main;&#125;.item-3 &#123; grid-area: sidebar;&#125;.item-4 &#123; grid-area: footer;&#125; .wrapper &#123; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: &quot;header header header header&quot; &quot;main main . sidebar&quot; &quot;footer footer footer footer&quot;;&#125; 把每个div起一个别名： .item-a { grid-area: header;} 开始布局 grid-template-areas: “header header header header” “main main . sidebar” “footer footer footer footer”; 其中.代表空占位结果如图所示： 5指定网格线(grid lines)的大小属性这么设置1234.wrapper &#123; grid-column-gap: &lt;line-size&gt;; grid-row-gap: &lt;line-size&gt;;&#125; 具体事例123456.container &#123; grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-column-gap: 10px; grid-row-gap: 15px;&#125; 6 每个网格中的格式6.1整体设置 -justify-items123.container &#123; align-items: start | end | center | stretch;&#125; start：将内容对齐到网格区域(grid area)的顶部end：将内容对齐到网格区域的底部center：将内容对齐到网格区域的中间（垂直居中）stretch：填满网格区域高度（默认值）示例：123.container &#123; align-items: start;&#125; 示例：123.container &#123; align-items: end;&#125; 示例：123.container &#123; align-items: center;&#125; 示例：123.container &#123; align-items: stretch;&#125; 6.2单个设置 -justify-self规则和上面一样，这里就不多说了示例：123.item-a &#123; justify-self: start;&#125; 示例：123.item-a &#123; justify-self: end;&#125; 示例：123.item-a &#123; justify-self: center;&#125; 示例：123.item-a &#123; justify-self: stretch;&#125; 7.非自适应布局对齐方式7.1沿—X轴线有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像px这样的非灵活单位设置大小，在这种情况下，您可以设置网格容器内的网格的对齐方式start：将网格对齐到 网格容器(grid container) 的左边end：将网格对齐到 网格容器 的右边center：将网格对齐到 网格容器 的中间（水平居中）stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间space-evenly：在每个栅格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间示例：123.container &#123; justify-content: start;&#125; 123.container &#123; justify-content: end;&#125; 123.container &#123; justify-content: center;&#125; 123.container &#123; justify-content: stretch;&#125; 123.container &#123; justify-content: space-around;&#125; 123.container &#123; justify-content: space-between;&#125; 123.container &#123; justify-content: space-evenly;&#125; 7.2沿—Y轴线和x轴基本一样示例：123.container &#123; align-content: start;&#125; 123.container &#123; align-content: end;&#125; 123.container &#123; align-content: center;&#125; 123.container &#123; align-content: stretch;&#125; 123.container &#123; align-content: space-around;&#125; 123.container &#123; align-content: space-between;&#125; 123.container &#123; align-content: space-evenly;&#125; 总结常用的基本就这些了如果需要了解更多，这儿啦"},{"title":"echarts-字符云","date":"2018-05-17T02:31:25.000Z","path":"2018/05/17/echarts-字符云/","text":"首先要说下，从echarts2.0之后，字符云就被分离出来，需要独自安装 1.安装1.1安装其他安装不说了，单独说下需要安装echarts和echarts-wordcloud npm install echarts-wordcloud -s 1.2引用在总的js中123let echarts = require(&apos;echarts&apos;);window.echarts=echarts;require(&apos;echarts-wordcloud&apos;); 2.使用heml部分代码就不强调了，直接写js部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let colorlist = [&quot;#4ad2ff &quot;, &quot;#36ffb1&quot;, &quot;#23ff4f&quot;, &quot;#3dff27&quot;, &quot;#7aff1a&quot;, &quot;#bdff1c&quot;, &quot;#e2ff15&quot;, &quot;#fdff52&quot;]; let myChart = echarts.init(document.getElementById(&quot;portrait&quot;)); let option = &#123; tooltip: &#123;&#125;, series: [&#123; type: &apos;wordCloud&apos;, gridSize: 10, //sizeRange: [22, 50], //rotationRange: [0, 0], //shape: &apos;circle&apos;, textStyle: &#123; normal: &#123; color: function() &#123; return colorlist[parseInt(10*Math.random())]; &#125; &#125;, /*emphasis: &#123; shadowBlur: 10, shadowColor: &apos;#333&apos; &#125;*/ &#125;, data: [&#123; name: &apos;企业&apos;, value: 10000, &#125;, &#123; name: &apos;公务员&apos;, value: 6181 &#125;, &#123; name: &apos;2018&apos;, value: 4386 &#125;, &#123; name: &apos;上下游&apos;, value: 4055 &#125;, &#123; name: &apos;公司&apos;, value: 2467 &#125;, &#123; name: &apos;项目&apos;, value: 2244 &#125;, &#123; name: &apos;十二月份&apos;, value: 1898 &#125;, &#123; name: &apos;一批&apos;, value: 1484 &#125;, &#123; name: &apos;大连&apos;, value: 1112 &#125;, &#123; name: &apos;北京&apos;, value: 965 &#125;, &#123; name: &apos;全国&apos;, value: 847 &#125;, &#123; name: &apos;采购&apos;, value: 582 &#125;, &#123; name: &apos;考试&apos;, value: 555 &#125;, &#123; name: &apos;示范&apos;, value: 550 &#125;,] &#125;] &#125;; myChart.setOption(option) 一个简单的字符云就出来了，更多功能以后待更新"},{"title":"css3-文字特效和背景透明","date":"2018-05-16T02:18:35.000Z","path":"2018/05/16/css3-文字特效和背景透明/","text":"直接上图，需要用CSS3实现这样的效果 1.html部分html这里需要一个 标签包含 之后每组字都是自己的 之所以是div是需要给每组字限定大小。1234567891011&lt;ul&gt; &lt;li class = &quot;li_title&quot;&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;区域占有率&lt;/div&gt;&lt;div&gt;主营产品&lt;/div&gt;&lt;div&gt;来源&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; 2.CSS部分2.1 li背景这里的li分为两部分，标题部分和其他行，这里如果用less的话就非常方便，less以后会在less专题中说，这里还是用css1234567.li_title&#123; margin-left: -50px; //内边距向左50 height: 30px; //每行高30px list-style-type : none; //去掉li前面的· background-color: rgb(46,154,254,0.6); //设置背景颜色，并且透明度为0.6 border-radius:10px; //拐角度为10px&#125; 后面的行无非就是改个颜色12345678.li_list&#123; margin-left: -50px; height: 30px; margin-top: 15px; list-style-type : none; background-color: rgb(28,28,28,0.6); border-radius:10px;&#125; 2.2 文字特效这里的特效就是多余的文字变成…直接代码讲解吧12345678910ul div&#123; color : #FFFFFF; //文字颜色白色 font-size : 18px; //字体大小18px float:left; //文字靠左浮动 margin-left: 8%; //左边距为8%，也就是每个字之间的间距 width:110px; //规定div大小，也就是文字框大小（主要） white-space:nowrap; //规定文字不能换行（主要） overflow:hidden; //规定多余的文字隐藏（主要） text-overflow:ellipsis; //规定文字超出的话···（主要）&#125; 这些之后图片的效果就回显现 3.左侧按钮特效直接上图，需要用CSS3实现这样的效果要实现这个效果首先要在左面定义一个 3.1左侧div_html123456789&lt;div class = &quot;menu&quot;&gt; &lt;ul&gt; &lt;li value = &quot;reaches&quot;&gt;行业上下游&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;xiehui&quot;&gt;协会理事会&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;gongxu&quot;&gt;供需平台&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;shejiao&quot;&gt;社交平台&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;qita&quot;&gt;其他&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 3.2.左侧CSS样式首先是menu的样式123456.menu&#123; width: 13%; //定义宽度 height: 736px; //定义高度 float:left; //浮动到左侧 transform:skew(0deg,20deg); //敲黑板划重点，倾斜，两个参数，这里是沿着x轴向下倾斜20度&#125; 之后设定ul样式，这个样式没有什么好说的12345.menu ul &#123; float:left; margin-top: 25%; margin-left: -20%;&#125; 再之后设置li样式，划重点1234567891011121314.menu li &#123; width: 100%; //li宽度 height: 100px; //高度 margin-top: 5%; //内置上边距 color : #FFFFFF; //颜色（字体） font-size : 20px; //字体大小 border:1px solid #ffffff; //边界线粗细为1px。边界线颜色为白色 list-style-type : none; //不显示· float:left; //左浮动 display: flex; //（划重点）用flex布局，这样设置里面字居中 align-items:center; // 上下居中 justify-content: center;// 左右居中 cursor: pointer; //鼠标经过变成手指&#125; 未被选择的li需要一个透明的背景色，如同前面一样，直接上代码123.menu_select&#123; background-color: rgb(110,110,110,0.3);&#125; 3.3实现点击切换效果js循环ul的children，如果和点击的li相同则删除menu_select样式，否则添加menu_select样式123456789101112$(&quot;.menu li&quot;).on(&apos;click&apos;, function() &#123; for (let child of $(&quot;.menu ul&quot;).children()) &#123; if(child.innerHTML != this.innerHTML)&#123; $(child).addClass(&quot;menu_select&quot;); $(&quot;#&quot;+child.attributes.value.value).hide() &#125; else&#123; $(child).removeClass(&quot;menu_select&quot;); $(&quot;#&quot;+child.attributes.value.value).show() &#125; &#125; &#125;)"},{"title":"echarts_地图","date":"2018-05-16T01:43:31.000Z","path":"2018/05/16/echarts-地图/","text":"echarts构建数据可视化 1.安装1.1 安装nodejs构建webpack项目，需要安装nodejs，告别传统直接1&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 标签引用，nodejs安装和webpack构建这里先不说了，以后专门写webpack时候再说。nodejs前面也说过安装就不多说了。 1.2 安装echarts直接使用命令1npm install echarts -s 这里说明一下，有个坑，echarts地图显示存在版本冲突，所以可以@你的版本号避免这种冲突。 1.3 引用echarts在webpack构建的项目里，在index.js或者main.js，即页面直接引用的js引用echarts12let echarts = require('echarts');window.echarts=echarts; 这里说明一下，也可以用import，这两个区别在以后的nodejs中回去讲解。 2.地图实现2.1 html部分首先在html中需要有放地图的位置，并且有自己的id，这里必须给该 大小，否则echarts显示不出来12&lt;div id = &quot;map&quot; style=&quot;width:600px;height:500px;&quot;&gt;&lt;/div&gt; 2.2 js部分首先把地图对应的json传给echarts1echarts.registerMap(city, resultJson); 之后获取div1let myChart = echarts.init(document.getElementById(&quot;map&quot;)); 之后setoption12345678910111213141516171819202122232425262728293031323334353637383940414243myChart.setOption(&#123; tooltip: &#123;//配置鼠标方式显示提示样式 trigger: &apos;item&apos;, formatter: &apos;&#123;b&#125;:&#123;c&#125;&apos; &#125;, series : [&#123; type: &apos;map&apos;, //设置地图样式，未选中板块的样式和选中板块的样式 itemStyle: &#123; normal: &#123; areaColor: &quot;#00BFFF&quot;, borderWidth: 1, borderColor: &apos;#fff&apos;, color: &apos;#00BFFF&apos;, label: &#123; show: true &#125; &#125;, emphasis: &#123; // 也是选中样式 borderWidth: 1, areaColor: &quot;#58FA82&quot;, borderColor: &apos;#fff&apos;, color: &apos;#32cd32&apos;, label: &#123; show: true, textStyle: &#123; color: &apos;#fff&apos; &#125; &#125; &#125; &#125;, map: city,//要和echarts.registerMap（）中第一个参数一致 label: &#123; normal: &#123; show: true &#125;, emphasis: &#123; show: true &#125; &#125;, data : [&#123;name:&apos;广东&apos;, selected:true , value:100&#125;] &#125;] &#125;) 3.效果 未完，以后关于在地图上添加各种标记也会写在这篇文章中"},{"title":"nodeppt(二)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt2/","text":"4.nodeppt书写nodeppt只要是符合markdown语法即可，也支持HTML混编 4.2 总的配置title: 这是title，网页名称speaker: 演讲者名称url:transition: 全局转场动效files: 引入的js和css文件，多个以半角逗号隔开theme: 皮肤样式highlightStyle: 代码高亮样式，默认monokai_sublimeusemathjax: yes 启用MathJax渲染公式 4.2 每一页间隔[slide]nodeppt用[slide]来区分每一页PPT [slide]第一页[slide]第二页[slide] 4.3 样式基于GFM的markdown语法编写 {:&amp;.rollIn} 需要改变样式的话后面直接加{:&amp;.flexbox.vleft}(该样式为居左) 4.4 背景图片完全style写法，更加灵活，视频背景、repeat背景更不在话下 [slide style=”background-image:url(‘/img/bg1.png’)”] 4.5 上下分界线 四个”-“是上下分界线 4.6 表格 Less Sass Stylus 环境 js/nodejs Ruby(这列右对齐) nodejs(高亮) {:.highlight} 扩展名 .less .scss/.sass .styl 特点 老牌，用户多，支持js解析 功能全，有成型框架，发展快 语法多样，小众 案例/框架 Bootstrap Compass Bootstrap Foundation Bourbon Base.Sass 123456| Less | Sass | Stylus:-------|:------:|-------:|--------环境 |js/nodejs | Ruby(这列右对齐) | nodejs(高亮) &#123;:.highlight&#125;扩展名 | .less | .scss/.sass | .styl特点 | 老牌，用户多，支持js解析 | 功能全，有成型框架，发展快 | 语法多样，小众案例/框架 | [Bootstrap](http://getbootstrap.com/) | [Compass](http://beta.compass-style.org) [Bootstrap](http://getbootstrap.com/css/#sass) [Foundation](http://foundation.zurb.com/) [Bourbon](http://bourbon.io) [Base.Sass](https://github.com/jsw0528/base.sass) | 4.7 text文字样式如图所示：展示如图效果12345678910&lt;span class=\"text-danger\"&gt;.text-danger&lt;/span&gt; &lt;span class=\"text-success\"&gt;.text-success&lt;/span&gt;&lt;span class=\"text-primary\"&gt;.text-primary&lt;/span&gt;&lt;span class=\"text-warning\"&gt;.text-warning&lt;/span&gt;&lt;span class=\"text-info\"&gt;.text-info&lt;/span&gt;&lt;span class=\"text-white\"&gt;.text-white&lt;/span&gt;&lt;span class=\"text-dark\"&gt;.text-dark&lt;/span&gt;&lt;span class=\"blue\"&gt;.blue&lt;/span&gt;&lt;span class=\"blue2\"&gt;.blue2&lt;/span&gt;&lt;span class=\"blue3\"&gt;.blue3&lt;/span&gt;&lt;span class=\"gray\"&gt;.gray&lt;/span&gt;&lt;span class=\"gray2\"&gt;.gray2&lt;/span&gt;&lt;span class=\"gray3\"&gt;.gray3&lt;/span&gt;&lt;span class=\"red\"&gt;.red&lt;/span&gt;&lt;span class=\"red2\"&gt;.red2&lt;/span&gt;&lt;span class=\"red3\"&gt;.red3&lt;/span&gt;&lt;span class=\"yellow\"&gt;.yellow&lt;/span&gt;&lt;span class=\"yellow2\"&gt;.yellow2&lt;/span&gt;&lt;span class=\"yellow3\"&gt;.yellow3&lt;/span&gt;&lt;span class=\"green\"&gt;.green&lt;/span&gt;&lt;span class=\"green2\"&gt;.green2&lt;/span&gt;&lt;span class=\"green3\"&gt;.green3&lt;/span&gt; 4.8 label如图所示：展示如图效果12345&lt;span class=\"label label-primary\"&gt;.label.label-primary&lt;/span&gt;&lt;span class=\"label label-warning\"&gt;.label.label-warning&lt;/span&gt;&lt;span class=\"label label-danger\"&gt;.label.label-danger&lt;/span&gt;&lt;span class=\"label label-default\"&gt;.label.label-default&lt;/span&gt;&lt;span class=\"label label-success\"&gt;.label.label-success&lt;/span&gt;&lt;span class=\"label label-info\"&gt;.label.label-info&lt;/span&gt;&lt;a href=\"#\"&gt;link style&lt;/a&gt; &lt;mark&gt;mark&lt;/mark&gt; 4.9 blockquoteblockquote ：如图所示：12nodeppt可能是迄今为止最好用的web presentation &lt;small&gt;三水清&lt;/small&gt;这是一个class是：pull-right的blockquote &lt;small&gt;small一下&lt;/small&gt; &#123;:&amp;.pull-right&#125; 4.10 buttons如图所示：123456&lt;button class=\"btn btn-default\"&gt;.btn .btn-default&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;.btn.btn-lg.btn-primary&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;.btn.btn-waring&lt;/button&gt; &lt;button class=\"btn btn-success\"&gt;.btn.btn-success&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;.btn.btn-danger&lt;/button&gt;&lt;button class=\"btn btn-lg btn-default\"&gt;.btn.btn-lg.btn-default&lt;/button&gt; &lt;button class=\"btn btn-xs btn-success\"&gt;.btn.btn-xs.btn-success&lt;/button&gt; &lt;button class=\"btn btn-sm btn-primary\"&gt;.btn.btn-sm.btn-primary&lt;/button&gt; &lt;button class=\"btn btn-rounded btn-warning\"&gt;.btn.btn-rounded.btn-waring&lt;/button&gt; &lt;button class=\"btn btn-danger\" disabled=\"disabled\"&gt;disabled.btn.btn-danger&lt;/button&gt;&lt;button class=\"btn btn-success\"&gt;&lt;i class=\"fa fa-share mr5\"&gt;&lt;/i&gt;&lt;/button&gt; 4.11 icons如图所示：1234567891011&lt;i class=\"fa fa-apple\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-android\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-github\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-google\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-linux\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-css3\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-html5\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-usd\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-pie-chart\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-file-video-o\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-cog\"&gt;&lt;/i&gt; 4.12 代码格式化使用 highlightjs 进行语法高亮如图所示：1234567891011121314151617181920212223242526&lt;div class=\"columns-2\"&gt; &lt;pre&gt;&lt;code class=\"javascript\"&gt;(function(window, document)&#123; var a = 1; var test = function()&#123; var b = 1; alert(b); &#125;; //泛数组转换为数组 function toArray(arrayLike) &#123; return [].slice.call(arrayLike); &#125;&#125;(window, document)); &lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=\"javascript\"&gt;(function(window, document)&#123; var a = 1; var test = function()&#123; var b = 1; alert(b); &#125;; //泛数组转换为数组 function toArray(arrayLike) &#123; return [].slice.call(arrayLike); &#125;&#125;(window, document)); &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; 4.13 语法混编使用 highlightjs 进行语法高亮如图所示：12345678910111213141516171819&lt;div class=\"file-setting\"&gt; &lt;p&gt;这是html&lt;/p&gt;&lt;/div&gt;&lt;p id=\"css-demo\"&gt;这是css样式&lt;/p&gt;&lt;p&gt;将html代码直接混编到**markdown**文件中即可&lt;/p&gt;我是js控制的颜色 black &#123;:#testScriptTag&#125;&lt;script&gt; function testScriptTag()&#123; document.getElementById('testScriptTag').style.color = 'black'; &#125;&lt;/script&gt;&lt;style&gt;#css-demo&#123; color: red;&#125;&lt;/style&gt; 4.14 iframe如图所示：1&lt;iframe data-src=\"http://www.baidu.com\" src=\"about:blank;\"&gt;&lt;/iframe&gt; 4.15 链接标签链接到百度1[链接到百度](https://www.baidu.com) 5.效果设置5.1 多种皮肤修改url可以改变皮肤如图所示：也可以通过代码点击实现1234567&lt;div class=\"columns6\"&gt; &lt;a href=\"?theme=color\" &gt;color&lt;/a&gt; &lt;a href=\"?theme=blue\"&gt;blue&lt;/a&gt; &lt;a href=\"?theme=dark\"&gt;dark&lt;/a&gt; &lt;a href=\"?theme=green\"&gt;green&lt;/a&gt; &lt;a href=\"?theme=light\"&gt;light&lt;/a&gt;&lt;/div&gt; 5.1 单页面转场设置[magic]中data-transition属性设置转场效果[magic][/magic]中间用========隔开两个div1234567891011121314[magic data-transition=\"earthquake\"]&lt;div class=\"columns3\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt;&lt;/div&gt;========&lt;div class=\"columns4\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt;&lt;/div&gt;[/magic] 5.2 相同页面转场设置 列表支持渐显动效哦 {:&amp;.动效类型} markdown列表第一条加上：{:&amp;.动效类型} markdown列表第一条加上： markdown列表第一条加上： 动效类型 fadeIn淡出淡入 {:&amp;.动效类型} rollIn从后向前放大 bounceIn弹出并震动 moveIn zoomIn从后向前放大 5.3 全局设置前面说过在PPT开头 transition: glue 5.4 页面之间设置在每个页面可以设置自己的转场效果 [slide data-transition=”zoomin”] 5.5 转场url设置在url后加上?transition=newspaper如图所示 slide/slide2/slide3newspapergluekontext/vkontextmove/circlehorizontal/horizontal3dvertical3dzoomin/zoomoutcardsearthquake/pulse/stick 这些转场效果慢慢试吧"},{"title":"nodeppt(三)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt3/","text":"6.装逼利器文字强调6.1 加粗加粗 6.2 字体闪烁em这时按下 H em会闪烁 6.3 放大增加了zoom.js的支持，在演示过程中使用alt+鼠标点击，则点击的地方就开始放大，再次alt+click则回复原状 6.4 使用note笔记用[note][/note]标签包含笔记文字 [note]这里是note笔记使用n键，才能显示[/note] 按下键盘【N】键打开[note]之中内容，否则不显示 7.图片处理7.1 引入图片1![小萝莉](nodeppt3/girl.jpg \"小萝莉\") 和1&lt;img src=\"/girl.jpg\"&gt; 都可以引入图片并且点击图片可放大 7.1 图片禁止放大只需要加个样式即可1&lt;img src=\"/girl.jpg\" class=\"no-screenfull\"&gt; 8.nodeppt的函数和事件8.1 单个slide事件[slide] 中使用data-on-X来指定一个全局函数名123build：当触发下一步操作的时会触发，event具有stop方法keypress：在当前页面按键触发，event具有stop方法enter/leave：进入/离开 此页面触发的事件，event无stop方法 8.2 回调123456[slide data-on-leave=\"fnName\"]进入执行回调incallback函数[slide data-on-enter=\"fnName\"]退出执行outcallback函数亦可以组合写：[slide data-on-leave=\"foo\" data-on-enter=\"bar\"] 8.3 远程执行函数开玩笑远程现在还不好用呢等以后在更新吧 9.后记了解更多内容请点击源代码下载PPT实例请点击，摘自源代码 10 补充10.1 启动项目 先下建立一个.md文件，nodeppt会找是否有.md文件 然后再启动命令启动10.2 手机控制目前手机控制还不算完美，只是翻页控制的还行。 先把本地的防火墙关闭 查看计算机的ip 启动项目 nodeppt start -p 8080 -d D:\\MyJob\\nodeppt -H 192.168.1.8 10.3 导出静态页面使用命令 nodeppt generate D:\\MyJob\\nodeppt\\demo.md D:\\ppt -a 打开连接选远程控制 确保手机能连上电脑的情况下用手机扫码（用手机自带的，别用微信）"},{"title":"nodeppt(一)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt1/","text":"是时候放弃微软的PPT,改用一款够装X够D的利器，nodeppt 0.导言0.1 nodeppt好处基于markdown编写,支持HTML混编对于程序员来说更方便 1.开始1.1 安装前准备不多说了，既然是nodeppt，顾名思义需要安装node，去官网下载即可,好无悬念下一步下一步，安装成功后再控制台查看版本，出现版本号即为安装成功。 1.2 安装nodepptnodeppt需要全局安装 npm install -g nodeppt 同样安装之后查看版本号 nodeppt -v 效果如图这样nodeppt就安装成功，安装成功后可以在控制台打开任意位置的markdown文件，开始表演真正的技术啦！Show Time！ 2.nodeppt命令2.1 获取帮助通过命令获取帮助，查看更多命令 nodeppt start -h 2.2 启动nodeppt-p为端口号-d为路径 nodeppt start -p -d path/for/ppts 例如： nodeppt start -p 8080 -d E:\\私人办公\\ppts 2.3 启动成功启动成功后弹出页面如图所示点击即可弹出页面 3.nodeppt基本操作3.0 页面菜单如图所示，在该位置分别有按钮上一页，下一页，画笔，浏览模式。可分别点击进行操作 3.1 翻页可以按 空格 ，向右 进行下一页/下一步。向左 上一步/上一页 3.2 画笔按 P 打开画笔 ，再次按 P 清空画板 ，按 C 清空画板并关闭画笔画板打开期间可以用 1-4 来选择画笔粗细， B Y G等颜色首字母选择颜色 3.3 表格放大在展示表格的页面按 w 使表格放大 3.4 浏览模式按 O 打开浏览模式，如图所示：，可以浏览选择需要的PPT页面 3.5 多窗口演示可以电脑分屏，自己看一个窗口，分享另一个窗口，这样演讲起来可以预先组织语言。 网址改成url?_multiscreen=1, 这里有个坑，这时候可能多窗口无法使用，请看浏览器右上角收藏旁边，点开，点允许即可。 3.6 打开note笔记按下键盘【N】打开note笔记 3.7 手机控制目前还没成功"},{"title":"个人微博——hexo(二)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/hexo2/","text":"4.配置_config.yml4.1 _config.yml常用结构说明直接上我的配置吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Site 网站# 网站标题 title: linjiad_个人博客#网站副标题subtitle: 柳外轻雷池上雨，雨声滴碎荷声#网站描述description: 这个人很懒什么也没写keywords:#您的名字author: linjiad#网站使用的语言language: JS#网站时区。timezone:# URL 网址#网址url: http://linjiad.github.io#网站根目录root: /#文章的 永久链接 格式 :year/:month/:day/:title/permalink: :year/:month/:day/:title/#永久链接中各部分的默认值 permalink_defaults: # Directory 目录# 资源文件夹，这个文件夹用来存放内容。 source_dir: source# 公共文件夹，这个文件夹用于存放生成的站点文件。public_dir: public# 标签文件夹tag_dir: tags# 归档文件夹archive_dir: archives# 分类文件夹category_dir: categories# Include code 文件夹code_dir: downloads/code# 国际化（i18n）文件夹i18n_dir: :lang# 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径skip_render:# Writing 文章# 新文章的文件名称new_post_name: :title.md # File name of new posts#预设布局，以后就在source下的_post下查看文章default_layout: post#把标题转换为 title casetitlecase: false # Transform title into titlecase#在新标签中打开链接external_link: true # Open external links in new tab#把文件名称转换为 (1) 小写或 (2) 大写 filename_case: 0#显示草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: true#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting分页index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tag 分类 &amp; 标签、# 默认分类default_category: uncategorized#分类别名 category_map:#标签别名tag_map: # Date / Time format 日期 / 时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/#日期格式date_format: YYYY-MM-DD#时间格式time_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable pagination#每页显示的文章量 (0 = 关闭分页功能)per_page: 10#分页目录pagination_dir: page# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#当前主题名称。值为false时禁用主题theme: miho# Deployment## Docs: https://hexo.io/docs/deployment.html#部署部分的设置deploy: type: git repo: https://账号:密码@github.com/你的名字/你的名字.github.io.git branch: master 5.主题themes5.1下载themes主题可以在这里找都是免费的哦！看好的主题可以再github中搜索名字，比如我的主题是，miho可以直接搜索点击进入后可以下载成.zip文件，之后再把文件解压到themes下 5.2配置themes之后再设置_config.yml中theme theme: miho 6.图片处理6.1下载图片处理包下载图片处理包 npm install hexo-asset-image –save 6.2配置_config.yml把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true post_asset_folder: true 6.3创建markdown文档再运行hexo new” xxxx” 生成md文件时source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 6.4放置和调用图片在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：1![你想输入的替代文字](xxxx/图片名.jpg) 7.MIHO主题7.1MIHO配置说明在该主题下会有一个_congig.yml文件，该文件是主题的配置文件_congig.yml配置就不一一说明可以参看README.md或者看这里 7.2MIHO列表图片踩坑这里面还有个大坑，就是列表图片总找不到，原因是路径不对坑在这里改成这个样子123456&lt;% if (post.cover_picture) &#123; %&gt; &lt;img src=\"&lt;%- (/^(http:|https:)?\\/\\//.test(post.cover_picture) ? post.cover_picture :config.url.replace(/\\/$/, '') + '/' + post.cover_picture )%&gt;\" alt=\"&lt;%- post.title %&gt;\" title=\"&lt;%- post.title %&gt;\"&gt; &lt;% &#125; else &#123; %&gt; &lt;img src=\"&lt;%- (/^(http:|https:)?\\/\\//.test(theme.cover_picture) ? theme.cover_picture : config.url.replace(/\\/$/, '') + '/' + theme.cover_picture ) %&gt;\" alt=\"&lt;%- post.title %&gt;\" title=\"&lt;%- post.title %&gt;\"&gt; &lt;% &#125; %&gt; 之后在引用图片的时候需要加日期12345678---title: date: 2018-05-11 09:48:26tags: categories: author: cover_picture: 2018/05/11/hexo2/menu.png--- 图片日期需要和date保持一致 8.尾声常用命令12345678910hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo generate 生成静态文件。hexo deploy 部署网站hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式hexo new page \"about\" 创建新的连接目录hexo new '文章名' 创建新的文件 更多需求可查询hexo官网更多miho主题可查询miho该项目地址放在这儿啦"},{"title":"个人微博——hexo(一)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/hexo1/","text":"用hexo和github搭建个人 免费 博客免费 对我我这种穷人来说显得弥足珍贵 0.导言0.1 个人微博技术个人微博技术有很对，4-12日尤大神发布了VuePress，大神本来想写文档，结果码出了一套框架（容我做一个悲伤的表情），大神就是大神。不过新框架还在不断完善，存在太多坑，这里就先不说VuePress，以后框架完善后再说。这里就聊一聊老牌的微博框架hexo 0.2 hexohexo是一个框架，简洁明朗，基于node，一键部署，并且支持MarkDown，现在微博基本上内容都是用MarkDown来写，而且还有很多 免费 框架哦！之前想写一个微博，用nodejs后台，前端用vue来写，还得弄服务器什么的，超级麻烦。后来学了下hexo，真的超级轻量！(我的废话真多)。 1.安装1.1 安装nodejshexo是基于nodejs，需要nodejs，还不会可以面壁了 1.2 安装hexohexo需要安装全局变量 npm install hexo-cli -g 1.3 安装git去这里https://git-scm.com/downloads毫无压力的进行安装吧 2.快速在本地开始2.1 开始命令 hexo i blog //init的缩写 blog是项目名 hexo初始化hexo cd blog //切换到站点根目录 切换到该目录下，或者直接在该目录下打开控制台 hexo g //generetor的缩写 在此之前可以先clean下，然后生成项目 hexo s //server的缩写 启动本地服务器 2.2 查看成果 打开浏览器输入localhost:4000查看： 2.3 目录结构在初始化的目录下会看到该目录结构一个崭新的博客页面出现在面前123456789node_modules：是依赖包public：存放的是生成的页面;clean会删除;generetor会生成scaffolds：命令生成文章等的模板source：用命令创建的各种文章，以后都在这里写自己的文章themes：主题；存放自己喜欢的主题并使用_config.yml：整个博客的配置db.json：source解析所得到的(我也不大清楚)package.json：项目所需模块项目的配置信息package-lock.json：nodejs升级后存储更细节的包版本，以后写nodejs会详细说明 2.4 安装hexo-server这里需要踩个坑，exo 3.0把服务器独立成个别模块，需要单独安装： npm i hexo-server 3.配置github3.1 在github上创建项目没有账号的自己注册创建新的项目创建项目，输入地址名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用！并且以后yourname.github.io就是你的博客地址，之后点击2创建 3.2 配置github私钥个人觉得这个配置后只能在该电脑使用，像我一样在公司台式机的朋友梦用其他电脑配置会哭的，这里就先不用私钥的办法，后面会说一个更好的方法。 3.2 安装deployer安装deployer后才能美美哒配置发布到网上 npm install hexo-deployer-git –save 之后需要在_config.yml末尾处加入一段代码1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 重点说明一下repo:1https://+用户名:密码+@+github.com/+ 1+.git 这里可以接刚才说的更好的方法 3.2 发布博客这时候小伙伴可以愉快的发布了建议执行命令按顺序执行123hexo cleanhexo generatehexo deploy 3.4 查看博客在浏览器中输入https://刚才的名字.github.io/进行访问"}]
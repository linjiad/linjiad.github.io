[{"title":"商业模式新生代","date":"2018-05-26T01:57:25.000Z","path":"2018/05/26/商业模式新生代/","text":"这本书讲述了商业模式，好像是废话，不多说了看看本书的结构吧 1商业模式画布1.1商业模式定义商业模式描述了企业如何创造价值、传递价值和获取价值的基本原理。本书提供一个了商业模式的框架，它使得我们能够描述和思组织、竞争对手和其他企业的商业模式。该框架提供了一种描述商业模式的共同语言，有了它方便我们分析其他企业的商业模式并寻找商业上的创新。通过9个基本构造块就可以很好地描述并定义商业模式，它们可以展示出企业创造收入的逻辑。 1.29基本构造块CS客户细分CS客户细分，Customer Segments，企业或机构所服务的一个或多个客户分类群体。为了更好地满足客户，企业可能把客户分成不同的细分区隔，每个细分区隔中的客户具有共同的需求、共同的行为和其他共同的属性。企业必须做出合理决议，到底该服务哪些客户细分群体，该忽略哪些客户细分群体。然后凭借对特定客户群体需求的深刻理解，设计相应的商业模式。 VP价值主张VP价值主张，Value Propositions，通过价值主张来解决客户难题和满足客户需求。价值主张构造块用来描绘为特定客户细分创造价值的系列产品和服务，它是用户选择你的原因，是公司提供给用户的利益集合。 CH渠道通路CH渠道通路，Channels，通过沟通、分销和销售渠道向客户传递价值主张。作用：提升公司产品和服务在客户中的认知:帮助客户评估公司价值主张:协助客户购买特定产品和服务:向客户传递价值主张:提供售后客户支持。 CR客户关系CR客户关系，Customer Relationships，在每一个客户细分市场建立和维系客户关系。动机：客户获取；客户维系；提升销量。 R$收入来源R$收入来源，Revenue Streams，收入来源产生于成功提供给客户的价值主张。用于描述公司从每个用户群体获取的现金收入，需要从创收中扣除成本。 KR核心资源KR核心资源，Key Resources，核心资源是用来描绘商业模式有效运转所必须得最重要因素。如：实体资产；知识资产；人力资源；金融资产等。 KA关键业务KA关键业务，Key Activities，通过执行一些关键业务活动，运转商业模式。用来描绘为了确保其商业模式可行，企业必须做的最重要的事情。如：制造产品；问题解决；平台/网络。 KP重要合作KP重要合作，Key Partnerships，有些业务要外包，而另外一些资源需要从企业外部获得。用来描述让商业模式有效运作所需的供应商与合作伙伴的网络。 C$成本结构C$成本结构，Cost Structure，商业模式上述要素所引发的成本构成。成本结构特点：固定成本；可变成本；规模经济；范围经济。 2 式样本书说明了以下几种式样 2.1 非绑定式商业模式有三种不同的基本业务类型:客户关系型业务、产品创新型业务和基础设施型业务。每种类型都包含不同的经济驱动因素、竞争驱动因素和文化驱动因素。这三种类型可能同时存在于一家公司里，但是理论上这三种业务“分离”成独立的实体，以便避免冲突或不利的权衡妥协。 2.2 长尾式商业模式长尾式商业模式的核心是多样少量:他们关注于为利基市场提供大量产品，每种产品相对而言卖得都少。利基产品销售总额可以与凭借少量畅销产品产生绝大多数销售额的传统模式相媲美。.长尾模式需要低库存成本和强大的平台，并使得利基产品对于兴趣买家来说容易获得。 2.3 多边平台式商业模式多边平台将两个或者更多有明显区别但又相互依赖的客户群体集合在一起。只有相关客户群体同时存在的时候，这样的平台才具有价值。多边平台通过促进各方客户群体之间的互动来创造价值。多边平台需要提升其价值，直到它达到可以吸引更多用户的程度，这种现象被称为网络效应。比如：信用卡连接了商家和持卡人;计算机操作系统连接了硬件生产商、应用开发商和用户:报纸连接了读者和广告主;家用视频游戏机连接了游戏开发商和游戏玩家。这里的关键是多边平台必须能同时吸引和服务所有的客户群体并以此来创造价值。多边平台对于某个特定用户群体的价值本质上依赖于这个平台“其他边”的用户数量。如果有足够多的游戏，一款家用游戏机平台就能吸引足够多的玩家。另一方面，如果有足够的游戏玩家已经在玩游戏了，游戏开发商也会为新的视频游戏机开发(更多的)游戏二所以多边平台经常会面临着一个“先有鸡还是先有蛋”左右为难的困境。解决这个问题的方法是针对一个群体。尽管多边平台的运营商最主要的成本是运营费用，但是他们经常会通过为一个群体提供低价甚至免费的服务来吸引他们，并依靠这个群体来吸引与之相对的另一个群体。多边平台的运营商所面临的困难是选择哪个群体，以及以什么价格来吸引他们。 2.4 免费式商业模式在免费式商业模式中，至少有一个庞大的客户细分群体可以享受持续的免费服务。免费服务可以来自多种模式。通过该商业模式的其他部分或其他客户细分群体，给非付费客户细分群体提供财务支持。 免费广告：多变平台的式样基于广告的免费商业模式是多边平台的一个表现形式。平台的一边被设计成以免费的内容、产品或服务来吸引用户，平台的另一边通过销售广告位来产生收入。 费增收商业模式:基础免费，增值收费免费增收模式中有大量基础用户受益于没有任何附加条件的免费产品或服务。大部分免费用户永远不会变成付费客户:只有一小部分，通常不超过所有用户的10%的用户会订阅收费的增值服务。这一小部分付费用户群体所支付的费用将用来补贴免费用户。只有在服务额外免费用户的边际成本极低的时候这种模式才成为可能。在免费增收模式中，关键的指标是为单位用户提供免费服务的成本和免费用户变成付费用户的转化率。 开源:变形的免费增收模式例举RedHat的案例，我理解的是：类似短信服务平台从运营商那里购买短信通道，然后租赁给多个企业使用赚取服务费，因为没有企业愿意承担直接从运营商购买短信通道的高额费用。 保险模式:颠倒的免费增收在免费增收模式中，少量为高级服务付费的客户补贴大量非付费客户。而保险模式则相反，在保险模式中，大量用户定期支付小额费用，来保护自己预防那些一旦发生在财务上就是毁灭性的小概率事件。简而言之，大量付费客户补贴有实际需求的少量客户，而且付费客户可以在任何时间成为受益客户群中的一员(即获赔客户)。 诱钓模式诱钓指的是通过廉价的、有吸引力的甚至是免费的初始产品或服务，来促进相关产品或服务未来的重复购买的商业模式式样。这种模式也称为亏损特价品或剃刀与刀片模式。亏损特价品指的是最初补贴甚至亏本提供，目的是从客户后续购买产生利润的产品或服务。 剃刀与刀片用来描述使用最初产品或服务引诱客户而从后续销售中赚取收入的普遍想法。移动通信行就是个好案例，移动网络运营商提供绑定服务订阅的免费手机已经是标准的做法了。运营商起初赔钱免费赠送手机，但他们很容易通过后续的月服务费弥补损失。运营商以免费产品提供瞬间愉悦，随后产生经常性收入。 1904年，金·吉列将第一款可替换刀片剃须刀推向市场，并以极低的折扣销售刀架，甚至作为其他产品的赠品来销售，以此创造一次性刀片的需求。这种模式的关键是找到便宜甚至免费的初始产品和后续重复消费产品之间的紧密联系。控制这种“锁定”关系是成功的关键。通过专利限制，激烈保证了竞争对手无法为吉列刀架提供更便宜的刀片。剃须刀是世界上专利保护最完善的消费产品，有超过1000种专利/低价打印机，高价墨盒/最后我们来看一下这章脑图 2.5 开放式商业模式开放式商业模式可以用于那些通过与外部伙伴系统性合作，来创造和捕捉价值的企业。这种模式可以是“由外到内”，将外部的创意引入公司内部，也可以是“由内到外”，将企业内部闲置的创意和资产提供给外部伙伴。 3 设计 3.1 客户洞察基于客户洞察建立商业模式。我们要从客户的角度来看待商业模式，这可以让我们找到全新的机会。这并不意味着全按照客户的思维来设计商业模式，但是在评估商业模式的时候需要把客户的思维融入进来。创新的成功需要依靠对客户的深人理解，包括环境、日常事务、客户关心的焦点及愿望。采用客户视角是整个商业模式设计过程的指导原则，应该让客户视角来指引我们关于价值主张、渠道通路、客户关系和收入来源的选择。 真正的挑战在于建立对客户的彻底理解，并基于这种理解进行商业模式设计的选择。在产品和服务设计领域，许多领先企业都与社会学家合作，加深对客户的理解。创新的挑战是建立在对客户的深刻理解上，而不是简单的问他们需要什么。 另一个挑战在于要知道该听取哪些客户和忽略哪些客户的意见。应避免过于聚焦于现有客户细分群体，而应该盯着新的和为满足的客户细分群体。许多商业模式创新的成功，正是因为它们满足了新客户未得到满足的需求。 移情图（empathy map）首先找出客户细分群体，并选择一个开始客户描述分析。先给这个客户一个名字和一些人口统计特征，诸如收入、婚姻情况等。然后询问和回答以下六个问题，在活动挂图或白板上描绘你的新命名的客户。我们的目标是建立一种客户的视角，来持续质疑你的商业模式中的各种假设。 3.2 创意构思需要产生大量商业模式创意，并筛选出最好的创意生成全新商业模式创意。设计新的商业模式需要产生大量商业模式创意，并筛选出最好的创意，这个收集和筛选的过程叫做创意构思。设计新的商业模式时，面对的挑战是忽略现状和暂停关注运营的问题，这样我们才能得到真正的全新创意。 创意构思的两个阶段：创意生成，这个阶段重视数量。创意合成，讨论所有的创意，加以组合，并缩减到少量可行的可选方案。这些方案不一定要代表颠覆性的商业模式，也许只是把你现有的商业模式略做扩展。 商业模式创新的多个集中点我们可以把创新区分为4类不同集中点的商业模式创新，这4个集中点每一个都可以成为主要商业模式变化的起点。有时，商业模式可以引发自多个集中点。 资源驱动型创新起源于一个组织现有的基础设施，抑或合作关系拓展，抑或转变现有商业模式。 产品/服务驱动型创新是以建立新的价值主张的方式来影响其他商业模式构造块。 客户驱动型创新是基于客户需求、降低获取成本或提高便利性的。就像所有从单一集中点所引发的创新一样，来自客户驱动的创新同样可以影响商业模式的构造块。 财务驱动创新是由收入来源、定价机制或成本结构来驱动的，同样影响商业模式的其他构造块。 多中心驱动创新是由多个集中点驱动的，并会显著影响商业模式的其他多个构造块。 3.3 可视思考可视思考的价值。对于商业模式的相关工作来说，可视思考是必不可少的。我们所谓的可视思考，是指使用诸如图片、草图、图表和便利贴等视觉化工具来构建和讨论事情。因为商业模式是由各种构造块及其相互关系所组成的复杂概念，不把它描绘出来将很难真正理解一个模式。 可视化的商业模式画布的好处视觉化的语法。为勾画商业模式所需要的信息提供了视觉和文字指导，因为它会告诉你把哪些信息放入商业模式的哪个部分。 抓住大局。通过描绘出商业模式画布上的所有元素，可以直观的展示出商业模式大局。 查看关系。商业画布可以清晰的表达出各个商业元素之间的关系。 收集参考点。可以把心理得假设贴出来变成明确的信息作为参考。 共同的语言。提供了词汇表和语法帮助人们更好的理解对方，提高凝聚力。 共同的埋解。不同部门员工缺乏对商业模式全貌的认识，商业画布能让所有人快速理解商业模式。 灵感触发器。商业画布中的创意会引发更多创意。 演示。帮助你彻底思考修改某个商业模式元素后所带来的系统性影响。 内/外部推销。把创意和计划清晰的让内/外部人员理解。 3.4 故事讲述讲故事的目的是要把商业模式以形象具体的呈现出来，可以从不同的视角塑造出不同的人物形象，比如下面两种视角： 公司视角,让员工成为故事的主人公，因为员工频繁地关注着客户的烦恼，而新的模式就可以解决这些烦恼。在这样的故事中，员工体现的是商业模式的内部运作机制、为推行新的模式提供了依据。 客户视角，客户道出困扰他的烦恼和他必须解决的问题。然后讲述你们公司是如何帮他创造价值的。在故事中，她描述了她得到了什么样的产品和服务，这些产品和服务是如何解决他的问题的，以及作为一个消费者，他所愿意掏钱的产品和服务是什么样的。 3.5 情景推测作用：通过细化设计环境，帮助我们熟悉商业模式的设计流程基于情景的商业模式设计。情景推测吧抽象的概念变成具体的模型。下面是两种情景推测： 客户情景推测，客户是如何使用产品和服务的，什么类型的客户在使用它们，客户的顾虑、愿望和目的分别是什么。这种建立在客户洞察之上的情景推测更进一步，把对客户的了解融入一组独特、具体的图像。通过描述特定的场景，关于客户的情景推测就能把客户洞察具体形象地表现出来。 未来情景推测，说白了就是臆测未来，假设未来会发生何种变化，然后针对每一种变化设计并检验商业模式。此方法以商业创新为目的，帮助公司更好的应对未来发展。 4 战略 4.1 商业模式环境商业模式是在特定的环境中进行设计和执行的。建议把商业环境大体上映像成四块主要领域范畴： 1市场影响因素市场问题。从客户和提供给客户的产品或服务的视角发现驱动和改变市场的关键因索。 市场细分。发现主要的细分市场，描述它们的吸引力，寻找新的细分市场。 需要和需求。罗列出市场需求，分析市场需求目前的服务水平。 转换成本。描述与客户投靠竟争对手行为相关的因素。 收益吸引力。寻找出与收益吸引力和定价能力相关的因素。 2行业影响因素竞争对手。发现当前竞争对手和它们的相对优势。 行业新入者。发现新的崛起的行业对手，判断它们是否利用不同于你的商业模式与你竟争。 替代性产品和服务。描述你公司的产品和服务潜在替代品，包括其他市场和行业的产品和服务。 供应商和其他价值链参与者。在你公司所在的市场中，描述出目前关键的价值链参与者，并发现新崛起的参与者。 利益相关者。确认哪些参与者可能会影响你的公司和商业模式。 3关键趋势技术趋势。发现能威胁、改变或改良你的公司的商业模式的技术趋势。 监管法规趋势。描述影响你的商业模式的法规及其变化趋势。 社会和文化趋势。发现可能会，影响你的商业摸式的主要社会趋势。 社会经济趋势。概括与你的商业模式相关的主要社会经济趋势。 4宏观经济影响力全球市场情况。从宏观的经济视角总结全球市场目前的整体状况。 资本市场。描绘出与你的资本需求密切相关的资本市场状况。 商品和其他资源。重点关注你的商业模式中所需资源的当前价格及其未来趋势。 经济基础。描绘你的业务运营环境中的经济基础。 4.2 评估商业模式如同每年做身体检查一样，定期评估商业模式是一种重要的管理工具，它可以评估出组织在行业内的“健康”程度，并适时地做出一些相应的调整。这种健康检查可以成为商业模式不断改进优化的基础。商业模式视角下的蓝海战略《蓝海战略》这本书可以看看。管理多个商业模式 商业评估工具SWOT(优势，劣势，威胁，机会) 4.3 蓝海战略蓝海战略：通过改变现有的商业模式来区分与竞争对手的模式，从而创造出新的行业 去除：那些被行业认为理所应当的存在应该被去除 降低：哪种因素应该被降低到标准之下 提升：哪种因素应该被提高到标准之上 创造：哪种行业中没有的因素应该被创造出来 5 流程5.1 创新四大目标商业模式创新的目标：满足市场，满足被忽视的市场需求。 投放市场，把新技术、产品和服务推向市场。 改善市场，通过更好的商业模式来改进、颠覆或变革现有的市场。 创造市场，建立全新的市场。 5.2 五大阶段动员为一个成功的商业模式设计项目做好准备工作。 活动：确定项目目标、测试初步商业想法、规划、组件设计团队。 关键：合适的队友、经验和知识。 风险：高估了初始想法的价值。 理解研究和分析商业模式所需要的元素。 活动：环境分析、研究潜在客户、采访行业专家、研究前人做法（失败案例）、收集想法。 关键：对潜在目标市场的深入理解、超越传统目标市场定义的界限。 风险：研究过度（研究和目标脱节）、收到预先想法的影响，研究结果不客观。 设计构建和测试可行的商业模式可选方案，并挑选最佳的方案。 活动：头脑风暴、原型制作、测试、选择。 关键：与不同部门的员工一起设计、透过现状看本质的能力、投入时间，探索多种商业模式。 风险：低估或打压大胆想法、过快的钟情于某个想法。 实施在实际环境中实施商业模式原型。 活动：交流和参与、执行。 关键：最佳项目管理、快速调整商业模式的能力和意愿、平衡好旧模式和新模式。 风险：积极性降低、减弱。 管理结合市场反馈来调整和修改商业模式。 活动：分析环境、持续的评估你的商业模式、换一个角度思考你的商业模式、调整商业模式，配合公司整体战略、处理模式间的协同效应和冲突问题。 关键：目光长远、积极主动、商业模式的管理。 风险：成为成功的牺牲品，满足于现状而未能及时作出调整。 最后贴一个脑图地址吧"},{"title":"weex","date":"2018-05-24T01:43:24.000Z","path":"2018/05/24/weex/","text":"0.安装0.1 安装nodejs这个不多说了不会的面壁吧。 0.2 安装weex-toolkit这个是个坑啊，官方给出的安装是 npm install weex-toolkit -g 不过这个安装可能会各种失败，失败之后再安装就无法安装了。即使再用淘宝镜像。那怎么办呢？首先我们需要卸载一下weex-toolkit npm uninstall weex-toolkit -g 其次我们需要去电脑中删除些文件还有这个也需要删除删除了这些，我们再安装，注意要用管理员运行cmd这次我们用淘宝镜像，没有cnpm自己安装下就可以了 cnpm install -g weex-toolkit 安装之后查看版本 npm uninstall weex-toolkit -g 出现版本号既可以了 0.3 安装java及配置0.4 安装git0.5 安装webpack0.6 安装android-studio安装android-studio这儿啦下一步下一步就好啦现在安装android-studio不带android-sdk，所以需要自己装之后还会安装一起android包，这时候需要翻墙，要访问谷歌这里强烈建议用国内镜像如图所示 大连东软信息学院镜像服务器地址:http://mirrors.neusoft.edu.cn 端口：80 接着点击close，关闭对话框，再重新启动SDK Manager就行啦。经过漫长的下载安装过程后，我们可以看到，之前选中安装的项目后面的状态都由之前的“Not installed”变为了如今的“Installed”，这就表示我们已经安装成功了！之后再配置android-sdk打开环境变量路径：控制面板-&gt;系统和安全-&gt;系统-&gt;高级系统设置-&gt;环境变量。新建：ANDROID_HOME 并把我们刚才赋值的sdk路径作为值插入添加path值，与配置java相同 ;%ANDROID_SDK_HOME%\\platform-tools; 保证系统能找到platform-tools下的adb.exe即可输入adb查看，出现下面情况即配置成功。接着刚才安装android-studio由于本机没有安装过Android Studio，因此这里也没有可导入的配置信息。点击OK。点击Setup Proxy。按上图设置代理。点击OK。点击Next。安装类型选择为”Custom”，并点击Next。将UI主题选择为Darcula(此风格看起来更加极客)。点击Next。选择之前安装Android Studio的路径，可以看到看下上图所述提示。点击Next。点击FinishAndroid SDK已经是最新。点击Finish。点击”Start a new Android Studio project”即可开始第一个Android程序的开发。 1.开启weex之旅吧1.1建立weex项目目录建立weex项目名称为helloWeex weex create helloWeex 建立时和vue一样，输入项目名称是否为helloWeex项目描述项目作者是否用eslint，一个js语法标准是否测试之后项目就建好了,目录结构如下添加Android应用支持 weex platform add android 如果你要支持IOS平台的话，你还要添加IOS应用，但是抱歉的是我没有苹果电脑，所以这里就不演示苹果的添加了。 1.2在Android Studio里运行weex"},{"title":"Swagger2","date":"2018-05-21T09:50:05.000Z","path":"2018/05/21/Swagger2/","text":"Swagger2主要解决接口文档，有了它妈妈再也不用担心接口太多不方便管理了，只需要在写代码时候简单加入些注解即可，方便简单。 0.安装pom文件直接在pom中用Maven下载jar包12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 1.创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.dataacquisition;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author colin * @version 1.0.0 * @date 17/10/24 下午12:02. */@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; ParameterBuilder parameterBuilder = new ParameterBuilder(); List&lt;Parameter&gt; parameters = new ArrayList&lt;Parameter&gt;(); parameterBuilder.name(\"Content-Type\") .description(\"header\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false).build(); parameters.add(parameterBuilder.build()); parameterBuilder.name(\"Accept\") .description(\"header\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false).build(); parameters.add(parameterBuilder.build()); //上面是设置header return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()// 选择那些路径和api会生成document .apis(RequestHandlerSelectors.basePackage(\"com.iss.rest\"))// 对所有api进行监控// .apis(RequestHandlerSelectors.any())// 对所有路径进行监控 .paths(PathSelectors.any()) .build() .globalOperationParameters(parameters) .apiInfo(apiInfo()); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"经济运行大数据API\") .description(\"经济大数据\") .termsOfServiceUrl(\"www.baidu.com\") .contact(\"colin\") .version(\"1.0\") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。看一下这个目录结构这里还要说明一下引包 PathSelectors import springfox.documentation.builders.PathSelectors; 1.添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容GET接口 对于传统参数为？的123456789101112131415161718192021222324252627@ApiOperation(value = \"上传Excel\", notes = \"上传Excel并存入数据库\", code = 200, produces = \"application/json\")@ApiImplicitParams(&#123;@ApiImplicitParam(name = \"userId\",value = \"用户ID\",required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"filepath\", value = \"上传文件路径地址用“/”\",paramType = \"query\", required = true, dataType = \"String\"), @ApiImplicitParam( name = \"type\", value = \"上传文件类型\", required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"productId\", value = \"上传文件productId\", required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"version\", value = \"上传文件版本\", required = false,paramType = \"query\", dataType = \"String\")&#125;)@RequestMapping(value = \"/uploadExcel\", method = RequestMethod.GET)public String uploadExcel(HttpServletRequest request) &#123; String filepath = WebUtils.findParameterValue(request, \"filepath\"); String productId = WebUtils.findParameterValue(request, \"productId\"); if(StringUtils.isBlank(filepath)||!new File(filepath).exists())&#123; return \"请输入正确文件路径\"; &#125; if(!configProductService.selectProductByProductId(productId))&#123; return \"productId不存在，请输入正确的productId\"; &#125; String userId = WebUtils.findParameterValue(request, \"userId\"); String type = WebUtils.findParameterValue(request, \"type\"); if(StringUtils.isBlank(type))&#123; return \"请输入上传Excel的种类（type=）\"; &#125; String version = WebUtils.findParameterValue(request, \"version\"); String result = uploadExcelService.uploadExcel(filepath,userId,type,version,productId); String result2 = uploadExcelService.upload(filepath); return result;&#125; GET接口 对于参数为/的123456789101112131415161718192021222324252627282930313233@ApiOperation(value = \"获取所有新闻\", notes = \"获取所有新闻\", code = 200, produces = \"application/json\") @ApiImplicitParams(&#123;@ApiImplicitParam(name = \"infoType\",value = \"行业动态等类别\",required = true,paramType = \"query\", dataType = \"String\"), @ApiImplicitParam( name = \"type\", value = \"所属行业\",paramType = \"query\", required = true, dataType = \"String\"), &#125;) @RequestMapping(value = \"/queryAllNewsNew/&#123;infoType&#125;/&#123;type&#125;/&#123;startTime&#125;/&#123;endTime&#125;/&#123;region&#125;/&#123;pageNum&#125;/&#123;pageSize&#125;\", method = RequestMethod.GET, produces = &#123;\"application/json\"&#125;, consumes = &#123;\"application/json\"&#125;) public Result queryAllNewsNew(@PathVariable(\"infoType\") String infoType, @PathVariable(\"type\") String type, @PathVariable(\"startTime\") String startTime, @PathVariable(\"endTime\") String endTime, @PathVariable(\"region\") String region, @PathVariable(\"pageNum\") String pageNum, @PathVariable(\"pageSize\") String pageSize) &#123; if (StringUtils.isBlank(pageNum)) &#123; pageNum = \"1\"; &#125; if (StringUtils.isBlank(pageSize)) &#123; pageSize = \"10\"; &#125; ResultEducationInfo resultEducationInfo = new ResultEducationInfo(); resultEducationInfo.setRegion(region); resultEducationInfo.setCityName(region); resultEducationInfo.setInfoType(infoType); resultEducationInfo.setCrawlType(type);// resultEducationInfo.setTime(time); resultEducationInfo.setStartTime(startTime); resultEducationInfo.setEndTime(endTime); resultEducationInfo.setPageNum(pageNum); resultEducationInfo.setPageSize(pageSize); Result result = jsonSearchService.queryAllNews(resultEducationInfo); return result; //Result.success(result); &#125; POST接口1234567891011@ApiOperation(value = \"解析Excel\", notes = \"解析Excel\", code = 200, produces = \"application/json\")@ApiImplicitParam(name = \"filepath\", value = \"上传文件路径地址用“/”\",paramType = \"query\", required = true, dataType = \"String\")@RequestMapping(value = \"/analysisExcel\", method = RequestMethod.POST)public Map analysisExcel(HttpServletRequest request) &#123; String filepath = WebUtils.findParameterValue(request, \"filepath\"); if(StringUtils.isBlank(filepath)||!new File(filepath).exists())&#123; return null; &#125; Map result = uploadExcelService.analysisExcel(filepath); return result;&#125; 结果如图所示"},{"title":"jQuery生成二维码","date":"2018-05-18T08:59:40.000Z","path":"2018/05/18/jQuery生成二维码/","text":"还是扫描二维码登录的需求，既然和二维码相关肯定需要实现二维码生成啦！ 0安装生成二维码的包不止一种，这里一个坑 qrcode 包，他也可以生成二维码，但是很难设置二维码大小，颜色等，强烈不建议安装这个。我已经掉坑里过。那么推荐使用jquery.qrcode。 npm install jquery.qrcode -s 这里前提是需要安装jquery并且在webpack中配好，先说一下代码，以后会详细说明123456plugins:[ new webpack.ProvidePlugin(&#123; $: \"jquery\", jQuery: \"jquery\" &#125;), ] 1使用之后引用jquery.qrcode1require('jquery.qrcode') 在之后在Html中定义div容器1&lt;div id=\"query\"&gt;&lt;/div&gt; 这里可以不用设置div大小，因为可以再js中设置二维码大小 再之后是js部分 1234567891011//动态生成二维码 $(\"#query\").qrcode(&#123; render: \"canvas\", // 渲染方式有table方式和canvas方式 width: 256, //默认宽度 height: 256, //默认高度 text: encodeURI(\"http://www.cnblogs.com/HtmlCss3/\"）, //二维码内容 typeNumber: -1, //计算模式一般默认为-1 correctLevel: 2, //二维码纠错级别 background: \"#ffffff\", //背景颜色 foreground: \"#000000\" //二维码颜色&#125;); 说明下encodeURI是为了防止中文乱码。应该不会怎么用上。至于如果想在二维码中间添加图片，目前不支持添加图片，不过我们可以自己把图片移到中间位置"},{"title":"websocket+Springboot","date":"2018-05-18T06:54:16.000Z","path":"2018/05/18/websocket/","text":"今天要做一个手机扫描登录，功能拆分，需要websocket推送信息到页面，不废话了直接开始吧。 0.导言0.1什么是websocket它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 0.2准备都需要什么准备呢？毫无疑问需要客户端（浏览器），服务端（后台），这里后台我们用的是Springboot。 1.后台Springboot1.1引包在pom中引用webpack包123456&lt;!-- 操作websoket--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;version&gt;1.3.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 1.2注入ServerEndpointExporter使用springboot内置tomcat进行部署的话，在编写websocket具体实现类之前，要注入ServerEndpointExporter，这个bean会自动注册使用了@ServerEndpoint注解声明的Websocket endpoint。1234567891011121314import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.socket.server.standard.ServerEndpointExporter;/** * Created by linjiad on 2018/5/18. */@Configurationpublic class WebSocketConfig &#123; @Bean public ServerEndpointExporter serverEndpointExporter()&#123; return new ServerEndpointExporter(); &#125;&#125; 1.3写自己的实现类直接先看代码吧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import net.sf.ehcache.util.concurrent.ConcurrentHashMap;import org.springframework.stereotype.Component;import javax.websocket.*;import javax.websocket.server.ServerEndpoint;import java.io.IOException;import java.util.Map;/** * Created by linjiad on 2018/5/18. */@ServerEndpoint(value = \"/websocket\")@Componentpublic class MyWebSocket &#123; //统计在线人数 private static int onlineCount = 0; //用本地线程保存session private static ThreadLocal&lt;Session&gt; sessions = new ThreadLocal&lt;Session&gt;(); //保存所有连接上的session private static Map&lt;String, Session&gt; sessionMap = new ConcurrentHashMap&lt;String, Session&gt;(); public static synchronized int getOnlineCount() &#123; return onlineCount; &#125; public static synchronized void addOnlineCount() &#123; onlineCount++; &#125; public static synchronized void subOnlineCount() &#123; onlineCount--; &#125; //连接 @OnOpen public void onOpen(Session session) &#123; sessions.set(session); addOnlineCount(); sessionMap.put(session.getId(), session); System.out.println(\"【\" + session.getId() + \"】连接上服务器======当前在线人数【\" + getOnlineCount() + \"】\"); //连接上后给客户端一个消息 sendMsg(session, \"恭喜你连接服务器成功！\"+session.getId()); &#125; //关闭 @OnClose public void onClose(Session session) &#123; subOnlineCount(); sessionMap.remove(session.getId()); System.out.println(\"【\" + session.getId() + \"】退出了连接======当前在线人数【\" + getOnlineCount() + \"】\"); &#125; //接收消息 客户端发送过来的消息 @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(\"【\" + session.getId() + \"】客户端的发送消息======内容【\" + message + \"】\"); String[] split = message.split(\",\"); String sessionId = split[0]; Session ss = sessionMap.get(sessionId); if (ss != null) &#123; String msgTo = \"【\" + session.getId() + \"】发送给【您】的消息:\\n【\" + split[1] + \"】\"; String msgMe = \"【我】发送消息给【\"+ss.getId()+\"】:\\n\"+split[1]; sendMsg(ss, msgTo); sendMsg(session,msgMe); &#125;else &#123; for (Session s : sessionMap.values()) &#123; if (!s.getId().equals(session.getId())) &#123; sendMsg(s, \"【\" + session.getId() + \"】发送给【您】的广播消息:\\n【\" + message + \"】\"); &#125; else &#123; sendMsg(session,\"【我】发送广播消息给大家\\n\"+message); &#125; &#125; &#125; &#125; //异常 @OnError public void onError(Session session, Throwable throwable) &#123; System.out.println(\"发生异常!\"); throwable.printStackTrace(); &#125; //统一的发送消息方法 public synchronized void sendMsg(Session session, String msg) &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这段代码里面注释都很清晰了，不多说了，重点是在 onMessage 方法中。后端就这么多久搞定了，很简单，把后端项目跑起来等待前端信息就可以了 2.前端2.1 页面HTMLHTML就很简单了，一个div,一个输入框，一个按钮就搞定1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;jspang webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id = \"message\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"ceshi\"&gt; &lt;button id=\"a\"&gt;发送&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 别问我为啥没引用js，因为我用的是webpack这个之后再讲。 2.2 js实现这个地方我分成了两部分，用import形式引入websocket部分先看index.js123456import websocket_config from './js/websocket_config.js';let websocket = new websocket_config.Websocket();$(\"#a\").on('click', function() &#123; let message = document.getElementById('ceshi').value; websocket.send(message); &#125;) 这段代码就是点击按钮把’ceshi’信息传给后台另一个websocket_config，我是把websocket部分封装进来12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Websocket&#123; constructor(url=\"ws://localhost:11000/websocket\") &#123; let self = this; self.url=url; let websocket = null; //判断当前浏览器是否支持WebSocket if('WebSocket' in window)&#123; self.websocket = new WebSocket(this.url); &#125; else&#123; alert(\"您当前浏览器不支持websocket\") &#125; //连接发生错误的回调方法 self.websocket.onerror = function()&#123; self.setMessageInnerHTML(\"error\"); &#125;; //连接成功建立的回调方法 self.websocket.onopen = function(event)&#123; self.setMessageInnerHTML(\"open\"); &#125; //接收到消息的回调方法 self.websocket.onmessage = function(event)&#123; console.log(event); self.setMessageInnerHTML(event.data); &#125; //连接关闭的回调方法 self.websocket.onclose = function()&#123; self.setMessageInnerHTML(\"close\"); &#125; //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。 window.onbeforeunload = function()&#123; self.websocket.close(); &#125; &#125; setMessageInnerHTML(innerHTML) &#123; document.getElementById('message').innerHTML += innerHTML + '&lt;br/&gt;'; &#125; closeWebSocket()&#123; this.websocket.close(); &#125; //发送消息 send(message)&#123; this.websocket.send(message); &#125;&#125;export default &#123;Websocket&#125;; 敲黑板划重点，这里有个坑，就是Class里面的this，前面我们这么写的 let self = this; 否则后面function里面this指向自己的function 3 看看具体效果吧直接输入信息会广播出去给所有人，如图所示所有人都会看到信息因为在后台代码12345678910111213141516171819202122232425262728293031//接收消息 客户端发送过来的消息 @OnMessage public void onMessage(String message, Session session) &#123; System.out.println(\"【\" + session.getId() + \"】客户端的发送消息======内容【\" + message + \"】\"); String[] split = message.split(\",\"); String sessionId = split[0]; Session ss = sessionMap.get(sessionId); if (ss != null) &#123; String msgTo = \"【\" + session.getId() + \"】发送给【您】的消息:\\n【\" + split[1] + \"】\"; String msgMe = \"【我】发送消息给【\"+ss.getId()+\"】:\\n\"+split[1]; sendMsg(ss, msgTo); sendMsg(session,msgMe); &#125;else &#123; for (Session s : sessionMap.values()) &#123; if (!s.getId().equals(session.getId())) &#123; sendMsg(s, \"【\" + session.getId() + \"】发送给【您】的广播消息:\\n【\" + message + \"】\"); &#125; else &#123; sendMsg(session,\"【我】发送广播消息给大家\\n\"+message); &#125; &#125; &#125; &#125; //统一的发送消息方法 public synchronized void sendMsg(Session session, String msg) &#123; try &#123; session.getBasicRemote().sendText(msg); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 如果，前面没有id则会循环sessionMap发给所有人如果，前面有id则单独发给一个人 session.getBasicRemote().sendText(msg);谁获取了什么消息"},{"title":"css3-grid网格化布局","date":"2018-05-17T08:32:49.000Z","path":"2018/05/17/css3-grid网格化布局/","text":"1.第一个 Grid 布局CSS Grid 布局由两个核心组成部分是: wrapper（父元素）和 items（子元素）。下面是一个 wrapper 元素，内部包含6个 items ：HTML部分12345678&lt;div class=&quot;wrapper&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;div&gt;6&lt;/div&gt;&lt;/div&gt; 要把 wrapper 元素变成一个 grid(网格)，只要简单地把其 display 属性设置为 grid 即可：123.wrapper &#123; display: grid;&#125; 仅仅是这样并没有什么用处结果如图所示： 2.Columns(列) 和 rows(行)为了使其成为二维的网格容器，我们需要定义列和行。让我们创建3列和2行。我们将使用 grid-template-row 和 grid-template-column 属性。 12345.wrapper &#123; display: grid; grid-template-columns: 100px 100px 100px; //设置三列（1-4条线） grid-template-rows: 50px 50px;//设置两行（1-3条线）&#125; 记住几条线是接下来需要用的这些值决定了我们希望我们的列有多宽（ 100px ），以及我们希望行数是多高（ 50px ）如果这样设置12345.wrapper &#123; display: grid; grid-template-columns: 200px 50px 100px; grid-template-rows: 100px 30px;&#125; 结果就是这样注意这里评分宽度尽量用（可以自适应） grid-template-columns: repeat(6, 1fr); 页面宽度平均分成6份，每个占一份 3.放置 items(子元素)3.1行要定位和调整 items(子元素) 大小，我们将使用 grid-column 和 grid-row 属性来设置：1234.item1 &#123; grid-column-start: 1; grid-column-end: 4;&#125; 当然也可以这么写123.item1 &#123; grid-column: 1 / 4;&#125; item1 占据从第一条网格线开始，到第四条网格线结束换句话说，它将独立占据整行.结果如图所示：这是怎么回事呢？为啥是1,4呢，原因如图 3.2列同理。列也就不用多说了，直接看代码123456789101112.item1 &#123; grid-column-start: 1; grid-column-end: 3;&#125;.item3 &#123; grid-row-start: 2; grid-row-end: 4;&#125;.item4 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 结果如下：基本布局这些就够了 4.矩阵布局——grid-template-areas直接代码讲解吧123456789101112131415161718192021.item-1 &#123; grid-area: header;&#125;.item-2 &#123; grid-area: main;&#125;.item-3 &#123; grid-area: sidebar;&#125;.item-4 &#123; grid-area: footer;&#125; .wrapper &#123; grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: &quot;header header header header&quot; &quot;main main . sidebar&quot; &quot;footer footer footer footer&quot;;&#125; 把每个div起一个别名： .item-a { grid-area: header;} 开始布局 grid-template-areas: “header header header header” “main main . sidebar” “footer footer footer footer”; 其中.代表空占位结果如图所示： 5指定网格线(grid lines)的大小属性这么设置1234.wrapper &#123; grid-column-gap: &lt;line-size&gt;; grid-row-gap: &lt;line-size&gt;;&#125; 具体事例123456.container &#123; grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-column-gap: 10px; grid-row-gap: 15px;&#125; 6 每个网格中的格式6.1整体设置 -justify-items123.container &#123; align-items: start | end | center | stretch;&#125; start：将内容对齐到网格区域(grid area)的顶部end：将内容对齐到网格区域的底部center：将内容对齐到网格区域的中间（垂直居中）stretch：填满网格区域高度（默认值）示例：123.container &#123; align-items: start;&#125; 示例：123.container &#123; align-items: end;&#125; 示例：123.container &#123; align-items: center;&#125; 示例：123.container &#123; align-items: stretch;&#125; 6.2单个设置 -justify-self规则和上面一样，这里就不多说了示例：123.item-a &#123; justify-self: start;&#125; 示例：123.item-a &#123; justify-self: end;&#125; 示例：123.item-a &#123; justify-self: center;&#125; 示例：123.item-a &#123; justify-self: stretch;&#125; 7.非自适应布局对齐方式7.1沿—X轴线有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像px这样的非灵活单位设置大小，在这种情况下，您可以设置网格容器内的网格的对齐方式start：将网格对齐到 网格容器(grid container) 的左边end：将网格对齐到 网格容器 的右边center：将网格对齐到 网格容器 的中间（水平居中）stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间space-evenly：在每个栅格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间示例：123.container &#123; justify-content: start;&#125; 123.container &#123; justify-content: end;&#125; 123.container &#123; justify-content: center;&#125; 123.container &#123; justify-content: stretch;&#125; 123.container &#123; justify-content: space-around;&#125; 123.container &#123; justify-content: space-between;&#125; 123.container &#123; justify-content: space-evenly;&#125; 7.2沿—Y轴线和x轴基本一样示例：123.container &#123; align-content: start;&#125; 123.container &#123; align-content: end;&#125; 123.container &#123; align-content: center;&#125; 123.container &#123; align-content: stretch;&#125; 123.container &#123; align-content: space-around;&#125; 123.container &#123; align-content: space-between;&#125; 123.container &#123; align-content: space-evenly;&#125; 总结常用的基本就这些了如果需要了解更多，这儿啦"},{"title":"echarts-字符云","date":"2018-05-17T02:31:25.000Z","path":"2018/05/17/echarts-字符云/","text":"首先要说下，从echarts2.0之后，字符云就被分离出来，需要独自安装 1.安装1.1安装其他安装不说了，单独说下需要安装echarts和echarts-wordcloud npm install echarts-wordcloud -s 1.2引用在总的js中123let echarts = require(&apos;echarts&apos;);window.echarts=echarts;require(&apos;echarts-wordcloud&apos;); 2.使用heml部分代码就不强调了，直接写js部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768let colorlist = [&quot;#4ad2ff &quot;, &quot;#36ffb1&quot;, &quot;#23ff4f&quot;, &quot;#3dff27&quot;, &quot;#7aff1a&quot;, &quot;#bdff1c&quot;, &quot;#e2ff15&quot;, &quot;#fdff52&quot;]; let myChart = echarts.init(document.getElementById(&quot;portrait&quot;)); let option = &#123; tooltip: &#123;&#125;, series: [&#123; type: &apos;wordCloud&apos;, gridSize: 10, //sizeRange: [22, 50], //rotationRange: [0, 0], //shape: &apos;circle&apos;, textStyle: &#123; normal: &#123; color: function() &#123; return colorlist[parseInt(10*Math.random())]; &#125; &#125;, /*emphasis: &#123; shadowBlur: 10, shadowColor: &apos;#333&apos; &#125;*/ &#125;, data: [&#123; name: &apos;企业&apos;, value: 10000, &#125;, &#123; name: &apos;公务员&apos;, value: 6181 &#125;, &#123; name: &apos;2018&apos;, value: 4386 &#125;, &#123; name: &apos;上下游&apos;, value: 4055 &#125;, &#123; name: &apos;公司&apos;, value: 2467 &#125;, &#123; name: &apos;项目&apos;, value: 2244 &#125;, &#123; name: &apos;十二月份&apos;, value: 1898 &#125;, &#123; name: &apos;一批&apos;, value: 1484 &#125;, &#123; name: &apos;大连&apos;, value: 1112 &#125;, &#123; name: &apos;北京&apos;, value: 965 &#125;, &#123; name: &apos;全国&apos;, value: 847 &#125;, &#123; name: &apos;采购&apos;, value: 582 &#125;, &#123; name: &apos;考试&apos;, value: 555 &#125;, &#123; name: &apos;示范&apos;, value: 550 &#125;,] &#125;] &#125;; myChart.setOption(option) 一个简单的字符云就出来了，更多功能以后待更新"},{"title":"css3-文字特效和背景透明","date":"2018-05-16T02:18:35.000Z","path":"2018/05/16/css3-文字特效和背景透明/","text":"直接上图，需要用CSS3实现这样的效果 1.html部分html这里需要一个 标签包含 之后每组字都是自己的 之所以是div是需要给每组字限定大小。1234567891011&lt;ul&gt; &lt;li class = &quot;li_title&quot;&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;区域占有率&lt;/div&gt;&lt;div&gt;主营产品&lt;/div&gt;&lt;div&gt;来源&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;li class = &quot;li_list&quot;&gt;&lt;div&gt;公司名称公司名称公司名称公司名称公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;div&gt;公司名称&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt; 2.CSS部分2.1 li背景这里的li分为两部分，标题部分和其他行，这里如果用less的话就非常方便，less以后会在less专题中说，这里还是用css1234567.li_title&#123; margin-left: -50px; //内边距向左50 height: 30px; //每行高30px list-style-type : none; //去掉li前面的· background-color: rgb(46,154,254,0.6); //设置背景颜色，并且透明度为0.6 border-radius:10px; //拐角度为10px&#125; 后面的行无非就是改个颜色12345678.li_list&#123; margin-left: -50px; height: 30px; margin-top: 15px; list-style-type : none; background-color: rgb(28,28,28,0.6); border-radius:10px;&#125; 2.2 文字特效这里的特效就是多余的文字变成…直接代码讲解吧12345678910ul div&#123; color : #FFFFFF; //文字颜色白色 font-size : 18px; //字体大小18px float:left; //文字靠左浮动 margin-left: 8%; //左边距为8%，也就是每个字之间的间距 width:110px; //规定div大小，也就是文字框大小（主要） white-space:nowrap; //规定文字不能换行（主要） overflow:hidden; //规定多余的文字隐藏（主要） text-overflow:ellipsis; //规定文字超出的话···（主要）&#125; 这些之后图片的效果就回显现 3.左侧按钮特效直接上图，需要用CSS3实现这样的效果要实现这个效果首先要在左面定义一个 3.1左侧div_html123456789&lt;div class = &quot;menu&quot;&gt; &lt;ul&gt; &lt;li value = &quot;reaches&quot;&gt;行业上下游&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;xiehui&quot;&gt;协会理事会&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;gongxu&quot;&gt;供需平台&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;shejiao&quot;&gt;社交平台&lt;/li&gt; &lt;li class=&quot;menu_select&quot; value = &quot;qita&quot;&gt;其他&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 3.2.左侧CSS样式首先是menu的样式123456.menu&#123; width: 13%; //定义宽度 height: 736px; //定义高度 float:left; //浮动到左侧 transform:skew(0deg,20deg); //敲黑板划重点，倾斜，两个参数，这里是沿着x轴向下倾斜20度&#125; 之后设定ul样式，这个样式没有什么好说的12345.menu ul &#123; float:left; margin-top: 25%; margin-left: -20%;&#125; 再之后设置li样式，划重点1234567891011121314.menu li &#123; width: 100%; //li宽度 height: 100px; //高度 margin-top: 5%; //内置上边距 color : #FFFFFF; //颜色（字体） font-size : 20px; //字体大小 border:1px solid #ffffff; //边界线粗细为1px。边界线颜色为白色 list-style-type : none; //不显示· float:left; //左浮动 display: flex; //（划重点）用flex布局，这样设置里面字居中 align-items:center; // 上下居中 justify-content: center;// 左右居中 cursor: pointer; //鼠标经过变成手指&#125; 未被选择的li需要一个透明的背景色，如同前面一样，直接上代码123.menu_select&#123; background-color: rgb(110,110,110,0.3);&#125; 3.3实现点击切换效果js循环ul的children，如果和点击的li相同则删除menu_select样式，否则添加menu_select样式123456789101112$(&quot;.menu li&quot;).on(&apos;click&apos;, function() &#123; for (let child of $(&quot;.menu ul&quot;).children()) &#123; if(child.innerHTML != this.innerHTML)&#123; $(child).addClass(&quot;menu_select&quot;); $(&quot;#&quot;+child.attributes.value.value).hide() &#125; else&#123; $(child).removeClass(&quot;menu_select&quot;); $(&quot;#&quot;+child.attributes.value.value).show() &#125; &#125; &#125;)"},{"title":"echarts_地图","date":"2018-05-16T01:43:31.000Z","path":"2018/05/16/echarts-地图/","text":"echarts构建数据可视化 1.安装1.1 安装nodejs构建webpack项目，需要安装nodejs，告别传统直接1&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 标签引用，nodejs安装和webpack构建这里先不说了，以后专门写webpack时候再说。nodejs前面也说过安装就不多说了。 1.2 安装echarts直接使用命令1npm install echarts -s 这里说明一下，有个坑，echarts地图显示存在版本冲突，所以可以@你的版本号避免这种冲突。 1.3 引用echarts在webpack构建的项目里，在index.js或者main.js，即页面直接引用的js引用echarts12let echarts = require('echarts');window.echarts=echarts; 这里说明一下，也可以用import，这两个区别在以后的nodejs中回去讲解。 2.地图实现2.1 html部分首先在html中需要有放地图的位置，并且有自己的id，这里必须给该 大小，否则echarts显示不出来12&lt;div id = &quot;map&quot; style=&quot;width:600px;height:500px;&quot;&gt;&lt;/div&gt; 2.2 js部分首先把地图对应的json传给echarts1echarts.registerMap(city, resultJson); 之后获取div1let myChart = echarts.init(document.getElementById(&quot;map&quot;)); 之后setoption12345678910111213141516171819202122232425262728293031323334353637383940414243myChart.setOption(&#123; tooltip: &#123;//配置鼠标方式显示提示样式 trigger: &apos;item&apos;, formatter: &apos;&#123;b&#125;:&#123;c&#125;&apos; &#125;, series : [&#123; type: &apos;map&apos;, //设置地图样式，未选中板块的样式和选中板块的样式 itemStyle: &#123; normal: &#123; areaColor: &quot;#00BFFF&quot;, borderWidth: 1, borderColor: &apos;#fff&apos;, color: &apos;#00BFFF&apos;, label: &#123; show: true &#125; &#125;, emphasis: &#123; // 也是选中样式 borderWidth: 1, areaColor: &quot;#58FA82&quot;, borderColor: &apos;#fff&apos;, color: &apos;#32cd32&apos;, label: &#123; show: true, textStyle: &#123; color: &apos;#fff&apos; &#125; &#125; &#125; &#125;, map: city,//要和echarts.registerMap（）中第一个参数一致 label: &#123; normal: &#123; show: true &#125;, emphasis: &#123; show: true &#125; &#125;, data : [&#123;name:&apos;广东&apos;, selected:true , value:100&#125;] &#125;] &#125;) 3.效果 未完，以后关于在地图上添加各种标记也会写在这篇文章中"},{"title":"个人微博——hexo(二)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/hexo2/","text":"4.配置_config.yml4.1 _config.yml常用结构说明直接上我的配置吧123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# Site 网站# 网站标题 title: linjiad_个人博客#网站副标题subtitle: 柳外轻雷池上雨，雨声滴碎荷声#网站描述description: 这个人很懒什么也没写keywords:#您的名字author: linjiad#网站使用的语言language: JS#网站时区。timezone:# URL 网址#网址url: http://linjiad.github.io#网站根目录root: /#文章的 永久链接 格式 :year/:month/:day/:title/permalink: :year/:month/:day/:title/#永久链接中各部分的默认值 permalink_defaults: # Directory 目录# 资源文件夹，这个文件夹用来存放内容。 source_dir: source# 公共文件夹，这个文件夹用于存放生成的站点文件。public_dir: public# 标签文件夹tag_dir: tags# 归档文件夹archive_dir: archives# 分类文件夹category_dir: categories# Include code 文件夹code_dir: downloads/code# 国际化（i18n）文件夹i18n_dir: :lang# 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径skip_render:# Writing 文章# 新文章的文件名称new_post_name: :title.md # File name of new posts#预设布局，以后就在source下的_post下查看文章default_layout: post#把标题转换为 title casetitlecase: false # Transform title into titlecase#在新标签中打开链接external_link: true # Open external links in new tab#把文件名称转换为 (1) 小写或 (2) 大写 filename_case: 0#显示草稿render_drafts: false#启动 Asset 文件夹post_asset_folder: true#把链接改为与根目录的相对位址relative_link: false#显示未来的文章future: true#代码块的设置highlight: enable: true line_number: true auto_detect: false tab_replace: # Home page setting分页index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tag 分类 &amp; 标签、# 默认分类default_category: uncategorized#分类别名 category_map:#标签别名tag_map: # Date / Time format 日期 / 时间格式## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/#日期格式date_format: YYYY-MM-DD#时间格式time_format: HH:mm:ss# Pagination 分页## Set per_page to 0 to disable pagination#每页显示的文章量 (0 = 关闭分页功能)per_page: 10#分页目录pagination_dir: page# Extensions 扩展## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/#当前主题名称。值为false时禁用主题theme: miho# Deployment## Docs: https://hexo.io/docs/deployment.html#部署部分的设置deploy: type: git repo: https://账号:密码@github.com/你的名字/你的名字.github.io.git branch: master 5.主题themes5.1下载themes主题可以在这里找都是免费的哦！看好的主题可以再github中搜索名字，比如我的主题是，miho可以直接搜索点击进入后可以下载成.zip文件，之后再把文件解压到themes下 5.2配置themes之后再设置_config.yml中theme theme: miho 6.图片处理6.1下载图片处理包下载图片处理包 npm install hexo-asset-image –save 6.2配置_config.yml把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true post_asset_folder: true 6.3创建markdown文档再运行hexo new” xxxx” 生成md文件时source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹 6.4放置和调用图片在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：1![你想输入的替代文字](xxxx/图片名.jpg) 7.MIHO主题7.1MIHO配置说明在该主题下会有一个_congig.yml文件，该文件是主题的配置文件_congig.yml配置就不一一说明可以参看README.md或者看这里 7.2MIHO列表图片踩坑这里面还有个大坑，就是列表图片总找不到，原因是路径不对坑在这里改成这个样子123456&lt;% if (post.cover_picture) &#123; %&gt; &lt;img src=\"&lt;%- (/^(http:|https:)?\\/\\//.test(post.cover_picture) ? post.cover_picture :config.url.replace(/\\/$/, '') + '/' + post.cover_picture )%&gt;\" alt=\"&lt;%- post.title %&gt;\" title=\"&lt;%- post.title %&gt;\"&gt; &lt;% &#125; else &#123; %&gt; &lt;img src=\"&lt;%- (/^(http:|https:)?\\/\\//.test(theme.cover_picture) ? theme.cover_picture : config.url.replace(/\\/$/, '') + '/' + theme.cover_picture ) %&gt;\" alt=\"&lt;%- post.title %&gt;\" title=\"&lt;%- post.title %&gt;\"&gt; &lt;% &#125; %&gt; 之后在引用图片的时候需要加日期12345678---title: date: 2018-05-11 09:48:26tags: categories: author: cover_picture: 2018/05/11/hexo2/menu.png--- 图片日期需要和date保持一致 8.尾声常用命令12345678910hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo generate 生成静态文件。hexo deploy 部署网站hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式hexo new page \"about\" 创建新的连接目录hexo new '文章名' 创建新的文件 更多需求可查询hexo官网更多miho主题可查询miho该项目地址放在这儿啦"},{"title":"个人微博——hexo(一)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/hexo1/","text":"用hexo和github搭建个人 免费 博客免费 对我我这种穷人来说显得弥足珍贵 0.导言0.1 个人微博技术个人微博技术有很对，4-12日尤大神发布了VuePress，大神本来想写文档，结果码出了一套框架（容我做一个悲伤的表情），大神就是大神。不过新框架还在不断完善，存在太多坑，这里就先不说VuePress，以后框架完善后再说。这里就聊一聊老牌的微博框架hexo 0.2 hexohexo是一个框架，简洁明朗，基于node，一键部署，并且支持MarkDown，现在微博基本上内容都是用MarkDown来写，而且还有很多 免费 框架哦！之前想写一个微博，用nodejs后台，前端用vue来写，还得弄服务器什么的，超级麻烦。后来学了下hexo，真的超级轻量！(我的废话真多)。 1.安装1.1 安装nodejshexo是基于nodejs，需要nodejs，还不会可以面壁了 1.2 安装hexohexo需要安装全局变量 npm install hexo-cli -g 1.3 安装git去这里https://git-scm.com/downloads毫无压力的进行安装吧 2.快速在本地开始2.1 开始命令 hexo i blog //init的缩写 blog是项目名 hexo初始化hexo cd blog //切换到站点根目录 切换到该目录下，或者直接在该目录下打开控制台 hexo g //generetor的缩写 在此之前可以先clean下，然后生成项目 hexo s //server的缩写 启动本地服务器 2.2 查看成果 打开浏览器输入localhost:4000查看： 2.3 目录结构在初始化的目录下会看到该目录结构一个崭新的博客页面出现在面前123456789node_modules：是依赖包public：存放的是生成的页面;clean会删除;generetor会生成scaffolds：命令生成文章等的模板source：用命令创建的各种文章，以后都在这里写自己的文章themes：主题；存放自己喜欢的主题并使用_config.yml：整个博客的配置db.json：source解析所得到的(我也不大清楚)package.json：项目所需模块项目的配置信息package-lock.json：nodejs升级后存储更细节的包版本，以后写nodejs会详细说明 2.4 安装hexo-server这里需要踩个坑，exo 3.0把服务器独立成个别模块，需要单独安装： npm i hexo-server 3.配置github3.1 在github上创建项目没有账号的自己注册创建新的项目创建项目，输入地址名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建才有用！并且以后yourname.github.io就是你的博客地址，之后点击2创建 3.2 配置github私钥个人觉得这个配置后只能在该电脑使用，像我一样在公司台式机的朋友梦用其他电脑配置会哭的，这里就先不用私钥的办法，后面会说一个更好的方法。 3.2 安装deployer安装deployer后才能美美哒配置发布到网上 npm install hexo-deployer-git –save 之后需要在_config.yml末尾处加入一段代码1234deploy: type: git repo: https://github.com/YourgithubName/YourgithubName.github.io.git branch: master 重点说明一下repo:1https://+用户名:密码+@+github.com/+ 1+.git 这里可以接刚才说的更好的方法 3.2 发布博客这时候小伙伴可以愉快的发布了建议执行命令按顺序执行123hexo cleanhexo generatehexo deploy 3.4 查看博客在浏览器中输入https://刚才的名字.github.io/进行访问"},{"title":"nodeppt(二)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt2/","text":"4.nodeppt书写nodeppt只要是符合markdown语法即可，也支持HTML混编 4.2 总的配置title: 这是title，网页名称speaker: 演讲者名称url:transition: 全局转场动效files: 引入的js和css文件，多个以半角逗号隔开theme: 皮肤样式highlightStyle: 代码高亮样式，默认monokai_sublimeusemathjax: yes 启用MathJax渲染公式 4.2 每一页间隔[slide]nodeppt用[slide]来区分每一页PPT [slide]第一页[slide]第二页[slide] 4.3 样式基于GFM的markdown语法编写 {:&amp;.rollIn} 需要改变样式的话后面直接加{:&amp;.flexbox.vleft}(该样式为居左) 4.4 背景图片完全style写法，更加灵活，视频背景、repeat背景更不在话下 [slide style=”background-image:url(‘/img/bg1.png’)”] 4.5 上下分界线 四个”-“是上下分界线 4.6 表格 Less Sass Stylus 环境 js/nodejs Ruby(这列右对齐) nodejs(高亮) {:.highlight} 扩展名 .less .scss/.sass .styl 特点 老牌，用户多，支持js解析 功能全，有成型框架，发展快 语法多样，小众 案例/框架 Bootstrap Compass Bootstrap Foundation Bourbon Base.Sass 123456| Less | Sass | Stylus:-------|:------:|-------:|--------环境 |js/nodejs | Ruby(这列右对齐) | nodejs(高亮) &#123;:.highlight&#125;扩展名 | .less | .scss/.sass | .styl特点 | 老牌，用户多，支持js解析 | 功能全，有成型框架，发展快 | 语法多样，小众案例/框架 | [Bootstrap](http://getbootstrap.com/) | [Compass](http://beta.compass-style.org) [Bootstrap](http://getbootstrap.com/css/#sass) [Foundation](http://foundation.zurb.com/) [Bourbon](http://bourbon.io) [Base.Sass](https://github.com/jsw0528/base.sass) | 4.7 text文字样式如图所示：展示如图效果12345678910&lt;span class=\"text-danger\"&gt;.text-danger&lt;/span&gt; &lt;span class=\"text-success\"&gt;.text-success&lt;/span&gt;&lt;span class=\"text-primary\"&gt;.text-primary&lt;/span&gt;&lt;span class=\"text-warning\"&gt;.text-warning&lt;/span&gt;&lt;span class=\"text-info\"&gt;.text-info&lt;/span&gt;&lt;span class=\"text-white\"&gt;.text-white&lt;/span&gt;&lt;span class=\"text-dark\"&gt;.text-dark&lt;/span&gt;&lt;span class=\"blue\"&gt;.blue&lt;/span&gt;&lt;span class=\"blue2\"&gt;.blue2&lt;/span&gt;&lt;span class=\"blue3\"&gt;.blue3&lt;/span&gt;&lt;span class=\"gray\"&gt;.gray&lt;/span&gt;&lt;span class=\"gray2\"&gt;.gray2&lt;/span&gt;&lt;span class=\"gray3\"&gt;.gray3&lt;/span&gt;&lt;span class=\"red\"&gt;.red&lt;/span&gt;&lt;span class=\"red2\"&gt;.red2&lt;/span&gt;&lt;span class=\"red3\"&gt;.red3&lt;/span&gt;&lt;span class=\"yellow\"&gt;.yellow&lt;/span&gt;&lt;span class=\"yellow2\"&gt;.yellow2&lt;/span&gt;&lt;span class=\"yellow3\"&gt;.yellow3&lt;/span&gt;&lt;span class=\"green\"&gt;.green&lt;/span&gt;&lt;span class=\"green2\"&gt;.green2&lt;/span&gt;&lt;span class=\"green3\"&gt;.green3&lt;/span&gt; 4.8 label如图所示：展示如图效果12345&lt;span class=\"label label-primary\"&gt;.label.label-primary&lt;/span&gt;&lt;span class=\"label label-warning\"&gt;.label.label-warning&lt;/span&gt;&lt;span class=\"label label-danger\"&gt;.label.label-danger&lt;/span&gt;&lt;span class=\"label label-default\"&gt;.label.label-default&lt;/span&gt;&lt;span class=\"label label-success\"&gt;.label.label-success&lt;/span&gt;&lt;span class=\"label label-info\"&gt;.label.label-info&lt;/span&gt;&lt;a href=\"#\"&gt;link style&lt;/a&gt; &lt;mark&gt;mark&lt;/mark&gt; 4.9 blockquoteblockquote ：如图所示：12nodeppt可能是迄今为止最好用的web presentation &lt;small&gt;三水清&lt;/small&gt;这是一个class是：pull-right的blockquote &lt;small&gt;small一下&lt;/small&gt; &#123;:&amp;.pull-right&#125; 4.10 buttons如图所示：123456&lt;button class=\"btn btn-default\"&gt;.btn .btn-default&lt;/button&gt; &lt;button class=\"btn btn-primary\"&gt;.btn.btn-lg.btn-primary&lt;/button&gt; &lt;button class=\"btn btn-warning\"&gt;.btn.btn-waring&lt;/button&gt; &lt;button class=\"btn btn-success\"&gt;.btn.btn-success&lt;/button&gt; &lt;button class=\"btn btn-danger\"&gt;.btn.btn-danger&lt;/button&gt;&lt;button class=\"btn btn-lg btn-default\"&gt;.btn.btn-lg.btn-default&lt;/button&gt; &lt;button class=\"btn btn-xs btn-success\"&gt;.btn.btn-xs.btn-success&lt;/button&gt; &lt;button class=\"btn btn-sm btn-primary\"&gt;.btn.btn-sm.btn-primary&lt;/button&gt; &lt;button class=\"btn btn-rounded btn-warning\"&gt;.btn.btn-rounded.btn-waring&lt;/button&gt; &lt;button class=\"btn btn-danger\" disabled=\"disabled\"&gt;disabled.btn.btn-danger&lt;/button&gt;&lt;button class=\"btn btn-success\"&gt;&lt;i class=\"fa fa-share mr5\"&gt;&lt;/i&gt;&lt;/button&gt; 4.11 icons如图所示：1234567891011&lt;i class=\"fa fa-apple\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-android\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-github\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-google\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-linux\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-css3\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-html5\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-usd\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-pie-chart\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-file-video-o\"&gt;&lt;/i&gt;&lt;i class=\"fa fa-cog\"&gt;&lt;/i&gt; 4.12 代码格式化使用 highlightjs 进行语法高亮如图所示：1234567891011121314151617181920212223242526&lt;div class=\"columns-2\"&gt; &lt;pre&gt;&lt;code class=\"javascript\"&gt;(function(window, document)&#123; var a = 1; var test = function()&#123; var b = 1; alert(b); &#125;; //泛数组转换为数组 function toArray(arrayLike) &#123; return [].slice.call(arrayLike); &#125;&#125;(window, document)); &lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=\"javascript\"&gt;(function(window, document)&#123; var a = 1; var test = function()&#123; var b = 1; alert(b); &#125;; //泛数组转换为数组 function toArray(arrayLike) &#123; return [].slice.call(arrayLike); &#125;&#125;(window, document)); &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; 4.13 语法混编使用 highlightjs 进行语法高亮如图所示：12345678910111213141516171819&lt;div class=\"file-setting\"&gt; &lt;p&gt;这是html&lt;/p&gt;&lt;/div&gt;&lt;p id=\"css-demo\"&gt;这是css样式&lt;/p&gt;&lt;p&gt;将html代码直接混编到**markdown**文件中即可&lt;/p&gt;我是js控制的颜色 black &#123;:#testScriptTag&#125;&lt;script&gt; function testScriptTag()&#123; document.getElementById('testScriptTag').style.color = 'black'; &#125;&lt;/script&gt;&lt;style&gt;#css-demo&#123; color: red;&#125;&lt;/style&gt; 4.14 iframe如图所示：1&lt;iframe data-src=\"http://www.baidu.com\" src=\"about:blank;\"&gt;&lt;/iframe&gt; 4.15 链接标签链接到百度1[链接到百度](https://www.baidu.com) 5.效果设置5.1 多种皮肤修改url可以改变皮肤如图所示：也可以通过代码点击实现1234567&lt;div class=\"columns6\"&gt; &lt;a href=\"?theme=color\" &gt;color&lt;/a&gt; &lt;a href=\"?theme=blue\"&gt;blue&lt;/a&gt; &lt;a href=\"?theme=dark\"&gt;dark&lt;/a&gt; &lt;a href=\"?theme=green\"&gt;green&lt;/a&gt; &lt;a href=\"?theme=light\"&gt;light&lt;/a&gt;&lt;/div&gt; 5.1 单页面转场设置[magic]中data-transition属性设置转场效果[magic][/magic]中间用========隔开两个div1234567891011121314[magic data-transition=\"earthquake\"]&lt;div class=\"columns3\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt; &lt;img src=\"/girl.jpg\" height=\"450\"&gt;&lt;/div&gt;========&lt;div class=\"columns4\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt; &lt;img src=\"/girl.jpg\" height=\"320\"&gt;&lt;/div&gt;[/magic] 5.2 相同页面转场设置 列表支持渐显动效哦 {:&amp;.动效类型} markdown列表第一条加上：{:&amp;.动效类型} markdown列表第一条加上： markdown列表第一条加上： 动效类型 fadeIn淡出淡入 {:&amp;.动效类型} rollIn从后向前放大 bounceIn弹出并震动 moveIn zoomIn从后向前放大 5.3 全局设置前面说过在PPT开头 transition: glue 5.4 页面之间设置在每个页面可以设置自己的转场效果 [slide data-transition=”zoomin”] 5.5 转场url设置在url后加上?transition=newspaper如图所示 slide/slide2/slide3newspapergluekontext/vkontextmove/circlehorizontal/horizontal3dvertical3dzoomin/zoomoutcardsearthquake/pulse/stick 这些转场效果慢慢试吧"},{"title":"nodeppt(一)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt1/","text":"是时候放弃微软的PPT,改用一款够装X够D的利器，nodeppt 0.导言0.1 nodeppt好处基于markdown编写,支持HTML混编对于程序员来说更方便 1.开始1.1 安装前准备不多说了，既然是nodeppt，顾名思义需要安装node，去官网下载即可,好无悬念下一步下一步，安装成功后再控制台查看版本，出现版本号即为安装成功。 1.2 安装nodepptnodeppt需要全局安装 npm install -g nodeppt 同样安装之后查看版本号 nodeppt -v 效果如图这样nodeppt就安装成功，安装成功后可以在控制台打开任意位置的markdown文件，开始表演真正的技术啦！Show Time！ 2.nodeppt命令2.1 获取帮助通过命令获取帮助，查看更多命令 nodeppt start -h 2.2 启动nodeppt-p为端口号-d为路径 nodeppt start -p -d path/for/ppts 例如： nodeppt start -p 8080 -d E:\\私人办公\\ppts 2.3 启动成功启动成功后弹出页面如图所示点击即可弹出页面 3.nodeppt基本操作3.0 页面菜单如图所示，在该位置分别有按钮上一页，下一页，画笔，浏览模式。可分别点击进行操作 3.1 翻页可以按 空格 ，向右 进行下一页/下一步。向左 上一步/上一页 3.2 画笔按 P 打开画笔 ，再次按 P 清空画板 ，按 C 清空画板并关闭画笔画板打开期间可以用 1-4 来选择画笔粗细， B Y G等颜色首字母选择颜色 3.3 表格放大在展示表格的页面按 w 使表格放大 3.4 浏览模式按 O 打开浏览模式，如图所示：，可以浏览选择需要的PPT页面 3.5 多窗口演示可以电脑分屏，自己看一个窗口，分享另一个窗口，这样演讲起来可以预先组织语言。 网址改成url?_multiscreen=1, 这里有个坑，这时候可能多窗口无法使用，请看浏览器右上角收藏旁边，点开，点允许即可。 3.6 打开note笔记按下键盘【N】打开note笔记 3.7 手机控制目前还没成功"},{"title":"nodeppt(三)","date":"2018-05-11T01:48:26.000Z","path":"2018/05/11/nodeppt3/","text":"6.装逼利器文字强调6.1 加粗加粗 6.2 字体闪烁em这时按下 H em会闪烁 6.3 放大增加了zoom.js的支持，在演示过程中使用alt+鼠标点击，则点击的地方就开始放大，再次alt+click则回复原状 6.4 使用note笔记用[note][/note]标签包含笔记文字 [note]这里是note笔记使用n键，才能显示[/note] 按下键盘【N】键打开[note]之中内容，否则不显示 7.图片处理7.1 引入图片1![小萝莉](nodeppt3/girl.jpg \"小萝莉\") 和1&lt;img src=\"/girl.jpg\"&gt; 都可以引入图片并且点击图片可放大 7.1 图片禁止放大只需要加个样式即可1&lt;img src=\"/girl.jpg\" class=\"no-screenfull\"&gt; 8.nodeppt的函数和事件8.1 单个slide事件[slide] 中使用data-on-X来指定一个全局函数名123build：当触发下一步操作的时会触发，event具有stop方法keypress：在当前页面按键触发，event具有stop方法enter/leave：进入/离开 此页面触发的事件，event无stop方法 8.2 回调123456[slide data-on-leave=\"fnName\"]进入执行回调incallback函数[slide data-on-enter=\"fnName\"]退出执行outcallback函数亦可以组合写：[slide data-on-leave=\"foo\" data-on-enter=\"bar\"] 8.3 远程执行函数开玩笑远程现在还不好用呢等以后在更新吧 9.后记了解更多内容请点击源代码下载PPT实例请点击，摘自源代码"}]